<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Mbed OS Reference: USBPhy Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="mbed-ce_55x55.png"/></td>
  <td id="projectalign">
   <div id="projectname">Mbed OS Reference
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('class_u_s_b_phy.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle"><div class="title">USBPhy Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>Abstract interface to physical USB hardware.  
 <a href="class_u_s_b_phy.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_u_s_b_phy_8h_source.html">USBPhy.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for USBPhy:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_u_s_b_phy.png" usemap="#USBPhy_map" alt=""/>
  <map id="USBPhy_map" name="USBPhy_map">
<area href="class_u_s_b_phy_hw.html" alt="USBPhyHw" shape="rect" coords="0,56,76,80"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa58d2212e6028f891db3cdb2067d617e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_s_b_phy.html#aa58d2212e6028f891db3cdb2067d617e">init</a> (<a class="el" href="class_u_s_b_phy_events.html">USBPhyEvents</a> *events)=0</td></tr>
<tr class="memdesc:aa58d2212e6028f891db3cdb2067d617e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize this <a class="el" href="class_u_s_b_phy.html" title="Abstract interface to physical USB hardware.">USBPhy</a> instance.  <a href="class_u_s_b_phy.html#aa58d2212e6028f891db3cdb2067d617e">More...</a><br /></td></tr>
<tr class="separator:aa58d2212e6028f891db3cdb2067d617e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a5b1b963d05fc3e18287ecefe1dca6f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_s_b_phy.html#a0a5b1b963d05fc3e18287ecefe1dca6f">deinit</a> ()=0</td></tr>
<tr class="memdesc:a0a5b1b963d05fc3e18287ecefe1dca6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Power down this <a class="el" href="class_u_s_b_phy.html" title="Abstract interface to physical USB hardware.">USBPhy</a> instance.  <a href="class_u_s_b_phy.html#a0a5b1b963d05fc3e18287ecefe1dca6f">More...</a><br /></td></tr>
<tr class="separator:a0a5b1b963d05fc3e18287ecefe1dca6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73239969cf916c1be67a2fcf5e608376"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_s_b_phy.html#a73239969cf916c1be67a2fcf5e608376">powered</a> ()=0</td></tr>
<tr class="memdesc:a73239969cf916c1be67a2fcf5e608376"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if USB power is present.  <a href="class_u_s_b_phy.html#a73239969cf916c1be67a2fcf5e608376">More...</a><br /></td></tr>
<tr class="separator:a73239969cf916c1be67a2fcf5e608376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47369b82ef0f5ff7aed2bd0cd82c2ca9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_s_b_phy.html#a47369b82ef0f5ff7aed2bd0cd82c2ca9">connect</a> ()=0</td></tr>
<tr class="memdesc:a47369b82ef0f5ff7aed2bd0cd82c2ca9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make the USB phy visible to the USB host.  <a href="class_u_s_b_phy.html#a47369b82ef0f5ff7aed2bd0cd82c2ca9">More...</a><br /></td></tr>
<tr class="separator:a47369b82ef0f5ff7aed2bd0cd82c2ca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4b9cc415683acddaa6545ffb693fb23"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_s_b_phy.html#ac4b9cc415683acddaa6545ffb693fb23">disconnect</a> ()=0</td></tr>
<tr class="memdesc:ac4b9cc415683acddaa6545ffb693fb23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach the USB phy.  <a href="class_u_s_b_phy.html#ac4b9cc415683acddaa6545ffb693fb23">More...</a><br /></td></tr>
<tr class="separator:ac4b9cc415683acddaa6545ffb693fb23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4ef25fc219d0a045a65041ec74906c1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_s_b_phy.html#ae4ef25fc219d0a045a65041ec74906c1">configure</a> ()=0</td></tr>
<tr class="memdesc:ae4ef25fc219d0a045a65041ec74906c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set this device to the configured state.  <a href="class_u_s_b_phy.html#ae4ef25fc219d0a045a65041ec74906c1">More...</a><br /></td></tr>
<tr class="separator:ae4ef25fc219d0a045a65041ec74906c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74193359376d12a7806d862ac0feae9d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_s_b_phy.html#a74193359376d12a7806d862ac0feae9d">unconfigure</a> ()=0</td></tr>
<tr class="memdesc:a74193359376d12a7806d862ac0feae9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Leave the configured state.  <a href="class_u_s_b_phy.html#a74193359376d12a7806d862ac0feae9d">More...</a><br /></td></tr>
<tr class="separator:a74193359376d12a7806d862ac0feae9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e18caf3b51bff18982c36a8546b7712"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_s_b_phy.html#a8e18caf3b51bff18982c36a8546b7712">sof_enable</a> ()=0</td></tr>
<tr class="memdesc:a8e18caf3b51bff18982c36a8546b7712"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable the start of frame interrupt.  <a href="class_u_s_b_phy.html#a8e18caf3b51bff18982c36a8546b7712">More...</a><br /></td></tr>
<tr class="separator:a8e18caf3b51bff18982c36a8546b7712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cd67a5a4e8a21c155dca647b1b5a6f7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_s_b_phy.html#a8cd67a5a4e8a21c155dca647b1b5a6f7">sof_disable</a> ()=0</td></tr>
<tr class="memdesc:a8cd67a5a4e8a21c155dca647b1b5a6f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable the start of frame interrupt.  <a href="class_u_s_b_phy.html#a8cd67a5a4e8a21c155dca647b1b5a6f7">More...</a><br /></td></tr>
<tr class="separator:a8cd67a5a4e8a21c155dca647b1b5a6f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a047021c7fd6ae8ed0aff2fa547031670"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_s_b_phy.html#a047021c7fd6ae8ed0aff2fa547031670">set_address</a> (uint8_t address)=0</td></tr>
<tr class="memdesc:a047021c7fd6ae8ed0aff2fa547031670"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the <a class="el" href="class_u_s_b_phy.html" title="Abstract interface to physical USB hardware.">USBPhy</a>'s address.  <a href="class_u_s_b_phy.html#a047021c7fd6ae8ed0aff2fa547031670">More...</a><br /></td></tr>
<tr class="separator:a047021c7fd6ae8ed0aff2fa547031670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6774032bc516c88938ad5bf302a59ddc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_s_b_phy.html#a6774032bc516c88938ad5bf302a59ddc">remote_wakeup</a> ()=0</td></tr>
<tr class="memdesc:a6774032bc516c88938ad5bf302a59ddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wake upstream devices.  <a href="class_u_s_b_phy.html#a6774032bc516c88938ad5bf302a59ddc">More...</a><br /></td></tr>
<tr class="separator:a6774032bc516c88938ad5bf302a59ddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d7bb2640b5965b8f6d67707ee31ec43"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="structusb__ep__table__t.html">usb_ep_table_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_s_b_phy.html#a2d7bb2640b5965b8f6d67707ee31ec43">endpoint_table</a> ()=0</td></tr>
<tr class="memdesc:a2d7bb2640b5965b8f6d67707ee31ec43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the endpoint table.  <a href="class_u_s_b_phy.html#a2d7bb2640b5965b8f6d67707ee31ec43">More...</a><br /></td></tr>
<tr class="separator:a2d7bb2640b5965b8f6d67707ee31ec43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7087cc06f0bf8f1c50c097a775cde528"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_s_b_phy.html#a7087cc06f0bf8f1c50c097a775cde528">ep0_set_max_packet</a> (uint32_t max_packet)=0</td></tr>
<tr class="memdesc:a7087cc06f0bf8f1c50c097a775cde528"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set wMaxPacketSize of endpoint 0.  <a href="class_u_s_b_phy.html#a7087cc06f0bf8f1c50c097a775cde528">More...</a><br /></td></tr>
<tr class="separator:a7087cc06f0bf8f1c50c097a775cde528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c4e065017c56cea38b1bf31228a1227"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_s_b_phy.html#a8c4e065017c56cea38b1bf31228a1227">ep0_setup_read_result</a> (uint8_t *buffer, uint32_t size)=0</td></tr>
<tr class="memdesc:a8c4e065017c56cea38b1bf31228a1227"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the contents of the SETUP packet.  <a href="class_u_s_b_phy.html#a8c4e065017c56cea38b1bf31228a1227">More...</a><br /></td></tr>
<tr class="separator:a8c4e065017c56cea38b1bf31228a1227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afab7b1ac8b0aded8a16ed9b2e06a44b7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_s_b_phy.html#afab7b1ac8b0aded8a16ed9b2e06a44b7">ep0_read</a> (uint8_t *data, uint32_t size)=0</td></tr>
<tr class="memdesc:afab7b1ac8b0aded8a16ed9b2e06a44b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start receiving a packet of up to wMaxPacketSize on endpoint 0.  <a href="class_u_s_b_phy.html#afab7b1ac8b0aded8a16ed9b2e06a44b7">More...</a><br /></td></tr>
<tr class="separator:afab7b1ac8b0aded8a16ed9b2e06a44b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a887c3a3ef21f3a99aaefafc1c3ec2774"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_s_b_phy.html#a887c3a3ef21f3a99aaefafc1c3ec2774">ep0_read_result</a> ()=0</td></tr>
<tr class="memdesc:a887c3a3ef21f3a99aaefafc1c3ec2774"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the contents of a received packet.  <a href="class_u_s_b_phy.html#a887c3a3ef21f3a99aaefafc1c3ec2774">More...</a><br /></td></tr>
<tr class="separator:a887c3a3ef21f3a99aaefafc1c3ec2774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af036c42fa5434f5881b704ee09a9ed65"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_s_b_phy.html#af036c42fa5434f5881b704ee09a9ed65">ep0_write</a> (uint8_t *buffer, uint32_t size)=0</td></tr>
<tr class="memdesc:af036c42fa5434f5881b704ee09a9ed65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a packet on endpoint 0.  <a href="class_u_s_b_phy.html#af036c42fa5434f5881b704ee09a9ed65">More...</a><br /></td></tr>
<tr class="separator:af036c42fa5434f5881b704ee09a9ed65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa368765be668dc5d21f3c190b38c34f3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_s_b_phy.html#aa368765be668dc5d21f3c190b38c34f3">ep0_stall</a> ()=0</td></tr>
<tr class="memdesc:aa368765be668dc5d21f3c190b38c34f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Protocol stall on endpoint 0.  <a href="class_u_s_b_phy.html#aa368765be668dc5d21f3c190b38c34f3">More...</a><br /></td></tr>
<tr class="separator:aa368765be668dc5d21f3c190b38c34f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac70515099d7d499ef2756f9c5668ef46"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_s_b_phy.html#ac70515099d7d499ef2756f9c5668ef46">endpoint_add</a> (usb_ep_t endpoint, uint32_t max_packet, usb_ep_type_t type)=0</td></tr>
<tr class="memdesc:ac70515099d7d499ef2756f9c5668ef46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure and enable an endpoint.  <a href="class_u_s_b_phy.html#ac70515099d7d499ef2756f9c5668ef46">More...</a><br /></td></tr>
<tr class="separator:ac70515099d7d499ef2756f9c5668ef46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2df969814bbc2e391ddc318a10a1e1ff"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_s_b_phy.html#a2df969814bbc2e391ddc318a10a1e1ff">endpoint_remove</a> (usb_ep_t endpoint)=0</td></tr>
<tr class="memdesc:a2df969814bbc2e391ddc318a10a1e1ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable an endpoint.  <a href="class_u_s_b_phy.html#a2df969814bbc2e391ddc318a10a1e1ff">More...</a><br /></td></tr>
<tr class="separator:a2df969814bbc2e391ddc318a10a1e1ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab71d67a4871c928d6d398288304d1c9b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_s_b_phy.html#ab71d67a4871c928d6d398288304d1c9b">endpoint_stall</a> (usb_ep_t endpoint)=0</td></tr>
<tr class="memdesc:ab71d67a4871c928d6d398288304d1c9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a functional stall on the given endpoint.  <a href="class_u_s_b_phy.html#ab71d67a4871c928d6d398288304d1c9b">More...</a><br /></td></tr>
<tr class="separator:ab71d67a4871c928d6d398288304d1c9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ec485b9f7d5d50f88f9d5fab5690d5b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_s_b_phy.html#a2ec485b9f7d5d50f88f9d5fab5690d5b">endpoint_unstall</a> (usb_ep_t endpoint)=0</td></tr>
<tr class="memdesc:a2ec485b9f7d5d50f88f9d5fab5690d5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Un-stall the endpoint.  <a href="class_u_s_b_phy.html#a2ec485b9f7d5d50f88f9d5fab5690d5b">More...</a><br /></td></tr>
<tr class="separator:a2ec485b9f7d5d50f88f9d5fab5690d5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e04a43787520f019444c299454a0021"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_s_b_phy.html#a1e04a43787520f019444c299454a0021">endpoint_read</a> (usb_ep_t endpoint, uint8_t *data, uint32_t size)=0</td></tr>
<tr class="memdesc:a1e04a43787520f019444c299454a0021"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a read on the given endpoint.  <a href="class_u_s_b_phy.html#a1e04a43787520f019444c299454a0021">More...</a><br /></td></tr>
<tr class="separator:a1e04a43787520f019444c299454a0021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32ae5ca2ffa9395b6ce2c7080f0adee9"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_s_b_phy.html#a32ae5ca2ffa9395b6ce2c7080f0adee9">endpoint_read_result</a> (usb_ep_t endpoint)=0</td></tr>
<tr class="memdesc:a32ae5ca2ffa9395b6ce2c7080f0adee9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finish a read on the given endpoint.  <a href="class_u_s_b_phy.html#a32ae5ca2ffa9395b6ce2c7080f0adee9">More...</a><br /></td></tr>
<tr class="separator:a32ae5ca2ffa9395b6ce2c7080f0adee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a5825552cdaa64b8916b626ca9e546e"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_s_b_phy.html#a8a5825552cdaa64b8916b626ca9e546e">endpoint_write</a> (usb_ep_t endpoint, uint8_t *data, uint32_t size)=0</td></tr>
<tr class="memdesc:a8a5825552cdaa64b8916b626ca9e546e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a write on the given endpoint.  <a href="class_u_s_b_phy.html#a8a5825552cdaa64b8916b626ca9e546e">More...</a><br /></td></tr>
<tr class="separator:a8a5825552cdaa64b8916b626ca9e546e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae551659076ba4ae394bc5d602ca00dc8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_s_b_phy.html#ae551659076ba4ae394bc5d602ca00dc8">endpoint_abort</a> (usb_ep_t endpoint)=0</td></tr>
<tr class="memdesc:ae551659076ba4ae394bc5d602ca00dc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abort the current transfer if it has not yet been sent.  <a href="class_u_s_b_phy.html#ae551659076ba4ae394bc5d602ca00dc8">More...</a><br /></td></tr>
<tr class="separator:ae551659076ba4ae394bc5d602ca00dc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a142b75b68a6291400e20fb0dd905b1c8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_s_b_phy.html#a142b75b68a6291400e20fb0dd905b1c8">process</a> ()=0</td></tr>
<tr class="memdesc:a142b75b68a6291400e20fb0dd905b1c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback used for performing USB processing.  <a href="class_u_s_b_phy.html#a142b75b68a6291400e20fb0dd905b1c8">More...</a><br /></td></tr>
<tr class="separator:a142b75b68a6291400e20fb0dd905b1c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Abstract interface to physical USB hardware. </p>
<h1><a class="anchor" id="autotoc_md62"></a>
Defined behavior</h1>
<ul>
<li>You can use any endpoint configurations that fit in the parameters of the table returned by <a class="el" href="class_u_s_b_phy.html#a2d7bb2640b5965b8f6d67707ee31ec43" title="Get the endpoint table.">USBPhy::endpoint_table</a>.</li>
<li>You can use all endpoints in any valid endpoint configuration concurrently.</li>
<li>The device supports use of at least one control, bulk, interrupt and isochronous in each direction at the same time - at least 8 endpoints.</li>
<li><a class="el" href="class_u_s_b_phy.html" title="Abstract interface to physical USB hardware.">USBPhy</a> supports all standard endpoint sizes (wMaxPacketSize).</li>
<li><a class="el" href="class_u_s_b_phy.html" title="Abstract interface to physical USB hardware.">USBPhy</a> can handle an interrupt latency of at least 100ms if the host PC is not performing a reset or setting the device's address.</li>
<li><a class="el" href="class_u_s_b_phy.html" title="Abstract interface to physical USB hardware.">USBPhy</a> only sends <a class="el" href="class_u_s_b_phy_events.html" title="Event handler for USBPhy.">USBPhyEvents</a> when it is in the initialized state.</li>
<li>When unpowered, <a class="el" href="class_u_s_b_phy.html" title="Abstract interface to physical USB hardware.">USBPhy</a> only sends the <a class="el" href="class_u_s_b_phy_events.html#a0e153d20beec9b7e5bc8314d6fcc765d" title="Callback called USB power is applied or removed.">USBPhyEvents::power</a> event.</li>
<li>On USB reset, all endpoints are removed except for endpoint 0.</li>
<li>A call to <a class="el" href="class_u_s_b_phy.html#af036c42fa5434f5881b704ee09a9ed65" title="Write a packet on endpoint 0.">USBPhy::ep0_write</a> results in the call of <a class="el" href="class_u_s_b_phy_events.html#abccfc5d4ae87ca7c59e498adc5626a3e" title="Callback called on the transmission of an IN packet.">USBPhyEvents::in</a> when the PC reads the data unless a power loss, reset, or a call to <a class="el" href="class_u_s_b_phy.html#ac4b9cc415683acddaa6545ffb693fb23" title="Detach the USB phy.">USBPhy::disconnect</a> occurs first.</li>
<li>A call to <a class="el" href="class_u_s_b_phy.html#a8a5825552cdaa64b8916b626ca9e546e" title="Start a write on the given endpoint.">USBPhy::endpoint_write</a> results in the call of <a class="el" href="class_u_s_b_phy_events.html#abccfc5d4ae87ca7c59e498adc5626a3e" title="Callback called on the transmission of an IN packet.">USBPhyEvents::in</a> when the pc reads the data unless a power loss, reset, or a call to <a class="el" href="class_u_s_b_phy.html#ae551659076ba4ae394bc5d602ca00dc8" title="Abort the current transfer if it has not yet been sent.">USBPhy::endpoint_abort</a> occurs first.</li>
<li>A call to <a class="el" href="class_u_s_b_phy.html#a1e04a43787520f019444c299454a0021" title="Start a read on the given endpoint.">USBPhy::endpoint_read</a> results in the call of <a class="el" href="class_u_s_b_phy_events.html#a13a457fcd37db7e17f97501d9200a5db" title="Callback called on the reception of an OUT packet.">USBPhyEvents::out</a> when the pc sends data unless a power loss, reset, or a call to <a class="el" href="class_u_s_b_phy.html#ae551659076ba4ae394bc5d602ca00dc8" title="Abort the current transfer if it has not yet been sent.">USBPhy::endpoint_abort</a> occurs first.</li>
<li>Endpoint 0 naks all transactions aside from setup packets until higher-level code calls one of <a class="el" href="class_u_s_b_phy.html#afab7b1ac8b0aded8a16ed9b2e06a44b7" title="Start receiving a packet of up to wMaxPacketSize on endpoint 0.">USBPhy::ep0_read</a>, <a class="el" href="class_u_s_b_phy.html#af036c42fa5434f5881b704ee09a9ed65" title="Write a packet on endpoint 0.">USBPhy::ep0_write</a> or <a class="el" href="class_u_s_b_phy.html#aa368765be668dc5d21f3c190b38c34f3" title="Protocol stall on endpoint 0.">USBPhy::ep0_stall</a>.</li>
<li>Endpoint 0 stall automatically clears on reception of a setup packet.</li>
</ul>
<h1><a class="anchor" id="autotoc_md63"></a>
Undefined behavior</h1>
<ul>
<li>Calling <a class="el" href="class_u_s_b_phy.html#ac70515099d7d499ef2756f9c5668ef46" title="Configure and enable an endpoint.">USBPhy::endpoint_add</a> or <a class="el" href="class_u_s_b_phy.html#a2df969814bbc2e391ddc318a10a1e1ff" title="Disable an endpoint.">USBPhy::endpoint_remove</a> outside of the control requests SetInterface or SetConfiguration.</li>
<li>Calling <a class="el" href="class_u_s_b_phy.html#a2df969814bbc2e391ddc318a10a1e1ff" title="Disable an endpoint.">USBPhy::endpoint_remove</a> on an endpoint that has an ongoing read or write operation. To avoid undefined behavior, you must abort ongoing operations with <a class="el" href="class_u_s_b_phy.html#ae551659076ba4ae394bc5d602ca00dc8" title="Abort the current transfer if it has not yet been sent.">USBPhy::endpoint_abort</a>.</li>
<li>Devices behavior is undefined if latency is greater than 2ms when address is being set - see USB spec 9.2.6.3.</li>
<li>Devices behavior is undefined if latency is greater than 10ms when a reset occurs - see USB spec 7.1.7.5.</li>
<li>Calling any of the USBPhy::endpoint_* functions on endpoint 0.</li>
</ul>
<h1><a class="anchor" id="autotoc_md64"></a>
Notes</h1>
<ul>
<li>Make sure <a class="el" href="class_u_s_b_phy.html" title="Abstract interface to physical USB hardware.">USBPhy</a> sends <a class="el" href="class_u_s_b_phy_events.html" title="Event handler for USBPhy.">USBPhyEvents</a> in the correct order when multiple packets are present. <a class="el" href="class_u_s_b_phy.html" title="Abstract interface to physical USB hardware.">USBPhy</a> must send IN endpoint events before OUT endpoint events if both are pending.</li>
<li>A host PC may resend setup packets to a USB device if there is noise on the USB line. The <a class="el" href="class_u_s_b_phy.html" title="Abstract interface to physical USB hardware.">USBPhy</a> should be able to handle this scenario and respond to the setup packet with an ACK.</li>
<li>Bidirectional protocols making use of alternating IN and OUT phases should not rely on the last ACK an IN transfer to indicate that the OUT phase should start. Instead, the OUT phase should be started at the same time the last IN transfer is started. This is because the ACK to the last in transfer may be dropped if there is noise on the USB line. If dropped, it will only be resent on the next IN phase. You can find more information on this in section 8.5.3.3 of the USB specification. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="_u_s_b_phy_8h_source.html#l00082">82</a> of file <a class="el" href="_u_s_b_phy_8h_source.html">USBPhy.h</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="aa58d2212e6028f891db3cdb2067d617e" name="aa58d2212e6028f891db3cdb2067d617e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa58d2212e6028f891db3cdb2067d617e">&#9670;&#160;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_u_s_b_phy_events.html">USBPhyEvents</a> *&#160;</td>
          <td class="paramname"><em>events</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize this <a class="el" href="class_u_s_b_phy.html" title="Abstract interface to physical USB hardware.">USBPhy</a> instance. </p>
<p >This function must be called before calling any other functions of this class, unless specifically noted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">events</td><td>Callback class to handle USB events </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_u_s_b_phy_hw.html#a50c1965ca313b9a65086cf6901601ce2">USBPhyHw</a>.</p>

</div>
</div>
<a id="a0a5b1b963d05fc3e18287ecefe1dca6f" name="a0a5b1b963d05fc3e18287ecefe1dca6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a5b1b963d05fc3e18287ecefe1dca6f">&#9670;&#160;</a></span>deinit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void deinit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Power down this <a class="el" href="class_u_s_b_phy.html" title="Abstract interface to physical USB hardware.">USBPhy</a> instance. </p>
<p >Disable interrupts and stop sending events. </p>

<p>Implemented in <a class="el" href="class_u_s_b_phy_hw.html#ab4be3c1e91e7349566e8514549d01612">USBPhyHw</a>.</p>

</div>
</div>
<a id="a73239969cf916c1be67a2fcf5e608376" name="a73239969cf916c1be67a2fcf5e608376"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73239969cf916c1be67a2fcf5e608376">&#9670;&#160;</a></span>powered()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool powered </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if USB power is present. </p>
<p >Devices which don't support checking the USB power state must always return true.</p>
<dl class="section return"><dt>Returns</dt><dd>true if USB power is present, false otherwise </dd></dl>

<p>Implemented in <a class="el" href="class_u_s_b_phy_hw.html#ab191042f0b34063a6fe27e157f84fbfd">USBPhyHw</a>.</p>

</div>
</div>
<a id="a47369b82ef0f5ff7aed2bd0cd82c2ca9" name="a47369b82ef0f5ff7aed2bd0cd82c2ca9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47369b82ef0f5ff7aed2bd0cd82c2ca9">&#9670;&#160;</a></span>connect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void connect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make the USB phy visible to the USB host. </p>
<p >Enable either the D+ or D- pullup so the host can detect the presence of this device. </p>

<p>Implemented in <a class="el" href="class_u_s_b_phy_hw.html#ae0e500ddf8b4cb6561c7697122d46b6d">USBPhyHw</a>.</p>

</div>
</div>
<a id="ac4b9cc415683acddaa6545ffb693fb23" name="ac4b9cc415683acddaa6545ffb693fb23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4b9cc415683acddaa6545ffb693fb23">&#9670;&#160;</a></span>disconnect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void disconnect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Detach the USB phy. </p>
<p >Disable the D+ and D- pullup and stop responding to USB traffic. </p>

<p>Implemented in <a class="el" href="class_u_s_b_phy_hw.html#ae912b4753197bd8e72679ee05d5e04b1">USBPhyHw</a>.</p>

</div>
</div>
<a id="ae4ef25fc219d0a045a65041ec74906c1" name="ae4ef25fc219d0a045a65041ec74906c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4ef25fc219d0a045a65041ec74906c1">&#9670;&#160;</a></span>configure()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void configure </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set this device to the configured state. </p>
<p >Enable added endpoints if they are not enabled already. </p>

<p>Implemented in <a class="el" href="class_u_s_b_phy_hw.html#a46c1f25adca734191cfa23d0fc3e5875">USBPhyHw</a>.</p>

</div>
</div>
<a id="a74193359376d12a7806d862ac0feae9d" name="a74193359376d12a7806d862ac0feae9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74193359376d12a7806d862ac0feae9d">&#9670;&#160;</a></span>unconfigure()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void unconfigure </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Leave the configured state. </p>
<p >This is a notification to the <a class="el" href="class_u_s_b_phy.html" title="Abstract interface to physical USB hardware.">USBPhy</a> indicating that the device is leaving the configured state. The <a class="el" href="class_u_s_b_phy.html" title="Abstract interface to physical USB hardware.">USBPhy</a> can disable all endpoints other than endpoint 0. </p>

<p>Implemented in <a class="el" href="class_u_s_b_phy_hw.html#aadbbe9a997e1efc8ecd9dde9630a4c47">USBPhyHw</a>.</p>

</div>
</div>
<a id="a8e18caf3b51bff18982c36a8546b7712" name="a8e18caf3b51bff18982c36a8546b7712"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e18caf3b51bff18982c36a8546b7712">&#9670;&#160;</a></span>sof_enable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sof_enable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable the start of frame interrupt. </p>
<p >Call <a class="el" href="class_u_s_b_phy_events.html#a3e7b1d01151f8d59c6bfea66cfa881d6" title="Callback called on start of frame.">USBPhyEvents::sof</a> on every frame. </p>

<p>Implemented in <a class="el" href="class_u_s_b_phy_hw.html#ac750eef2d58acf652c32537f31d6e20e">USBPhyHw</a>.</p>

</div>
</div>
<a id="a8cd67a5a4e8a21c155dca647b1b5a6f7" name="a8cd67a5a4e8a21c155dca647b1b5a6f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cd67a5a4e8a21c155dca647b1b5a6f7">&#9670;&#160;</a></span>sof_disable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sof_disable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disable the start of frame interrupt. </p>
<p >Stop calling <a class="el" href="class_u_s_b_phy_events.html#a3e7b1d01151f8d59c6bfea66cfa881d6" title="Callback called on start of frame.">USBPhyEvents::sof</a>. </p>

<p>Implemented in <a class="el" href="class_u_s_b_phy_hw.html#a51a739f8a8f282d8fbb1dd26a18dcc4d">USBPhyHw</a>.</p>

</div>
</div>
<a id="a047021c7fd6ae8ed0aff2fa547031670" name="a047021c7fd6ae8ed0aff2fa547031670"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a047021c7fd6ae8ed0aff2fa547031670">&#9670;&#160;</a></span>set_address()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void set_address </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the <a class="el" href="class_u_s_b_phy.html" title="Abstract interface to physical USB hardware.">USBPhy</a>'s address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>This device's USB address </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_u_s_b_phy_hw.html#a2e1260269d01275ff3400f1d8322052b">USBPhyHw</a>.</p>

</div>
</div>
<a id="a6774032bc516c88938ad5bf302a59ddc" name="a6774032bc516c88938ad5bf302a59ddc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6774032bc516c88938ad5bf302a59ddc">&#9670;&#160;</a></span>remote_wakeup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void remote_wakeup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wake upstream devices. </p>

<p>Implemented in <a class="el" href="class_u_s_b_phy_hw.html#a871c63a0515e47655b8d7ab8d9a6fd55">USBPhyHw</a>.</p>

</div>
</div>
<a id="a2d7bb2640b5965b8f6d67707ee31ec43" name="a2d7bb2640b5965b8f6d67707ee31ec43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d7bb2640b5965b8f6d67707ee31ec43">&#9670;&#160;</a></span>endpoint_table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="structusb__ep__table__t.html">usb_ep_table_t</a> * endpoint_table </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the endpoint table. </p>
<p >This function returns a table which describes the endpoints can be used, the functionality of those endpoints and the resource cost. </p>

<p>Implemented in <a class="el" href="class_u_s_b_phy_hw.html#ac51e70eea9ed2d23b58433108ce1ffc8">USBPhyHw</a>.</p>

</div>
</div>
<a id="a7087cc06f0bf8f1c50c097a775cde528" name="a7087cc06f0bf8f1c50c097a775cde528"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7087cc06f0bf8f1c50c097a775cde528">&#9670;&#160;</a></span>ep0_set_max_packet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint32_t ep0_set_max_packet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_packet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set wMaxPacketSize of endpoint 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_packet</td><td>The wMaxPacketSize value for endpoint 0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The actual size of endpoint 0 </dd></dl>

<p>Implemented in <a class="el" href="class_u_s_b_phy_hw.html#a8809eda36161a4cedc41fb9b683059f9">USBPhyHw</a>.</p>

</div>
</div>
<a id="a8c4e065017c56cea38b1bf31228a1227" name="a8c4e065017c56cea38b1bf31228a1227"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c4e065017c56cea38b1bf31228a1227">&#9670;&#160;</a></span>ep0_setup_read_result()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ep0_setup_read_result </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the contents of the SETUP packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>Buffer to fill with data </td></tr>
    <tr><td class="paramname">size</td><td>Size of buffer passed in </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_u_s_b_phy_hw.html#ac1bd29d67aad5ca302e45780ff1c2c14">USBPhyHw</a>.</p>

</div>
</div>
<a id="afab7b1ac8b0aded8a16ed9b2e06a44b7" name="afab7b1ac8b0aded8a16ed9b2e06a44b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afab7b1ac8b0aded8a16ed9b2e06a44b7">&#9670;&#160;</a></span>ep0_read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ep0_read </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start receiving a packet of up to wMaxPacketSize on endpoint 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Buffer to fill with the data read </td></tr>
    <tr><td class="paramname">size</td><td>Size of buffer </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_u_s_b_phy_hw.html#a0df2612bd5c56f4bfff7946e71dcef87">USBPhyHw</a>.</p>

</div>
</div>
<a id="a887c3a3ef21f3a99aaefafc1c3ec2774" name="a887c3a3ef21f3a99aaefafc1c3ec2774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a887c3a3ef21f3a99aaefafc1c3ec2774">&#9670;&#160;</a></span>ep0_read_result()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint32_t ep0_read_result </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the contents of a received packet. </p>
<dl class="section return"><dt>Returns</dt><dd>Size of data read </dd></dl>

<p>Implemented in <a class="el" href="class_u_s_b_phy_hw.html#a75b59b975d3ec66ce8ed4be850423633">USBPhyHw</a>.</p>

</div>
</div>
<a id="af036c42fa5434f5881b704ee09a9ed65" name="af036c42fa5434f5881b704ee09a9ed65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af036c42fa5434f5881b704ee09a9ed65">&#9670;&#160;</a></span>ep0_write()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ep0_write </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write a packet on endpoint 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>Buffer fill with data to send </td></tr>
    <tr><td class="paramname">size</td><td>Size of data to send </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_u_s_b_phy_hw.html#a8781582c22e2e267f8fc6a3e1953f4a1">USBPhyHw</a>.</p>

</div>
</div>
<a id="aa368765be668dc5d21f3c190b38c34f3" name="aa368765be668dc5d21f3c190b38c34f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa368765be668dc5d21f3c190b38c34f3">&#9670;&#160;</a></span>ep0_stall()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ep0_stall </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Protocol stall on endpoint 0. </p>
<p >Stall all IN and OUT packets on endpoint 0 until a setup packet is received. </p><dl class="section note"><dt>Note</dt><dd>The stall is cleared automatically when a setup packet is received </dd></dl>

<p>Implemented in <a class="el" href="class_u_s_b_phy_hw.html#a9cf78176a3fecab68dae69bb5e305851">USBPhyHw</a>.</p>

</div>
</div>
<a id="ac70515099d7d499ef2756f9c5668ef46" name="ac70515099d7d499ef2756f9c5668ef46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac70515099d7d499ef2756f9c5668ef46">&#9670;&#160;</a></span>endpoint_add()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool endpoint_add </td>
          <td>(</td>
          <td class="paramtype">usb_ep_t&#160;</td>
          <td class="paramname"><em>endpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">usb_ep_type_t&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Configure and enable an endpoint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">endpoint</td><td>Endpoint to configure and enable </td></tr>
    <tr><td class="paramname">max_packet</td><td>The maximum packet size that can be sent or received </td></tr>
    <tr><td class="paramname">type</td><td>The type of endpoint this should be configured as - USB_EP_TYPE_BULK, USB_EP_TYPE_INT or USB_EP_TYPE_ISO </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function cannot be used to configure endpoint 0. That must be done with ep0_set_max_packet </dd></dl>

<p>Implemented in <a class="el" href="class_u_s_b_phy_hw.html#ad2ccb63c18f090e2d66144da825f035c">USBPhyHw</a>.</p>

</div>
</div>
<a id="a2df969814bbc2e391ddc318a10a1e1ff" name="a2df969814bbc2e391ddc318a10a1e1ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2df969814bbc2e391ddc318a10a1e1ff">&#9670;&#160;</a></span>endpoint_remove()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void endpoint_remove </td>
          <td>(</td>
          <td class="paramtype">usb_ep_t&#160;</td>
          <td class="paramname"><em>endpoint</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disable an endpoint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">endpoint</td><td>Endpoint to disable </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_u_s_b_phy_hw.html#a50e949bdfe371ad803ab8ad7f08ba88d">USBPhyHw</a>.</p>

</div>
</div>
<a id="ab71d67a4871c928d6d398288304d1c9b" name="ab71d67a4871c928d6d398288304d1c9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab71d67a4871c928d6d398288304d1c9b">&#9670;&#160;</a></span>endpoint_stall()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void endpoint_stall </td>
          <td>(</td>
          <td class="paramtype">usb_ep_t&#160;</td>
          <td class="paramname"><em>endpoint</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a functional stall on the given endpoint. </p>
<p >Set the HALT feature for this endpoint so that all further communication is aborted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">endpoint</td><td>Endpoint to stall </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_u_s_b_phy_hw.html#a39bd0a0410e9e6f0f57bdd7a531d89e2">USBPhyHw</a>.</p>

</div>
</div>
<a id="a2ec485b9f7d5d50f88f9d5fab5690d5b" name="a2ec485b9f7d5d50f88f9d5fab5690d5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ec485b9f7d5d50f88f9d5fab5690d5b">&#9670;&#160;</a></span>endpoint_unstall()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void endpoint_unstall </td>
          <td>(</td>
          <td class="paramtype">usb_ep_t&#160;</td>
          <td class="paramname"><em>endpoint</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Un-stall the endpoint. </p>
<p >Clear the HALT feature on this endpoint so communication can resume.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">endpoint</td><td>Endpoint to stall </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_u_s_b_phy_hw.html#a084242badc636299b42a9ecd81940ba6">USBPhyHw</a>.</p>

</div>
</div>
<a id="a1e04a43787520f019444c299454a0021" name="a1e04a43787520f019444c299454a0021"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e04a43787520f019444c299454a0021">&#9670;&#160;</a></span>endpoint_read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool endpoint_read </td>
          <td>(</td>
          <td class="paramtype">usb_ep_t&#160;</td>
          <td class="paramname"><em>endpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start a read on the given endpoint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">endpoint</td><td>Endpoint to start the read on </td></tr>
    <tr><td class="paramname">data</td><td>Buffer to fill with data </td></tr>
    <tr><td class="paramname">size</td><td>Size of the read buffer. This must be at least the max packet size for this endpoint. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the read was successfully started, false otherwise </dd></dl>

<p>Implemented in <a class="el" href="class_u_s_b_phy_hw.html#a2f546bd48afad1c47600020fb46647b7">USBPhyHw</a>.</p>

</div>
</div>
<a id="a32ae5ca2ffa9395b6ce2c7080f0adee9" name="a32ae5ca2ffa9395b6ce2c7080f0adee9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32ae5ca2ffa9395b6ce2c7080f0adee9">&#9670;&#160;</a></span>endpoint_read_result()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint32_t endpoint_read_result </td>
          <td>(</td>
          <td class="paramtype">usb_ep_t&#160;</td>
          <td class="paramname"><em>endpoint</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finish a read on the given endpoint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">endpoint</td><td>Endpoint to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes received </dd></dl>

<p>Implemented in <a class="el" href="class_u_s_b_phy_hw.html#a215188ced9629adb85a70f167657de42">USBPhyHw</a>.</p>

</div>
</div>
<a id="a8a5825552cdaa64b8916b626ca9e546e" name="a8a5825552cdaa64b8916b626ca9e546e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a5825552cdaa64b8916b626ca9e546e">&#9670;&#160;</a></span>endpoint_write()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool endpoint_write </td>
          <td>(</td>
          <td class="paramtype">usb_ep_t&#160;</td>
          <td class="paramname"><em>endpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start a write on the given endpoint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">endpoint</td><td>Endpoint to write to </td></tr>
    <tr><td class="paramname">data</td><td>Buffer to write </td></tr>
    <tr><td class="paramname">size</td><td>Size of data to write </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the data was prepared for transmit, false otherwise </dd></dl>

<p>Implemented in <a class="el" href="class_u_s_b_phy_hw.html#ae216147aabd40369019a66ec5260bdd1">USBPhyHw</a>.</p>

</div>
</div>
<a id="ae551659076ba4ae394bc5d602ca00dc8" name="ae551659076ba4ae394bc5d602ca00dc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae551659076ba4ae394bc5d602ca00dc8">&#9670;&#160;</a></span>endpoint_abort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void endpoint_abort </td>
          <td>(</td>
          <td class="paramtype">usb_ep_t&#160;</td>
          <td class="paramname"><em>endpoint</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Abort the current transfer if it has not yet been sent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">endpoint</td><td>Endpoint to abort the transfer on. It is implementation defined if this function has an effect on receive endpoints. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_u_s_b_phy_hw.html#a0a4d4c5fe4ca955db6b9a5de3d0ad635">USBPhyHw</a>.</p>

</div>
</div>
<a id="a142b75b68a6291400e20fb0dd905b1c8" name="a142b75b68a6291400e20fb0dd905b1c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a142b75b68a6291400e20fb0dd905b1c8">&#9670;&#160;</a></span>process()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void process </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Callback used for performing USB processing. </p>
<p ><a class="el" href="class_u_s_b_phy.html" title="Abstract interface to physical USB hardware.">USBPhy</a> processing should be triggered by calling <a class="el" href="class_u_s_b_phy_events.html#ab7376c83ba1c7ee62ab492302cbb32be" title="Callback called to indicate the USB processing needs to be done.">USBPhyEvents::start_process</a> and done inside process. All <a class="el" href="class_u_s_b_phy_events.html" title="Event handler for USBPhy.">USBPhyEvents</a> callbacks aside from <a class="el" href="class_u_s_b_phy_events.html#ab7376c83ba1c7ee62ab492302cbb32be" title="Callback called to indicate the USB processing needs to be done.">USBPhyEvents::start_process</a> must be called in the context of process </p>

<p>Implemented in <a class="el" href="class_u_s_b_phy_hw.html#a6780fc1879338e1ff38faf7279ec6a0b">USBPhyHw</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_u_s_b_phy.html">USBPhy</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>

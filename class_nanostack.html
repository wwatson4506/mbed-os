<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Mbed OS Reference: Nanostack Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="mbed-ce_55x55.png"/></td>
  <td id="projectalign">
   <div id="projectname">Mbed OS Reference
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('class_nanostack.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a>  </div>
  <div class="headertitle"><div class="title">Nanostack Class Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for Nanostack:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_nanostack.png" usemap="#Nanostack_map" alt=""/>
  <map id="Nanostack_map" name="Nanostack_map">
<area href="class_onboard_network_stack.html" title="mbed OS API for onboard IP stack abstraction" alt="OnboardNetworkStack" shape="rect" coords="0,112,172,136"/>
<area href="classmbed_1_1_non_copyable.html" alt="NonCopyable&lt; Nanostack &gt;" shape="rect" coords="182,112,354,136"/>
<area href="class_network_stack.html" title="NetworkStack class." alt="NetworkStack" shape="rect" coords="0,56,172,80"/>
<area href="class_d_n_s.html" title="Base class for DNS provider." alt="DNS" shape="rect" coords="0,0,172,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nanostack_1_1_ethernet_interface.html">EthernetInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nanostack_1_1_interface.html">Interface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nanostack_1_1_mesh_interface.html">MeshInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nanostack_1_1_p_p_p_interface.html">PPPInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a7640d35fa5798e1ff5ce0cf9a7faa097"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>(int delay_ms, <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; void()&gt; user_cb)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_stack.html#a7640d35fa5798e1ff5ce0cf9a7faa097">call_in_callback_cb_t</a></td></tr>
<tr class="memdesc:a7640d35fa5798e1ff5ce0cf9a7faa097"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for a call-in callback.  <a href="class_network_stack.html#a7640d35fa5798e1ff5ce0cf9a7faa097">More...</a><br /></td></tr>
<tr class="separator:a7640d35fa5798e1ff5ce0cf9a7faa097"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab42e008066f06faed53163986feaf124"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nanostack.html#ab42e008066f06faed53163986feaf124">add_ethernet_interface</a> (<a class="el" href="class_e_m_a_c.html">EMAC</a> &amp;emac, bool default_if, <a class="el" href="class_onboard_network_stack_1_1_interface.html">OnboardNetworkStack::Interface</a> **interface_out, <a class="el" href="class_network_interface.html">NetworkInterface</a> *user_network_interface=NULL) override</td></tr>
<tr class="memdesc:ab42e008066f06faed53163986feaf124"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a network interface with the IP stack.  <a href="class_nanostack.html#ab42e008066f06faed53163986feaf124">More...</a><br /></td></tr>
<tr class="separator:ab42e008066f06faed53163986feaf124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a320ba06d48aa2401a4e62d69b79297ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_onboard_network_stack.html">OnboardNetworkStack</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_onboard_network_stack.html#a320ba06d48aa2401a4e62d69b79297ba">onboardNetworkStack</a> () final</td></tr>
<tr class="memdesc:a320ba06d48aa2401a4e62d69b79297ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamic downcast to a <a class="el" href="class_onboard_network_stack.html" title="mbed OS API for onboard IP stack abstraction">OnboardNetworkStack</a>.  <a href="class_onboard_network_stack.html#a320ba06d48aa2401a4e62d69b79297ba">More...</a><br /></td></tr>
<tr class="separator:a320ba06d48aa2401a4e62d69b79297ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77de8d1afa4b83dd6f560dc39251e1eb"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_stack.html#a77de8d1afa4b83dd6f560dc39251e1eb">get_ipv6_link_local_address</a> (<a class="el" href="class_socket_address.html">SocketAddress</a> *address)</td></tr>
<tr class="memdesc:a77de8d1afa4b83dd6f560dc39251e1eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the IPv6 link local address.  <a href="class_network_stack.html#a77de8d1afa4b83dd6f560dc39251e1eb">More...</a><br /></td></tr>
<tr class="separator:a77de8d1afa4b83dd6f560dc39251e1eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad597f0496e42b17be72d00fa832e0963"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_stack.html#ad597f0496e42b17be72d00fa832e0963">get_ip_address_if</a> (<a class="el" href="class_socket_address.html">SocketAddress</a> *address, const char *interface_name)</td></tr>
<tr class="memdesc:ad597f0496e42b17be72d00fa832e0963"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the local IP address on interface name.  <a href="class_network_stack.html#ad597f0496e42b17be72d00fa832e0963">More...</a><br /></td></tr>
<tr class="separator:ad597f0496e42b17be72d00fa832e0963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87a975b9ef736cef63334895c5770660"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga4dc6e8ec26b364f135278917c3f27c6e">nsapi_value_or_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_stack.html#a87a975b9ef736cef63334895c5770660">getaddrinfo</a> (const char *hostname, <a class="el" href="class_socket_address.html">SocketAddress</a> *hints, <a class="el" href="class_socket_address.html">SocketAddress</a> **res, const char *interface_name=NULL)</td></tr>
<tr class="memdesc:a87a975b9ef736cef63334895c5770660"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate a hostname to the multiple IP addresses with specific version using network interface name.  <a href="class_network_stack.html#a87a975b9ef736cef63334895c5770660">More...</a><br /></td></tr>
<tr class="separator:a87a975b9ef736cef63334895c5770660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa964732e6c585b596adc760fe95f40f5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga4dc6e8ec26b364f135278917c3f27c6e">nsapi_value_or_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_stack.html#aa964732e6c585b596adc760fe95f40f5">getaddrinfo_async</a> (const char *hostname, <a class="el" href="class_socket_address.html">SocketAddress</a> *hints, <a class="el" href="classmbed_1_1_callback.html">hostbyname_cb_t</a> callback, const char *interface_name=NULL)</td></tr>
<tr class="memdesc:aa964732e6c585b596adc760fe95f40f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translates a hostname to the multiple IP addresses (asynchronous)  <a href="class_network_stack.html#aa964732e6c585b596adc760fe95f40f5">More...</a><br /></td></tr>
<tr class="separator:aa964732e6c585b596adc760fe95f40f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26000e958701f5b35886fac1757c0bf4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_stack.html#a26000e958701f5b35886fac1757c0bf4">gethostbyname_async_cancel</a> (int id)</td></tr>
<tr class="memdesc:a26000e958701f5b35886fac1757c0bf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancels asynchronous hostname translation.  <a href="class_network_stack.html#a26000e958701f5b35886fac1757c0bf4">More...</a><br /></td></tr>
<tr class="separator:a26000e958701f5b35886fac1757c0bf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbf8dbcd865fee3ebef07fefbea802a7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_stack.html#adbf8dbcd865fee3ebef07fefbea802a7">add_dns_server</a> (const <a class="el" href="class_socket_address.html">SocketAddress</a> &amp;address, const char *interface_name=NULL)</td></tr>
<tr class="memdesc:adbf8dbcd865fee3ebef07fefbea802a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a domain name server to list of servers to query.  <a href="class_network_stack.html#adbf8dbcd865fee3ebef07fefbea802a7">More...</a><br /></td></tr>
<tr class="separator:adbf8dbcd865fee3ebef07fefbea802a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a7320cea7380b373238fac3de2881469c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_onboard_network_stack.html">OnboardNetworkStack</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_onboard_network_stack.html#a7320cea7380b373238fac3de2881469c">get_default_instance</a> ()</td></tr>
<tr class="memdesc:a7320cea7380b373238fac3de2881469c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the default on-board network stack.  <a href="class_onboard_network_stack.html#a7320cea7380b373238fac3de2881469c">More...</a><br /></td></tr>
<tr class="separator:a7320cea7380b373238fac3de2881469c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a839e3aefbadd82c35902dd53ef5a21fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nanostack.html#a839e3aefbadd82c35902dd53ef5a21fa">get_ip_address</a> (<a class="el" href="class_socket_address.html">SocketAddress</a> *address) override</td></tr>
<tr class="memdesc:a839e3aefbadd82c35902dd53ef5a21fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the local IP address.   <a href="class_nanostack.html#a839e3aefbadd82c35902dd53ef5a21fa">More...</a><br /></td></tr>
<tr class="separator:a839e3aefbadd82c35902dd53ef5a21fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdc95fb930de625b8f727680c3476d43"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nanostack.html#acdc95fb930de625b8f727680c3476d43">gethostbyname</a> (const char *host, <a class="el" href="class_socket_address.html">SocketAddress</a> *address, nsapi_version_t version, const char *interface_name) override</td></tr>
<tr class="memdesc:acdc95fb930de625b8f727680c3476d43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate a hostname to an IP address with specific version using network interface name.  <a href="class_nanostack.html#acdc95fb930de625b8f727680c3476d43">More...</a><br /></td></tr>
<tr class="separator:acdc95fb930de625b8f727680c3476d43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab738a37df7a1cec6fba88e6b9c45dde1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga4dc6e8ec26b364f135278917c3f27c6e">nsapi_value_or_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nanostack.html#ab738a37df7a1cec6fba88e6b9c45dde1">gethostbyname_async</a> (const char *host, <a class="el" href="classmbed_1_1_callback.html">hostbyname_cb_t</a> callback, nsapi_version_t version, const char *interface_name) override</td></tr>
<tr class="memdesc:ab738a37df7a1cec6fba88e6b9c45dde1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate a hostname to an IP address (asynchronous) using network interface name.  <a href="class_nanostack.html#ab738a37df7a1cec6fba88e6b9c45dde1">More...</a><br /></td></tr>
<tr class="separator:ab738a37df7a1cec6fba88e6b9c45dde1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d043b7dbb9ec7bcb1f21dccff63d04f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nanostack.html#a2d043b7dbb9ec7bcb1f21dccff63d04f">get_dns_server</a> (int index, <a class="el" href="class_socket_address.html">SocketAddress</a> *address, const char *interface_name) override</td></tr>
<tr class="memdesc:a2d043b7dbb9ec7bcb1f21dccff63d04f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a domain name server from a list of servers to query.  <a href="class_nanostack.html#a2d043b7dbb9ec7bcb1f21dccff63d04f">More...</a><br /></td></tr>
<tr class="separator:a2d043b7dbb9ec7bcb1f21dccff63d04f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb28d1dbec5bd932b9eaae360d6da91b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nanostack.html#adb28d1dbec5bd932b9eaae360d6da91b">socket_open</a> (void **handle, nsapi_protocol_t proto) override</td></tr>
<tr class="memdesc:adb28d1dbec5bd932b9eaae360d6da91b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens a socket.  <a href="class_nanostack.html#adb28d1dbec5bd932b9eaae360d6da91b">More...</a><br /></td></tr>
<tr class="separator:adb28d1dbec5bd932b9eaae360d6da91b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba6b0a7fc6f7f0a6b79c89c93e9e3bf3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nanostack.html#aba6b0a7fc6f7f0a6b79c89c93e9e3bf3">socket_close</a> (void *handle) override</td></tr>
<tr class="memdesc:aba6b0a7fc6f7f0a6b79c89c93e9e3bf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the socket.  <a href="class_nanostack.html#aba6b0a7fc6f7f0a6b79c89c93e9e3bf3">More...</a><br /></td></tr>
<tr class="separator:aba6b0a7fc6f7f0a6b79c89c93e9e3bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23709b7e5fcaf12b6a74de0f2cab9986"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nanostack.html#a23709b7e5fcaf12b6a74de0f2cab9986">socket_bind</a> (void *handle, const <a class="el" href="class_socket_address.html">SocketAddress</a> &amp;address) override</td></tr>
<tr class="memdesc:a23709b7e5fcaf12b6a74de0f2cab9986"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a specific address to a socket.  <a href="class_nanostack.html#a23709b7e5fcaf12b6a74de0f2cab9986">More...</a><br /></td></tr>
<tr class="separator:a23709b7e5fcaf12b6a74de0f2cab9986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90e1932e34889754ddb018166054e3c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nanostack.html#a90e1932e34889754ddb018166054e3c4">socket_listen</a> (void *handle, int backlog) override</td></tr>
<tr class="memdesc:a90e1932e34889754ddb018166054e3c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Listen for connections on a TCP socket.  <a href="class_nanostack.html#a90e1932e34889754ddb018166054e3c4">More...</a><br /></td></tr>
<tr class="separator:a90e1932e34889754ddb018166054e3c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b14e3ba4378d810612622483c194ad2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nanostack.html#a8b14e3ba4378d810612622483c194ad2">socket_connect</a> (void *handle, const <a class="el" href="class_socket_address.html">SocketAddress</a> &amp;address) override</td></tr>
<tr class="memdesc:a8b14e3ba4378d810612622483c194ad2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connects TCP socket to a remote host.  <a href="class_nanostack.html#a8b14e3ba4378d810612622483c194ad2">More...</a><br /></td></tr>
<tr class="separator:a8b14e3ba4378d810612622483c194ad2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9d7af8652bf95bb3a99cbd988a60f02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nanostack.html#ab9d7af8652bf95bb3a99cbd988a60f02">socket_accept</a> (void *handle, void **server, <a class="el" href="class_socket_address.html">SocketAddress</a> *address) override</td></tr>
<tr class="memdesc:ab9d7af8652bf95bb3a99cbd988a60f02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accepts a connection on a TCP socket.  <a href="class_nanostack.html#ab9d7af8652bf95bb3a99cbd988a60f02">More...</a><br /></td></tr>
<tr class="separator:ab9d7af8652bf95bb3a99cbd988a60f02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e66843535784598a3fa76105801e77f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___net_socket.html#ga1aef0d1a2599df92bb4499b5c4262d25">nsapi_size_or_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nanostack.html#a9e66843535784598a3fa76105801e77f">socket_send</a> (void *handle, const void *data, <a class="el" href="group___net_socket.html#gaeaef3ae1ffcf0d50c66fa2ca37621281">nsapi_size_t</a> size) override</td></tr>
<tr class="memdesc:a9e66843535784598a3fa76105801e77f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send data over a TCP socket.  <a href="class_nanostack.html#a9e66843535784598a3fa76105801e77f">More...</a><br /></td></tr>
<tr class="separator:a9e66843535784598a3fa76105801e77f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed43f4c030344db652e7821fd0fff994"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___net_socket.html#ga1aef0d1a2599df92bb4499b5c4262d25">nsapi_size_or_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nanostack.html#aed43f4c030344db652e7821fd0fff994">socket_recv</a> (void *handle, void *data, <a class="el" href="group___net_socket.html#gaeaef3ae1ffcf0d50c66fa2ca37621281">nsapi_size_t</a> size) override</td></tr>
<tr class="memdesc:aed43f4c030344db652e7821fd0fff994"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive data over a TCP socket.  <a href="class_nanostack.html#aed43f4c030344db652e7821fd0fff994">More...</a><br /></td></tr>
<tr class="separator:aed43f4c030344db652e7821fd0fff994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceb411cbca87cde852280cb94a982f73"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___net_socket.html#ga1aef0d1a2599df92bb4499b5c4262d25">nsapi_size_or_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nanostack.html#aceb411cbca87cde852280cb94a982f73">socket_sendto</a> (void *handle, const <a class="el" href="class_socket_address.html">SocketAddress</a> &amp;address, const void *data, <a class="el" href="group___net_socket.html#gaeaef3ae1ffcf0d50c66fa2ca37621281">nsapi_size_t</a> size) override</td></tr>
<tr class="memdesc:aceb411cbca87cde852280cb94a982f73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a packet over a UDP socket.  <a href="class_nanostack.html#aceb411cbca87cde852280cb94a982f73">More...</a><br /></td></tr>
<tr class="separator:aceb411cbca87cde852280cb94a982f73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a264b90bbb8fd5b6a5ac0c93ea5617453"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___net_socket.html#ga1aef0d1a2599df92bb4499b5c4262d25">nsapi_size_or_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nanostack.html#a264b90bbb8fd5b6a5ac0c93ea5617453">socket_recvfrom</a> (void *handle, <a class="el" href="class_socket_address.html">SocketAddress</a> *address, void *buffer, <a class="el" href="group___net_socket.html#gaeaef3ae1ffcf0d50c66fa2ca37621281">nsapi_size_t</a> size) override</td></tr>
<tr class="memdesc:a264b90bbb8fd5b6a5ac0c93ea5617453"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive a packet over a UDP socket.  <a href="class_nanostack.html#a264b90bbb8fd5b6a5ac0c93ea5617453">More...</a><br /></td></tr>
<tr class="separator:a264b90bbb8fd5b6a5ac0c93ea5617453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa39dc687ca69ce33807642fee47e7db8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nanostack.html#aa39dc687ca69ce33807642fee47e7db8">socket_attach</a> (void *handle, void(*callback)(void *), void *data) override</td></tr>
<tr class="memdesc:aa39dc687ca69ce33807642fee47e7db8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a callback on state change of the socket.  <a href="class_nanostack.html#aa39dc687ca69ce33807642fee47e7db8">More...</a><br /></td></tr>
<tr class="separator:aa39dc687ca69ce33807642fee47e7db8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45cb37f5bbe111d0e64a45d9bb1204cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nanostack.html#a45cb37f5bbe111d0e64a45d9bb1204cc">setsockopt</a> (void *handle, int level, int optname, const void *optval, unsigned optlen) override</td></tr>
<tr class="memdesc:a45cb37f5bbe111d0e64a45d9bb1204cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set stack-specific socket options.  <a href="class_nanostack.html#a45cb37f5bbe111d0e64a45d9bb1204cc">More...</a><br /></td></tr>
<tr class="separator:a45cb37f5bbe111d0e64a45d9bb1204cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a324213e6725ac48b2842bcdcce383022"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nanostack.html#a324213e6725ac48b2842bcdcce383022">getsockopt</a> (void *handle, int level, int optname, void *optval, unsigned *optlen) override</td></tr>
<tr class="memdesc:a324213e6725ac48b2842bcdcce383022"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get stack-specific socket options.  <a href="class_nanostack.html#a324213e6725ac48b2842bcdcce383022">More...</a><br /></td></tr>
<tr class="separator:a324213e6725ac48b2842bcdcce383022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6e5ab3271a4df6347b400bd7e16fdc0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga1aef0d1a2599df92bb4499b5c4262d25">nsapi_size_or_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_stack.html#aa6e5ab3271a4df6347b400bd7e16fdc0">socket_sendto_control</a> (<a class="el" href="group___net_socket.html#gad0273762e5e5643dda87a74c7de45b69">nsapi_socket_t</a> handle, const <a class="el" href="class_socket_address.html">SocketAddress</a> &amp;address, const void *data, <a class="el" href="group___net_socket.html#gaeaef3ae1ffcf0d50c66fa2ca37621281">nsapi_size_t</a> size, <a class="el" href="group___net_socket.html#gad737df4845d4a53ab1bf720f73572a7e">nsapi_msghdr_t</a> *control, <a class="el" href="group___net_socket.html#gaeaef3ae1ffcf0d50c66fa2ca37621281">nsapi_size_t</a> control_size)</td></tr>
<tr class="memdesc:aa6e5ab3271a4df6347b400bd7e16fdc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a packet with ancillary data over a UDP socket.  <a href="class_network_stack.html#aa6e5ab3271a4df6347b400bd7e16fdc0">More...</a><br /></td></tr>
<tr class="separator:aa6e5ab3271a4df6347b400bd7e16fdc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a345f6e49fcae39c08ca892e2d1b6337b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga1aef0d1a2599df92bb4499b5c4262d25">nsapi_size_or_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_stack.html#a345f6e49fcae39c08ca892e2d1b6337b">socket_recvfrom_control</a> (<a class="el" href="group___net_socket.html#gad0273762e5e5643dda87a74c7de45b69">nsapi_socket_t</a> handle, <a class="el" href="class_socket_address.html">SocketAddress</a> *address, void *data, <a class="el" href="group___net_socket.html#gaeaef3ae1ffcf0d50c66fa2ca37621281">nsapi_size_t</a> size, <a class="el" href="group___net_socket.html#gad737df4845d4a53ab1bf720f73572a7e">nsapi_msghdr_t</a> *control, <a class="el" href="group___net_socket.html#gaeaef3ae1ffcf0d50c66fa2ca37621281">nsapi_size_t</a> control_size)</td></tr>
<tr class="memdesc:a345f6e49fcae39c08ca892e2d1b6337b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive a packet with ancillary data over a UDP socket.  <a href="class_network_stack.html#a345f6e49fcae39c08ca892e2d1b6337b">More...</a><br /></td></tr>
<tr class="separator:a345f6e49fcae39c08ca892e2d1b6337b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock">
<p class="definition">Definition at line <a class="el" href="_nanostack_8h_source.html#l00029">29</a> of file <a class="el" href="_nanostack_8h_source.html">Nanostack.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a7640d35fa5798e1ff5ce0cf9a7faa097" name="a7640d35fa5798e1ff5ce0cf9a7faa097"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7640d35fa5798e1ff5ce0cf9a7faa097">&#9670;&#160;</a></span>call_in_callback_cb_t</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt;<a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> (int delay_ms, <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt;void()&gt; user_cb)&gt; <a class="el" href="class_network_stack.html#a7640d35fa5798e1ff5ce0cf9a7faa097">call_in_callback_cb_t</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Type for a call-in callback. </p>
<p >This is a pointer to a function that will call the provided callback from the network stack after a given delay, or immediately if <code>delay_ms</code> is 0. </p>

<p class="definition">Definition at line <a class="el" href="_network_stack_8h_source.html#l00235">235</a> of file <a class="el" href="_network_stack_8h_source.html">NetworkStack.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab42e008066f06faed53163986feaf124" name="ab42e008066f06faed53163986feaf124"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab42e008066f06faed53163986feaf124">&#9670;&#160;</a></span>add_ethernet_interface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> add_ethernet_interface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_e_m_a_c.html">EMAC</a> &amp;&#160;</td>
          <td class="paramname"><em>emac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>default_if</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_onboard_network_stack_1_1_interface.html">OnboardNetworkStack::Interface</a> **&#160;</td>
          <td class="paramname"><em>interface_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_network_interface.html">NetworkInterface</a> *&#160;</td>
          <td class="paramname"><em>user_network_interface</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register a network interface with the IP stack. </p>
<p >Connects <a class="el" href="class_e_m_a_c.html" title="This interface should be used to abstract low level access to networking hardware All operations rece...">EMAC</a> layer with the IP stack and initializes all the required infrastructure. This function should be called only once for each available interface. <a class="el" href="class_e_m_a_c.html" title="This interface should be used to abstract low level access to networking hardware All operations rece...">EMAC</a> memory manager is available to <a class="el" href="class_e_m_a_c.html" title="This interface should be used to abstract low level access to networking hardware All operations rece...">EMAC</a> after this function call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">emac</td><td><a class="el" href="class_e_m_a_c.html" title="This interface should be used to abstract low level access to networking hardware All operations rece...">EMAC</a> HAL implementation for this network interface </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">default_if</td><td>true if the interface should be treated as the default one </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">interface_out</td><td>Network stack's representation of the network interface will be saved to this pointer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_network_interface</td><td>Pointer to <a class="el" href="class_network_interface.html" title="Common interface that is shared between network devices.">NetworkInterface</a> that represents the ethernet interface being added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NSAPI_ERROR_OK on success, or error code </dd></dl>

<p>Implements <a class="el" href="class_onboard_network_stack.html#a84fc8c13cc5a41a241b9a547cd844e44">OnboardNetworkStack</a>.</p>

</div>
</div>
<a id="a839e3aefbadd82c35902dd53ef5a21fa" name="a839e3aefbadd82c35902dd53ef5a21fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a839e3aefbadd82c35902dd53ef5a21fa">&#9670;&#160;</a></span>get_ip_address()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> get_ip_address </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_socket_address.html">SocketAddress</a> *&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the local IP address.  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td><a class="el" href="class_socket_address.html" title="SocketAddress class.">SocketAddress</a> representation of the local IP address </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NSAPI_ERROR_OK</td><td>on success </td></tr>
    <tr><td class="paramname">NSAPI_ERROR_UNSUPPORTED</td><td>if this feature is not supported </td></tr>
    <tr><td class="paramname">NSAPI_ERROR_PARAMETER</td><td>if the provided pointer is invalid </td></tr>
    <tr><td class="paramname">NSAPI_ERROR_NO_ADDRESS</td><td>if the address cannot be obtained from stack  </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_network_stack.html#a2ab48210e24fc7efb4e1cada14c4b57b">NetworkStack</a>.</p>

</div>
</div>
<a id="acdc95fb930de625b8f727680c3476d43" name="acdc95fb930de625b8f727680c3476d43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdc95fb930de625b8f727680c3476d43">&#9670;&#160;</a></span>gethostbyname()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> gethostbyname </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_socket_address.html">SocketAddress</a> *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nsapi_version_t&#160;</td>
          <td class="paramname"><em>version</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>interface_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Translate a hostname to an IP address with specific version using network interface name. </p>
<p >The hostname may be either a domain name or an IP address. If the hostname is an IP address, no network transactions will be performed.</p>
<p >Method first checks <a class="el" href="class_nanostack.html">Nanostack</a> <a class="el" href="class_d_n_s.html" title="Base class for DNS provider.">DNS</a> query result cache. If match is found, then the result is returned immediately. Otherwise method calls <a class="el" href="class_d_n_s.html" title="Base class for DNS provider.">DNS</a> resolver to find a match.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>Hostname to resolve. </td></tr>
    <tr><td class="paramname">address</td><td>Pointer to a <a class="el" href="class_socket_address.html" title="SocketAddress class.">SocketAddress</a> to store the result. </td></tr>
    <tr><td class="paramname">version</td><td>IP version of address to resolve, NSAPI_UNSPEC indicates version is chosen by the stack (defaults to NSAPI_UNSPEC). </td></tr>
    <tr><td class="paramname">interface_name</td><td>Network interface name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NSAPI_ERROR_OK on success, negative error code on failure. </dd></dl>

<p>Reimplemented from <a class="el" href="class_network_stack.html#a5eeb3e01ec53546b61fd7b823a4980ef">NetworkStack</a>.</p>

</div>
</div>
<a id="ab738a37df7a1cec6fba88e6b9c45dde1" name="ab738a37df7a1cec6fba88e6b9c45dde1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab738a37df7a1cec6fba88e6b9c45dde1">&#9670;&#160;</a></span>gethostbyname_async()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga4dc6e8ec26b364f135278917c3f27c6e">nsapi_value_or_error_t</a> gethostbyname_async </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmbed_1_1_callback.html">hostbyname_cb_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nsapi_version_t&#160;</td>
          <td class="paramname"><em>version</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>interface_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Translate a hostname to an IP address (asynchronous) using network interface name. </p>
<p >The hostname may be either a domain name or a dotted IP address. If the hostname is an IP address, no network transactions will be performed.</p>
<p >Method first checks <a class="el" href="class_nanostack.html">Nanostack</a> <a class="el" href="class_d_n_s.html" title="Base class for DNS provider.">DNS</a> query result cache. If match is found, then the result is returned immediately.</p>
<p >Call is non-blocking. Result of the <a class="el" href="class_d_n_s.html" title="Base class for DNS provider.">DNS</a> operation is returned by the callback. If this function returns failure, callback will not be called. In case result is success (IP address was found from <a class="el" href="class_d_n_s.html" title="Base class for DNS provider.">DNS</a> cache), callback will be called before function returns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>Hostname to resolve. </td></tr>
    <tr><td class="paramname">callback</td><td>Callback that is called for result. </td></tr>
    <tr><td class="paramname">version</td><td>IP version of address to resolve, NSAPI_UNSPEC indicates version is chosen by the stack (defaults to NSAPI_UNSPEC). </td></tr>
    <tr><td class="paramname">interface_name</td><td>Network interface name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on immediate success, negative error code on immediate failure or a positive unique id that represents the hostname translation operation and can be passed to cancel. </dd></dl>

<p>Reimplemented from <a class="el" href="class_network_stack.html#ab43b64cae1f145615db7f697d34552d7">NetworkStack</a>.</p>

</div>
</div>
<a id="a2d043b7dbb9ec7bcb1f21dccff63d04f" name="a2d043b7dbb9ec7bcb1f21dccff63d04f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d043b7dbb9ec7bcb1f21dccff63d04f">&#9670;&#160;</a></span>get_dns_server()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> get_dns_server </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_socket_address.html">SocketAddress</a> *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>interface_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a domain name server from a list of servers to query. </p>
<p >Returns a <a class="el" href="class_d_n_s.html" title="Base class for DNS provider.">DNS</a> server address for a index. <a class="el" href="class_d_n_s.html" title="Base class for DNS provider.">DNS</a> servers are queried from <a class="el" href="class_nanostack.html">Nanostack</a> <a class="el" href="class_d_n_s.html" title="Base class for DNS provider.">DNS</a> cache. If returns error no more <a class="el" href="class_d_n_s.html" title="Base class for DNS provider.">DNS</a> servers to read.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index of the <a class="el" href="class_d_n_s.html" title="Base class for DNS provider.">DNS</a> server, starts from zero </td></tr>
    <tr><td class="paramname">address</td><td>Destination for the host address </td></tr>
    <tr><td class="paramname">interface_name</td><td>Network interface name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative error code on failure </dd></dl>

<p>Reimplemented from <a class="el" href="class_network_stack.html#a0ccb0f7a5af95e76d0dea335ab866047">NetworkStack</a>.</p>

</div>
</div>
<a id="adb28d1dbec5bd932b9eaae360d6da91b" name="adb28d1dbec5bd932b9eaae360d6da91b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb28d1dbec5bd932b9eaae360d6da91b">&#9670;&#160;</a></span>socket_open()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> socket_open </td>
          <td>(</td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nsapi_protocol_t&#160;</td>
          <td class="paramname"><em>proto</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Opens a socket. </p>
<p >Creates a network socket and stores it in the specified handle. The handle must be passed to following calls on the socket.</p>
<p >A stack may have a finite number of sockets, in this case NSAPI_ERROR_NO_SOCKET is returned if no socket is available.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Destination for the handle to a newly created socket </td></tr>
    <tr><td class="paramname">proto</td><td>Protocol of socket to open, NSAPI_TCP or NSAPI_UDP </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative error code on failure </dd></dl>

<p>Implements <a class="el" href="class_network_stack.html#a917003ace34919b35f8e1dced0b52a05">NetworkStack</a>.</p>

</div>
</div>
<a id="aba6b0a7fc6f7f0a6b79c89c93e9e3bf3" name="aba6b0a7fc6f7f0a6b79c89c93e9e3bf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba6b0a7fc6f7f0a6b79c89c93e9e3bf3">&#9670;&#160;</a></span>socket_close()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> socket_close </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Close the socket. </p>
<p >Closes any open connection and deallocates any memory associated with the socket.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td><a class="el" href="class_socket.html" title="Socket interface.">Socket</a> handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative error code on failure </dd></dl>

<p>Implements <a class="el" href="class_network_stack.html#a519c5ecb722a17ea2acafad17f9386a3">NetworkStack</a>.</p>

</div>
</div>
<a id="a23709b7e5fcaf12b6a74de0f2cab9986" name="a23709b7e5fcaf12b6a74de0f2cab9986"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23709b7e5fcaf12b6a74de0f2cab9986">&#9670;&#160;</a></span>socket_bind()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> socket_bind </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_socket_address.html">SocketAddress</a> &amp;&#160;</td>
          <td class="paramname"><em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind a specific address to a socket. </p>
<p >Binding a socket specifies the address and port on which to recieve data. If the IP address is zeroed, only the port is bound.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td><a class="el" href="class_socket.html" title="Socket interface.">Socket</a> handle </td></tr>
    <tr><td class="paramname">address</td><td>Local address to bind </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative error code on failure. </dd></dl>

<p>Implements <a class="el" href="class_network_stack.html#ac92c15ee2f3ef7e26cb881393559d1ff">NetworkStack</a>.</p>

</div>
</div>
<a id="a90e1932e34889754ddb018166054e3c4" name="a90e1932e34889754ddb018166054e3c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90e1932e34889754ddb018166054e3c4">&#9670;&#160;</a></span>socket_listen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> socket_listen </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>backlog</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Listen for connections on a TCP socket. </p>
<p >Marks the socket as a passive socket that can be used to accept incoming connections.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td><a class="el" href="class_socket.html" title="Socket interface.">Socket</a> handle </td></tr>
    <tr><td class="paramname">backlog</td><td>Number of pending connections that can be queued simultaneously </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative error code on failure </dd></dl>

<p>Implements <a class="el" href="class_network_stack.html#a45a50de4d7a421ac592f7effa7765639">NetworkStack</a>.</p>

</div>
</div>
<a id="a8b14e3ba4378d810612622483c194ad2" name="a8b14e3ba4378d810612622483c194ad2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b14e3ba4378d810612622483c194ad2">&#9670;&#160;</a></span>socket_connect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> socket_connect </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_socket_address.html">SocketAddress</a> &amp;&#160;</td>
          <td class="paramname"><em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Connects TCP socket to a remote host. </p>
<p >Initiates a connection to a remote server specified by the indicated address.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td><a class="el" href="class_socket.html" title="Socket interface.">Socket</a> handle </td></tr>
    <tr><td class="paramname">address</td><td>The <a class="el" href="class_socket_address.html" title="SocketAddress class.">SocketAddress</a> of the remote host </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative error code on failure </dd></dl>

<p>Implements <a class="el" href="class_network_stack.html#ad584c350cb47627892fd2783e4c0c88a">NetworkStack</a>.</p>

</div>
</div>
<a id="ab9d7af8652bf95bb3a99cbd988a60f02" name="ab9d7af8652bf95bb3a99cbd988a60f02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9d7af8652bf95bb3a99cbd988a60f02">&#9670;&#160;</a></span>socket_accept()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> socket_accept </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>server</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_socket_address.html">SocketAddress</a> *&#160;</td>
          <td class="paramname"><em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accepts a connection on a TCP socket. </p>
<p >The server socket must be bound and set to listen for connections. On a new connection, creates a network socket and stores it in the specified handle. The handle must be passed to following calls on the socket.</p>
<p >A stack may have a finite number of sockets, in this case NSAPI_ERROR_NO_SOCKET is returned if no socket is available.</p>
<p >This call is non-blocking. If accept would block, NSAPI_ERROR_WOULD_BLOCK is returned immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">server</td><td><a class="el" href="class_socket.html" title="Socket interface.">Socket</a> handle to server to accept from </td></tr>
    <tr><td class="paramname">handle</td><td>Destination for a handle to the newly created socket </td></tr>
    <tr><td class="paramname">address</td><td>Destination for the remote address or NULL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative error code on failure </dd></dl>

<p>Implements <a class="el" href="class_network_stack.html#aa497dbf81d1e9844f7c73ea44a9b6e54">NetworkStack</a>.</p>

</div>
</div>
<a id="a9e66843535784598a3fa76105801e77f" name="a9e66843535784598a3fa76105801e77f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e66843535784598a3fa76105801e77f">&#9670;&#160;</a></span>socket_send()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___net_socket.html#ga1aef0d1a2599df92bb4499b5c4262d25">nsapi_size_or_error_t</a> socket_send </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___net_socket.html#gaeaef3ae1ffcf0d50c66fa2ca37621281">nsapi_size_t</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send data over a TCP socket. </p>
<p >The socket must be connected to a remote host. Returns the number of bytes sent from the buffer.</p>
<p >This call is non-blocking. If send would block, NSAPI_ERROR_WOULD_BLOCK is returned immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td><a class="el" href="class_socket.html" title="Socket interface.">Socket</a> handle </td></tr>
    <tr><td class="paramname">data</td><td>Buffer of data to send to the host </td></tr>
    <tr><td class="paramname">size</td><td>Size of the buffer in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of sent bytes on success, negative error code on failure </dd></dl>

<p>Implements <a class="el" href="class_network_stack.html#a70b5c1fd2bc705be0cc7651532008b8a">NetworkStack</a>.</p>

</div>
</div>
<a id="aed43f4c030344db652e7821fd0fff994" name="aed43f4c030344db652e7821fd0fff994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed43f4c030344db652e7821fd0fff994">&#9670;&#160;</a></span>socket_recv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___net_socket.html#ga1aef0d1a2599df92bb4499b5c4262d25">nsapi_size_or_error_t</a> socket_recv </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___net_socket.html#gaeaef3ae1ffcf0d50c66fa2ca37621281">nsapi_size_t</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Receive data over a TCP socket. </p>
<p >The socket must be connected to a remote host. Returns the number of bytes received into the buffer.</p>
<p >This call is non-blocking. If recv would block, NSAPI_ERROR_WOULD_BLOCK is returned immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td><a class="el" href="class_socket.html" title="Socket interface.">Socket</a> handle </td></tr>
    <tr><td class="paramname">data</td><td>Destination buffer for data received from the host </td></tr>
    <tr><td class="paramname">size</td><td>Size of the buffer in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of received bytes on success, negative error code on failure </dd></dl>

<p>Implements <a class="el" href="class_network_stack.html#a178a8c725d8f646ff6b26b381d2ac2c6">NetworkStack</a>.</p>

</div>
</div>
<a id="aceb411cbca87cde852280cb94a982f73" name="aceb411cbca87cde852280cb94a982f73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aceb411cbca87cde852280cb94a982f73">&#9670;&#160;</a></span>socket_sendto()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___net_socket.html#ga1aef0d1a2599df92bb4499b5c4262d25">nsapi_size_or_error_t</a> socket_sendto </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_socket_address.html">SocketAddress</a> &amp;&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___net_socket.html#gaeaef3ae1ffcf0d50c66fa2ca37621281">nsapi_size_t</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send a packet over a UDP socket. </p>
<p >Sends data to the specified address. Returns the number of bytes sent from the buffer.</p>
<p >This call is non-blocking. If sendto would block, NSAPI_ERROR_WOULD_BLOCK is returned immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td><a class="el" href="class_socket.html" title="Socket interface.">Socket</a> handle </td></tr>
    <tr><td class="paramname">address</td><td>The <a class="el" href="class_socket_address.html" title="SocketAddress class.">SocketAddress</a> of the remote host </td></tr>
    <tr><td class="paramname">data</td><td>Buffer of data to send to the host </td></tr>
    <tr><td class="paramname">size</td><td>Size of the buffer in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of sent bytes on success, negative error code on failure </dd></dl>

<p>Implements <a class="el" href="class_network_stack.html#a75c6134df4d9116db6d9354c000bc354">NetworkStack</a>.</p>

</div>
</div>
<a id="a264b90bbb8fd5b6a5ac0c93ea5617453" name="a264b90bbb8fd5b6a5ac0c93ea5617453"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a264b90bbb8fd5b6a5ac0c93ea5617453">&#9670;&#160;</a></span>socket_recvfrom()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___net_socket.html#ga1aef0d1a2599df92bb4499b5c4262d25">nsapi_size_or_error_t</a> socket_recvfrom </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_socket_address.html">SocketAddress</a> *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___net_socket.html#gaeaef3ae1ffcf0d50c66fa2ca37621281">nsapi_size_t</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Receive a packet over a UDP socket. </p>
<p >Receives data and stores the source address in address if address is not NULL. Returns the number of bytes received into the buffer.</p>
<p >This call is non-blocking. If recvfrom would block, NSAPI_ERROR_WOULD_BLOCK is returned immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td><a class="el" href="class_socket.html" title="Socket interface.">Socket</a> handle </td></tr>
    <tr><td class="paramname">address</td><td>Destination for the source address or NULL </td></tr>
    <tr><td class="paramname">buffer</td><td>Destination buffer for data received from the host </td></tr>
    <tr><td class="paramname">size</td><td>Size of the buffer in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of received bytes on success, negative error code on failure </dd></dl>

<p>Implements <a class="el" href="class_network_stack.html#a33819f2c330cad315163b285e28371e0">NetworkStack</a>.</p>

</div>
</div>
<a id="aa39dc687ca69ce33807642fee47e7db8" name="aa39dc687ca69ce33807642fee47e7db8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa39dc687ca69ce33807642fee47e7db8">&#9670;&#160;</a></span>socket_attach()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void socket_attach </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register a callback on state change of the socket. </p>
<p >The specified callback will be called on state changes such as when the socket can recv/send/accept successfully and on when an error occurs. The callback may also be called spuriously without reason.</p>
<p >The callback may be called in an interrupt context and should not perform expensive operations such as recv/send calls.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td><a class="el" href="class_socket.html" title="Socket interface.">Socket</a> handle </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call on state change </td></tr>
    <tr><td class="paramname">data</td><td>Argument to pass to callback </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_network_stack.html#a836e3ddbc6fea2ce55bfcb477f56387c">NetworkStack</a>.</p>

</div>
</div>
<a id="a45cb37f5bbe111d0e64a45d9bb1204cc" name="a45cb37f5bbe111d0e64a45d9bb1204cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45cb37f5bbe111d0e64a45d9bb1204cc">&#9670;&#160;</a></span>setsockopt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> setsockopt </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>optval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>optlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set stack-specific socket options. </p>
<p >The setsockopt allow an application to pass stack-specific hints to the underlying stack. For unsupported options, NSAPI_ERROR_UNSUPPORTED is returned and the socket is unmodified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td><a class="el" href="class_socket.html" title="Socket interface.">Socket</a> handle. </td></tr>
    <tr><td class="paramname">level</td><td>Stack-specific protocol level. </td></tr>
    <tr><td class="paramname">optname</td><td>Stack-specific option identifier. </td></tr>
    <tr><td class="paramname">optval</td><td>Option value. </td></tr>
    <tr><td class="paramname">optlen</td><td>Length of the option value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NSAPI_ERROR_OK on success, negative error code on failure. </dd></dl>

<p>Reimplemented from <a class="el" href="class_network_stack.html#aac9e14a8be89337c5aea17fd705c3f46">NetworkStack</a>.</p>

</div>
</div>
<a id="a324213e6725ac48b2842bcdcce383022" name="a324213e6725ac48b2842bcdcce383022"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a324213e6725ac48b2842bcdcce383022">&#9670;&#160;</a></span>getsockopt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> getsockopt </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>optval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>optlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get stack-specific socket options. </p>
<p >The getstackopt allow an application to retrieve stack-specific hints from the underlying stack. For unsupported options, NSAPI_ERROR_UNSUPPORTED is returned and optval is unmodified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td><a class="el" href="class_socket.html" title="Socket interface.">Socket</a> handle. </td></tr>
    <tr><td class="paramname">level</td><td>Stack-specific protocol level. </td></tr>
    <tr><td class="paramname">optname</td><td>Stack-specific option identifier. </td></tr>
    <tr><td class="paramname">optval</td><td>Destination for option value. </td></tr>
    <tr><td class="paramname">optlen</td><td>Length of the option value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NSAPI_ERROR_OK on success, negative error code on failure. </dd></dl>

<p>Reimplemented from <a class="el" href="class_network_stack.html#add47ee70f334bcabd0df63f116143311">NetworkStack</a>.</p>

</div>
</div>
<a id="a7320cea7380b373238fac3de2881469c" name="a7320cea7380b373238fac3de2881469c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7320cea7380b373238fac3de2881469c">&#9670;&#160;</a></span>get_default_instance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_onboard_network_stack.html">OnboardNetworkStack</a> &amp; get_default_instance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the default on-board network stack. </p>
<p >Returns the default on-board network stack, as configured by JSON option nsapi.default-stack. </p>

</div>
</div>
<a id="a320ba06d48aa2401a4e62d69b79297ba" name="a320ba06d48aa2401a4e62d69b79297ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a320ba06d48aa2401a4e62d69b79297ba">&#9670;&#160;</a></span>onboardNetworkStack()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_onboard_network_stack.html">OnboardNetworkStack</a> * onboardNetworkStack </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dynamic downcast to a <a class="el" href="class_onboard_network_stack.html" title="mbed OS API for onboard IP stack abstraction">OnboardNetworkStack</a>. </p>

<p>Reimplemented from <a class="el" href="class_network_stack.html#aa5f46dd32614b93bc8a9d41b822a7ab7">NetworkStack</a>.</p>

<p class="definition">Definition at line <a class="el" href="_onboard_network_stack_8h_source.html#l00209">209</a> of file <a class="el" href="_onboard_network_stack_8h_source.html">OnboardNetworkStack.h</a>.</p>

</div>
</div>
<a id="a77de8d1afa4b83dd6f560dc39251e1eb" name="a77de8d1afa4b83dd6f560dc39251e1eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77de8d1afa4b83dd6f560dc39251e1eb">&#9670;&#160;</a></span>get_ipv6_link_local_address()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> get_ipv6_link_local_address </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_socket_address.html">SocketAddress</a> *&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the IPv6 link local address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td><a class="el" href="class_socket_address.html" title="SocketAddress class.">SocketAddress</a> representation of the link local IPv6 address </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NSAPI_ERROR_OK</td><td>on success </td></tr>
    <tr><td class="paramname">NSAPI_ERROR_UNSUPPORTED</td><td>if this feature is not supported </td></tr>
    <tr><td class="paramname">NSAPI_ERROR_PARAMETER</td><td>if the provided pointer is invalid </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad597f0496e42b17be72d00fa832e0963" name="ad597f0496e42b17be72d00fa832e0963"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad597f0496e42b17be72d00fa832e0963">&#9670;&#160;</a></span>get_ip_address_if()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> get_ip_address_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_socket_address.html">SocketAddress</a> *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>interface_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the local IP address on interface name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td><a class="el" href="class_socket_address.html" title="SocketAddress class.">SocketAddress</a> representation of the link local IPv6 address </td></tr>
    <tr><td class="paramname">interface_name</td><td>Network interface_name </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NSAPI_ERROR_OK</td><td>on success </td></tr>
    <tr><td class="paramname">NSAPI_ERROR_UNSUPPORTED</td><td>if this feature is not supported </td></tr>
    <tr><td class="paramname">NSAPI_ERROR_PARAMETER</td><td>if the provided pointer is invalid </td></tr>
    <tr><td class="paramname">NSAPI_ERROR_NO_ADDRESS</td><td>if the address cannot be obtained from stack </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a87a975b9ef736cef63334895c5770660" name="a87a975b9ef736cef63334895c5770660"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87a975b9ef736cef63334895c5770660">&#9670;&#160;</a></span>getaddrinfo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga4dc6e8ec26b364f135278917c3f27c6e">nsapi_value_or_error_t</a> getaddrinfo </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>hostname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_socket_address.html">SocketAddress</a> *&#160;</td>
          <td class="paramname"><em>hints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_socket_address.html">SocketAddress</a> **&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>interface_name</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Translate a hostname to the multiple IP addresses with specific version using network interface name. </p>
<p >The hostname may be either a domain name or an IP address. If the hostname is an IP address, no network transactions will be performed.</p>
<p >If no stack-specific <a class="el" href="class_d_n_s.html" title="Base class for DNS provider.">DNS</a> resolution is provided, the hostname will be resolve using a UDP socket on the stack.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hostname</td><td>Hostname to resolve. </td></tr>
    <tr><td class="paramname">hints</td><td>Pointer to a <a class="el" href="class_socket_address.html" title="SocketAddress class.">SocketAddress</a> with query parameters. </td></tr>
    <tr><td class="paramname">res</td><td>Pointer to a <a class="el" href="class_socket_address.html" title="SocketAddress class.">SocketAddress</a> array to store the result.. </td></tr>
    <tr><td class="paramname">interface_name</td><td>Network interface name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of results on success, negative error code on failure. </dd></dl>

<p>Implements <a class="el" href="class_d_n_s.html#a4e2299044fa2bbb37717a7661bb608f7">DNS</a>.</p>

</div>
</div>
<a id="aa964732e6c585b596adc760fe95f40f5" name="aa964732e6c585b596adc760fe95f40f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa964732e6c585b596adc760fe95f40f5">&#9670;&#160;</a></span>getaddrinfo_async()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga4dc6e8ec26b364f135278917c3f27c6e">nsapi_value_or_error_t</a> getaddrinfo_async </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>hostname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_socket_address.html">SocketAddress</a> *&#160;</td>
          <td class="paramname"><em>hints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmbed_1_1_callback.html">hostbyname_cb_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>interface_name</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Translates a hostname to the multiple IP addresses (asynchronous) </p>
<p >The hostname may be either a domain name or an IP address. If the hostname is an IP address, no network transactions will be performed.</p>
<p >If no stack-specific <a class="el" href="class_d_n_s.html" title="Base class for DNS provider.">DNS</a> resolution is provided, the hostname will be resolve using a UDP socket on the stack.</p>
<p >The call is non-blocking. Result of the <a class="el" href="class_d_n_s.html" title="Base class for DNS provider.">DNS</a> operation is returned by the callback. If this function returns failure, callback will not be called. In case that IP addresses are found from <a class="el" href="class_d_n_s.html" title="Base class for DNS provider.">DNS</a> cache, callback will be called before function returns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hostname</td><td>Hostname to resolve </td></tr>
    <tr><td class="paramname">hints</td><td>Pointer to a <a class="el" href="class_socket_address.html" title="SocketAddress class.">SocketAddress</a> with query parameters. </td></tr>
    <tr><td class="paramname">callback</td><td>Callback that is called for result </td></tr>
    <tr><td class="paramname">interface_name</td><td>Network interface_name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on immediate success, negative error code on immediate failure or a positive unique id that represents the hostname translation operation and can be passed to cancel </dd></dl>

<p>Implements <a class="el" href="class_d_n_s.html#afd29392442faa47f202cd69ede31dd03">DNS</a>.</p>

</div>
</div>
<a id="a26000e958701f5b35886fac1757c0bf4" name="a26000e958701f5b35886fac1757c0bf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26000e958701f5b35886fac1757c0bf4">&#9670;&#160;</a></span>gethostbyname_async_cancel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> gethostbyname_async_cancel </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cancels asynchronous hostname translation. </p>
<p >When translation is cancelled, callback will not be called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Unique id of the hostname translation operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NSAPI_ERROR_OK on success, negative error code on failure </dd></dl>

<p>Implements <a class="el" href="class_d_n_s.html#a3ba06c19476ec03988c7cd7807823d63">DNS</a>.</p>

</div>
</div>
<a id="adbf8dbcd865fee3ebef07fefbea802a7" name="adbf8dbcd865fee3ebef07fefbea802a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbf8dbcd865fee3ebef07fefbea802a7">&#9670;&#160;</a></span>add_dns_server()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> add_dns_server </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_socket_address.html">SocketAddress</a> &amp;&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>interface_name</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a domain name server to list of servers to query. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>Destination for the host address </td></tr>
    <tr><td class="paramname">interface_name</td><td>Network interface name. Currently unused, the server is added for all interfaces. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NSAPI_ERROR_OK on success, negative error code on failure </dd></dl>

<p>Implements <a class="el" href="class_d_n_s.html#ad222683619bf0a9e32e0499e25cd3a98">DNS</a>.</p>

</div>
</div>
<a id="aa6e5ab3271a4df6347b400bd7e16fdc0" name="aa6e5ab3271a4df6347b400bd7e16fdc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6e5ab3271a4df6347b400bd7e16fdc0">&#9670;&#160;</a></span>socket_sendto_control()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga1aef0d1a2599df92bb4499b5c4262d25">nsapi_size_or_error_t</a> socket_sendto_control </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___net_socket.html#gad0273762e5e5643dda87a74c7de45b69">nsapi_socket_t</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_socket_address.html">SocketAddress</a> &amp;&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___net_socket.html#gaeaef3ae1ffcf0d50c66fa2ca37621281">nsapi_size_t</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___net_socket.html#gad737df4845d4a53ab1bf720f73572a7e">nsapi_msghdr_t</a> *&#160;</td>
          <td class="paramname"><em>control</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___net_socket.html#gaeaef3ae1ffcf0d50c66fa2ca37621281">nsapi_size_t</a>&#160;</td>
          <td class="paramname"><em>control_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send a packet with ancillary data over a UDP socket. </p>
<p >Sends data to the specified address. Returns the number of bytes sent from the buffer.</p>
<p >This call is non-blocking. If sendto would block, NSAPI_ERROR_WOULD_BLOCK is returned immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td><a class="el" href="class_socket.html" title="Socket interface.">Socket</a> handle </td></tr>
    <tr><td class="paramname">address</td><td>The <a class="el" href="class_socket_address.html" title="SocketAddress class.">SocketAddress</a> of the remote host </td></tr>
    <tr><td class="paramname">data</td><td>Buffer of data to send to the host </td></tr>
    <tr><td class="paramname">size</td><td>Size of the buffer in bytes </td></tr>
    <tr><td class="paramname">control</td><td>Storage for ancillary data </td></tr>
    <tr><td class="paramname">control_size</td><td>Size of ancillary data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of sent bytes on success, negative error code on failure </dd></dl>

<p class="definition">Definition at line <a class="el" href="_network_stack_8h_source.html#l00408">408</a> of file <a class="el" href="_network_stack_8h_source.html">NetworkStack.h</a>.</p>

</div>
</div>
<a id="a345f6e49fcae39c08ca892e2d1b6337b" name="a345f6e49fcae39c08ca892e2d1b6337b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a345f6e49fcae39c08ca892e2d1b6337b">&#9670;&#160;</a></span>socket_recvfrom_control()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga1aef0d1a2599df92bb4499b5c4262d25">nsapi_size_or_error_t</a> socket_recvfrom_control </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___net_socket.html#gad0273762e5e5643dda87a74c7de45b69">nsapi_socket_t</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_socket_address.html">SocketAddress</a> *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___net_socket.html#gaeaef3ae1ffcf0d50c66fa2ca37621281">nsapi_size_t</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___net_socket.html#gad737df4845d4a53ab1bf720f73572a7e">nsapi_msghdr_t</a> *&#160;</td>
          <td class="paramname"><em>control</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___net_socket.html#gaeaef3ae1ffcf0d50c66fa2ca37621281">nsapi_size_t</a>&#160;</td>
          <td class="paramname"><em>control_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Receive a packet with ancillary data over a UDP socket. </p>
<p >Receives data and stores the source address in address if address is not NULL. Returns the number of bytes received into the buffer.</p>
<p >Ancillary data is stored into <code>control</code>. The caller needs to allocate a buffer that is large enough to contain the data they want to receive, then pass the pointer in through the <code>control</code> member. The data will be filled into <code>control</code>, beginning with a header specifying what data was received. See <a class="el" href="struct_msg_header_iterator.html" title="Allows iteration through the list of message headers received in the control parameter of the socket_...">MsgHeaderIterator</a> for how to parse this data.</p>
<p >This call is non-blocking. If recvfrom would block, NSAPI_ERROR_WOULD_BLOCK is returned immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td><a class="el" href="class_socket.html" title="Socket interface.">Socket</a> handle </td></tr>
    <tr><td class="paramname">address</td><td>Destination for the source address or NULL </td></tr>
    <tr><td class="paramname">data</td><td>Destination buffer for data received from the host </td></tr>
    <tr><td class="paramname">size</td><td>Size of the buffer in bytes </td></tr>
    <tr><td class="paramname">control</td><td>Storage for ancillary data </td></tr>
    <tr><td class="paramname">control_size</td><td>Size of ancillary data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of received bytes on success, negative error code on failure </dd></dl>

<p class="definition">Definition at line <a class="el" href="_network_stack_8h_source.html#l00441">441</a> of file <a class="el" href="_network_stack_8h_source.html">NetworkStack.h</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_nanostack.html">Nanostack</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>

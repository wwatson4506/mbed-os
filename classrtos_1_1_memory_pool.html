<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Mbed OS Reference: MemoryPool&lt; T, pool_sz &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="mbed-ce_55x55.png"/></td>
  <td id="projectalign">
   <div id="projectname">Mbed OS Reference
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classrtos_1_1_memory_pool.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle"><div class="title">MemoryPool&lt; T, pool_sz &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__mbed-os-public.html">Public API</a> &raquo; <a class="el" href="group__rtos-public-api.html">RTOS</a> &raquo; <a class="el" href="group__rtos___memory_pool.html">MemoryPool class</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Define and manage fixed-size memory pools of objects of a given type.  
 <a href="classrtos_1_1_memory_pool.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_memory_pool_8h_source.html">MemoryPool.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for MemoryPool&lt; T, pool_sz &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classrtos_1_1_memory_pool.png" usemap="#MemoryPool_3C_20T_2C_20pool_5Fsz_20_3E_map" alt=""/>
  <map id="MemoryPool_3C_20T_2C_20pool_5Fsz_20_3E_map" name="MemoryPool_3C_20T_2C_20pool_5Fsz_20_3E_map">
<area href="classmbed_1_1_non_copyable.html" alt="NonCopyable&lt; MemoryPool&lt; T, pool_sz &gt; &gt;" shape="rect" coords="0,0,267,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad84b296839bf3f443cd44918baa08592"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrtos_1_1_memory_pool.html#ad84b296839bf3f443cd44918baa08592">MemoryPool</a> ()</td></tr>
<tr class="memdesc:ad84b296839bf3f443cd44918baa08592"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create and Initialize a memory pool.  <a href="classrtos_1_1_memory_pool.html#ad84b296839bf3f443cd44918baa08592">More...</a><br /></td></tr>
<tr class="separator:ad84b296839bf3f443cd44918baa08592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a156294d0fe3e6e70fbc2708420e5dcd6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrtos_1_1_memory_pool.html#a156294d0fe3e6e70fbc2708420e5dcd6">~MemoryPool</a> ()</td></tr>
<tr class="memdesc:a156294d0fe3e6e70fbc2708420e5dcd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a memory pool.  <a href="classrtos_1_1_memory_pool.html#a156294d0fe3e6e70fbc2708420e5dcd6">More...</a><br /></td></tr>
<tr class="separator:a156294d0fe3e6e70fbc2708420e5dcd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91aa8b1c8bb6e5863674cf7f5152c9d1"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrtos_1_1_memory_pool.html#a91aa8b1c8bb6e5863674cf7f5152c9d1">alloc</a> ()</td></tr>
<tr class="memdesc:a91aa8b1c8bb6e5863674cf7f5152c9d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a memory block from a memory pool, without blocking.  <a href="classrtos_1_1_memory_pool.html#a91aa8b1c8bb6e5863674cf7f5152c9d1">More...</a><br /></td></tr>
<tr class="separator:a91aa8b1c8bb6e5863674cf7f5152c9d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac04087901b2c364dbf4dadeb1a07215e"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrtos_1_1_memory_pool.html#ac04087901b2c364dbf4dadeb1a07215e">try_alloc</a> ()</td></tr>
<tr class="memdesc:ac04087901b2c364dbf4dadeb1a07215e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a memory block from a memory pool, without blocking.  <a href="classrtos_1_1_memory_pool.html#ac04087901b2c364dbf4dadeb1a07215e">More...</a><br /></td></tr>
<tr class="separator:ac04087901b2c364dbf4dadeb1a07215e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6185391d15defb5de9336056fdbdef5a"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrtos_1_1_memory_pool.html#a6185391d15defb5de9336056fdbdef5a">alloc_for</a> (uint32_t millisec)</td></tr>
<tr class="memdesc:a6185391d15defb5de9336056fdbdef5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a memory block from a memory pool, optionally blocking.  <a href="classrtos_1_1_memory_pool.html#a6185391d15defb5de9336056fdbdef5a">More...</a><br /></td></tr>
<tr class="separator:a6185391d15defb5de9336056fdbdef5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac41a41660aa033dfc03731ddd4c545d1"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrtos_1_1_memory_pool.html#ac41a41660aa033dfc03731ddd4c545d1">try_alloc_for</a> (Kernel::Clock::duration_u32 rel_time)</td></tr>
<tr class="memdesc:ac41a41660aa033dfc03731ddd4c545d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a memory block from a memory pool, optionally blocking.  <a href="classrtos_1_1_memory_pool.html#ac41a41660aa033dfc03731ddd4c545d1">More...</a><br /></td></tr>
<tr class="separator:ac41a41660aa033dfc03731ddd4c545d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae652632219b64d1f63e66fee4549aa15"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrtos_1_1_memory_pool.html#ae652632219b64d1f63e66fee4549aa15">alloc_until</a> (uint64_t millisec)</td></tr>
<tr class="memdesc:ae652632219b64d1f63e66fee4549aa15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a memory block from a memory pool, blocking.  <a href="classrtos_1_1_memory_pool.html#ae652632219b64d1f63e66fee4549aa15">More...</a><br /></td></tr>
<tr class="separator:ae652632219b64d1f63e66fee4549aa15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60f8c8ad3bf9cb1a335ec0f80c58a2b2"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrtos_1_1_memory_pool.html#a60f8c8ad3bf9cb1a335ec0f80c58a2b2">try_alloc_until</a> (Kernel::Clock::time_point abs_time)</td></tr>
<tr class="memdesc:a60f8c8ad3bf9cb1a335ec0f80c58a2b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a memory block from a memory pool, blocking.  <a href="classrtos_1_1_memory_pool.html#a60f8c8ad3bf9cb1a335ec0f80c58a2b2">More...</a><br /></td></tr>
<tr class="separator:a60f8c8ad3bf9cb1a335ec0f80c58a2b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0fa91b977c5112160ff3c723c1ad58a"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrtos_1_1_memory_pool.html#ac0fa91b977c5112160ff3c723c1ad58a">calloc</a> ()</td></tr>
<tr class="memdesc:ac0fa91b977c5112160ff3c723c1ad58a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a memory block from a memory pool, without blocking, and set memory block to zero.  <a href="classrtos_1_1_memory_pool.html#ac0fa91b977c5112160ff3c723c1ad58a">More...</a><br /></td></tr>
<tr class="separator:ac0fa91b977c5112160ff3c723c1ad58a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae173100129a2da2592458b4e3df76c82"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrtos_1_1_memory_pool.html#ae173100129a2da2592458b4e3df76c82">try_calloc</a> ()</td></tr>
<tr class="memdesc:ae173100129a2da2592458b4e3df76c82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a memory block from a memory pool, without blocking, and set memory block to zero.  <a href="classrtos_1_1_memory_pool.html#ae173100129a2da2592458b4e3df76c82">More...</a><br /></td></tr>
<tr class="separator:ae173100129a2da2592458b4e3df76c82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b65530fbcc31eb258ccb3576a3c0fe9"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrtos_1_1_memory_pool.html#a0b65530fbcc31eb258ccb3576a3c0fe9">calloc_for</a> (uint32_t millisec)</td></tr>
<tr class="memdesc:a0b65530fbcc31eb258ccb3576a3c0fe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a memory block from a memory pool, optionally blocking, and set memory block to zero.  <a href="classrtos_1_1_memory_pool.html#a0b65530fbcc31eb258ccb3576a3c0fe9">More...</a><br /></td></tr>
<tr class="separator:a0b65530fbcc31eb258ccb3576a3c0fe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a1d96530566819a3626a63b8a159e8f"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrtos_1_1_memory_pool.html#a3a1d96530566819a3626a63b8a159e8f">try_calloc_for</a> (Kernel::Clock::duration_u32 rel_time)</td></tr>
<tr class="memdesc:a3a1d96530566819a3626a63b8a159e8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a memory block from a memory pool, optionally blocking, and set memory block to zero.  <a href="classrtos_1_1_memory_pool.html#a3a1d96530566819a3626a63b8a159e8f">More...</a><br /></td></tr>
<tr class="separator:a3a1d96530566819a3626a63b8a159e8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acffdc446a0759a5e0eed01264c830008"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrtos_1_1_memory_pool.html#acffdc446a0759a5e0eed01264c830008">calloc_until</a> (uint64_t millisec)</td></tr>
<tr class="memdesc:acffdc446a0759a5e0eed01264c830008"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a memory block from a memory pool, blocking, and set memory block to zero.  <a href="classrtos_1_1_memory_pool.html#acffdc446a0759a5e0eed01264c830008">More...</a><br /></td></tr>
<tr class="separator:acffdc446a0759a5e0eed01264c830008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40981c282e790d9b49e73182462fdcc1"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrtos_1_1_memory_pool.html#a40981c282e790d9b49e73182462fdcc1">try_calloc_until</a> (Kernel::Clock::time_point abs_time)</td></tr>
<tr class="memdesc:a40981c282e790d9b49e73182462fdcc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a memory block from a memory pool, blocking, and set memory block to zero.  <a href="classrtos_1_1_memory_pool.html#a40981c282e790d9b49e73182462fdcc1">More...</a><br /></td></tr>
<tr class="separator:a40981c282e790d9b49e73182462fdcc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d6a78f2054f1e24ea86f7f4c4df76c8"><td class="memItemLeft" align="right" valign="top">osStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrtos_1_1_memory_pool.html#a7d6a78f2054f1e24ea86f7f4c4df76c8">free</a> (T *block)</td></tr>
<tr class="memdesc:a7d6a78f2054f1e24ea86f7f4c4df76c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a memory block.  <a href="classrtos_1_1_memory_pool.html#a7d6a78f2054f1e24ea86f7f4c4df76c8">More...</a><br /></td></tr>
<tr class="separator:a7d6a78f2054f1e24ea86f7f4c4df76c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T, uint32_t pool_sz&gt;<br />
class rtos::MemoryPool&lt; T, pool_sz &gt;</div><p >Define and manage fixed-size memory pools of objects of a given type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>data type of a single object (element). </td></tr>
    <tr><td class="paramname">queue_sz</td><td>maximum number of objects (elements) in the memory pool.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Memory considerations: The memory pool data store and control structures will be created on current thread's stack, both for the mbed OS and underlying RTOS objects (static or dynamic RTOS memory pools are not being used).</dd>
<dd>
Bare metal profile: This class is not supported. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_memory_pool_8h_source.html#l00059">59</a> of file <a class="el" href="_memory_pool_8h_source.html">MemoryPool.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad84b296839bf3f443cd44918baa08592" name="ad84b296839bf3f443cd44918baa08592"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad84b296839bf3f443cd44918baa08592">&#9670;&#160;</a></span>MemoryPool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrtos_1_1_memory_pool.html">MemoryPool</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create and Initialize a memory pool. </p>
<dl class="section note"><dt>Note</dt><dd>You cannot call this function from ISR context. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_memory_pool_8h_source.html#l00066">66</a> of file <a class="el" href="_memory_pool_8h_source.html">MemoryPool.h</a>.</p>

</div>
</div>
<a id="a156294d0fe3e6e70fbc2708420e5dcd6" name="a156294d0fe3e6e70fbc2708420e5dcd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a156294d0fe3e6e70fbc2708420e5dcd6">&#9670;&#160;</a></span>~MemoryPool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="classrtos_1_1_memory_pool.html">MemoryPool</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a memory pool. </p>
<dl class="section note"><dt>Note</dt><dd>You cannot call this function from ISR context. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_memory_pool_8h_source.html#l00082">82</a> of file <a class="el" href="_memory_pool_8h_source.html">MemoryPool.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a91aa8b1c8bb6e5863674cf7f5152c9d1" name="a91aa8b1c8bb6e5863674cf7f5152c9d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91aa8b1c8bb6e5863674cf7f5152c9d1">&#9670;&#160;</a></span>alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T * alloc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a memory block from a memory pool, without blocking. </p>
<dl class="section return"><dt>Returns</dt><dd>address of the allocated memory block or nullptr in case of no memory available.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>You may call this function from ISR context. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000092">Deprecated:</a></b></dt><dd>Replaced with try_alloc. In future <a class="el" href="classrtos_1_1_memory_pool.html#a91aa8b1c8bb6e5863674cf7f5152c9d1" title="Allocate a memory block from a memory pool, without blocking.">alloc()</a> will be an untimed blocking call. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_memory_pool_8h_source.html#l00094">94</a> of file <a class="el" href="_memory_pool_8h_source.html">MemoryPool.h</a>.</p>

</div>
</div>
<a id="ac04087901b2c364dbf4dadeb1a07215e" name="ac04087901b2c364dbf4dadeb1a07215e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac04087901b2c364dbf4dadeb1a07215e">&#9670;&#160;</a></span>try_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T * try_alloc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a memory block from a memory pool, without blocking. </p>
<p >This method works like <code>std::malloc</code> or <code>std::allocator&lt;T&gt;::allocate</code> in that the returned memory block is not initialized. For types with a non-trivial constructor placement new must be used to construct an object in the returned storage.</p>
<p >Example: </p><div class="fragment"><div class="line">MyObject *obj = pool.alloc();</div>
<div class="line"><span class="keywordflow">if</span> (obj) {</div>
<div class="line">    <span class="keyword">new</span> (obj) MyObject(1, 2);</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>address of the allocated memory block or nullptr in case of no memory available.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>You may call this function from ISR context. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_memory_pool_8h_source.html#l00117">117</a> of file <a class="el" href="_memory_pool_8h_source.html">MemoryPool.h</a>.</p>

</div>
</div>
<a id="a6185391d15defb5de9336056fdbdef5a" name="a6185391d15defb5de9336056fdbdef5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6185391d15defb5de9336056fdbdef5a">&#9670;&#160;</a></span>alloc_for()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T * alloc_for </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>millisec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a memory block from a memory pool, optionally blocking. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">millisec</td><td>timeout value (osWaitForever to wait forever) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>address of the allocated memory block or nullptr in case of no memory available.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>You may call this function from ISR context if the millisec parameter is set to 0. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000093">Deprecated:</a></b></dt><dd>Replaced with <code>try_alloc_for</code>. For example use <code>try_alloc_for(5s)</code> rather than <code>alloc_for(5000)</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_memory_pool_8h_source.html#l00130">130</a> of file <a class="el" href="_memory_pool_8h_source.html">MemoryPool.h</a>.</p>

</div>
</div>
<a id="ac41a41660aa033dfc03731ddd4c545d1" name="ac41a41660aa033dfc03731ddd4c545d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac41a41660aa033dfc03731ddd4c545d1">&#9670;&#160;</a></span>try_alloc_for()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T * try_alloc_for </td>
          <td>(</td>
          <td class="paramtype">Kernel::Clock::duration_u32&#160;</td>
          <td class="paramname"><em>rel_time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a memory block from a memory pool, optionally blocking. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrtos_1_1_memory_pool.html#ac04087901b2c364dbf4dadeb1a07215e" title="Allocate a memory block from a memory pool, without blocking.">MemoryPool::try_alloc</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rel_time</td><td>timeout value (<a class="el" href="namespacertos_1_1_kernel.html#a29baed0762de3912b6b7592150a9498e" title="Magic &quot;wait forever&quot; constant for Kernel::Clock::duration_u32-based APIs.">Kernel::wait_for_u32_forever</a> to wait forever) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>address of the allocated memory block or nullptr in case of no memory available.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>You may call this function from ISR context if the rel_time parameter is set to 0. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_memory_pool_8h_source.html#l00142">142</a> of file <a class="el" href="_memory_pool_8h_source.html">MemoryPool.h</a>.</p>

</div>
</div>
<a id="ae652632219b64d1f63e66fee4549aa15" name="ae652632219b64d1f63e66fee4549aa15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae652632219b64d1f63e66fee4549aa15">&#9670;&#160;</a></span>alloc_until()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T * alloc_until </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>millisec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a memory block from a memory pool, blocking. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">millisec</td><td>absolute timeout time, referenced to <a class="el" href="namespacertos_1_1_kernel.html#a5744e4ade0a4700887b7f390a530da02" title="Read the current RTOS kernel millisecond tick count.">Kernel::get_ms_count()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>address of the allocated memory block or nullptr in case of no memory available.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>You cannot call this function from ISR context. </dd>
<dd>
the underlying RTOS may have a limit to the maximum wait time due to internal 32-bit computations, but this is guaranteed to work if the wait is &lt;= 0x7fffffff milliseconds (~24 days). If the limit is exceeded, the wait will time out earlier than specified. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000094">Deprecated:</a></b></dt><dd>Replaced with <code>try_alloc_until</code>. For example use <code>try_alloc_until(Kernel::Clock::now() + 5s)</code> rather than <code>alloc_until(<a class="el" href="namespacertos_1_1_kernel.html#a5744e4ade0a4700887b7f390a530da02" title="Read the current RTOS kernel millisecond tick count.">Kernel::get_ms_count()</a> + 5000)</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_memory_pool_8h_source.html#l00160">160</a> of file <a class="el" href="_memory_pool_8h_source.html">MemoryPool.h</a>.</p>

</div>
</div>
<a id="a60f8c8ad3bf9cb1a335ec0f80c58a2b2" name="a60f8c8ad3bf9cb1a335ec0f80c58a2b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60f8c8ad3bf9cb1a335ec0f80c58a2b2">&#9670;&#160;</a></span>try_alloc_until()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T * try_alloc_until </td>
          <td>(</td>
          <td class="paramtype">Kernel::Clock::time_point&#160;</td>
          <td class="paramname"><em>abs_time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a memory block from a memory pool, blocking. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrtos_1_1_memory_pool.html#ac04087901b2c364dbf4dadeb1a07215e" title="Allocate a memory block from a memory pool, without blocking.">MemoryPool::try_alloc</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">abs_time</td><td>absolute timeout time, referenced to <a class="el" href="structrtos_1_1_kernel_1_1_clock.html" title="A C++11 chrono TrivialClock for the kernel millisecond tick count.">Kernel::Clock</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>address of the allocated memory block or nullptr in case of no memory available.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>You cannot call this function from ISR context. </dd>
<dd>
the underlying RTOS may have a limit to the maximum wait time due to internal 32-bit computations, but this is guaranteed to work if the wait is &lt;= 0x7fffffff milliseconds (~24 days). If the limit is exceeded, the wait will time out earlier than specified. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_memory_pool_8h_source.html#l00176">176</a> of file <a class="el" href="_memory_pool_8h_source.html">MemoryPool.h</a>.</p>

</div>
</div>
<a id="ac0fa91b977c5112160ff3c723c1ad58a" name="ac0fa91b977c5112160ff3c723c1ad58a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0fa91b977c5112160ff3c723c1ad58a">&#9670;&#160;</a></span>calloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T * calloc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a memory block from a memory pool, without blocking, and set memory block to zero. </p>
<dl class="section return"><dt>Returns</dt><dd>address of the allocated memory block or nullptr in case of no memory available.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>You may call this function from ISR context. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000095">Deprecated:</a></b></dt><dd>Replaced with try_calloc. In future <a class="el" href="classrtos_1_1_memory_pool.html#ac0fa91b977c5112160ff3c723c1ad58a" title="Allocate a memory block from a memory pool, without blocking, and set memory block to zero.">calloc()</a> will be an untimed blocking call. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_memory_pool_8h_source.html#l00197">197</a> of file <a class="el" href="_memory_pool_8h_source.html">MemoryPool.h</a>.</p>

</div>
</div>
<a id="ae173100129a2da2592458b4e3df76c82" name="ae173100129a2da2592458b4e3df76c82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae173100129a2da2592458b4e3df76c82">&#9670;&#160;</a></span>try_calloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T * try_calloc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a memory block from a memory pool, without blocking, and set memory block to zero. </p>
<dl class="section return"><dt>Returns</dt><dd>address of the allocated memory block or nullptr in case of no memory available.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>You may call this function from ISR context. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_memory_pool_8h_source.html#l00207">207</a> of file <a class="el" href="_memory_pool_8h_source.html">MemoryPool.h</a>.</p>

</div>
</div>
<a id="a0b65530fbcc31eb258ccb3576a3c0fe9" name="a0b65530fbcc31eb258ccb3576a3c0fe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b65530fbcc31eb258ccb3576a3c0fe9">&#9670;&#160;</a></span>calloc_for()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T * calloc_for </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>millisec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a memory block from a memory pool, optionally blocking, and set memory block to zero. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">millisec</td><td>timeout value (osWaitForever to wait forever) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>address of the allocated memory block or nullptr in case of no memory available.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>You may call this function from ISR context if the millisec parameter is set to 0. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000096">Deprecated:</a></b></dt><dd>Replaced with <code>try_calloc_for</code>. For example use <code>try_calloc_for(5s)</code> rather than <code>calloc_for(5000)</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_memory_pool_8h_source.html#l00224">224</a> of file <a class="el" href="_memory_pool_8h_source.html">MemoryPool.h</a>.</p>

</div>
</div>
<a id="a3a1d96530566819a3626a63b8a159e8f" name="a3a1d96530566819a3626a63b8a159e8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a1d96530566819a3626a63b8a159e8f">&#9670;&#160;</a></span>try_calloc_for()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T * try_calloc_for </td>
          <td>(</td>
          <td class="paramtype">Kernel::Clock::duration_u32&#160;</td>
          <td class="paramname"><em>rel_time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a memory block from a memory pool, optionally blocking, and set memory block to zero. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rel_time</td><td>timeout value (<a class="el" href="namespacertos_1_1_kernel.html#a29baed0762de3912b6b7592150a9498e" title="Magic &quot;wait forever&quot; constant for Kernel::Clock::duration_u32-based APIs.">Kernel::wait_for_u32_forever</a> to wait forever) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>address of the allocated memory block or nullptr in case of no memory available.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>You may call this function from ISR context if the rel_time parameter is set to 0. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_memory_pool_8h_source.html#l00235">235</a> of file <a class="el" href="_memory_pool_8h_source.html">MemoryPool.h</a>.</p>

</div>
</div>
<a id="acffdc446a0759a5e0eed01264c830008" name="acffdc446a0759a5e0eed01264c830008"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acffdc446a0759a5e0eed01264c830008">&#9670;&#160;</a></span>calloc_until()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T * calloc_until </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>millisec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a memory block from a memory pool, blocking, and set memory block to zero. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">millisec</td><td>absolute timeout time, referenced to <a class="el" href="namespacertos_1_1_kernel.html#a5744e4ade0a4700887b7f390a530da02" title="Read the current RTOS kernel millisecond tick count.">Kernel::get_ms_count()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>address of the allocated memory block or nullptr in case of no memory available.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>You cannot call this function from ISR context. </dd>
<dd>
the underlying RTOS may have a limit to the maximum wait time due to internal 32-bit computations, but this is guaranteed to work if the wait is &lt;= 0x7fffffff milliseconds (~24 days). If the limit is exceeded, the wait will time out earlier than specified. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000097">Deprecated:</a></b></dt><dd>Replaced with <code>try_calloc_until</code>. For example use <code>try_calloc_until(Kernel::Clock::now() + 5s)</code> rather than <code>calloc_until(<a class="el" href="namespacertos_1_1_kernel.html#a5744e4ade0a4700887b7f390a530da02" title="Read the current RTOS kernel millisecond tick count.">Kernel::get_ms_count()</a> + 5000)</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_memory_pool_8h_source.html#l00257">257</a> of file <a class="el" href="_memory_pool_8h_source.html">MemoryPool.h</a>.</p>

</div>
</div>
<a id="a40981c282e790d9b49e73182462fdcc1" name="a40981c282e790d9b49e73182462fdcc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40981c282e790d9b49e73182462fdcc1">&#9670;&#160;</a></span>try_calloc_until()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T * try_calloc_until </td>
          <td>(</td>
          <td class="paramtype">Kernel::Clock::time_point&#160;</td>
          <td class="paramname"><em>abs_time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a memory block from a memory pool, blocking, and set memory block to zero. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">abs_time</td><td>absolute timeout time, referenced to <a class="el" href="structrtos_1_1_kernel_1_1_clock.html" title="A C++11 chrono TrivialClock for the kernel millisecond tick count.">Kernel::Clock</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>address of the allocated memory block or nullptr in case of no memory available.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>You cannot call this function from ISR context. </dd>
<dd>
the underlying RTOS may have a limit to the maximum wait time due to internal 32-bit computations, but this is guaranteed to work if the wait is &lt;= 0x7fffffff milliseconds (~24 days). If the limit is exceeded, the wait will time out earlier than specified. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_memory_pool_8h_source.html#l00272">272</a> of file <a class="el" href="_memory_pool_8h_source.html">MemoryPool.h</a>.</p>

</div>
</div>
<a id="a7d6a78f2054f1e24ea86f7f4c4df76c8" name="a7d6a78f2054f1e24ea86f7f4c4df76c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d6a78f2054f1e24ea86f7f4c4df76c8">&#9670;&#160;</a></span>free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">osStatus free </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free a memory block. </p>
<p >This method works like <code>std::free</code> or <code>std::allocator&lt;T&gt;::deallocate</code> in that any object in the memory is not destroyed. For types with a non-trivial destructor that destructor must be called manually before freeing the memory.</p>
<p >Example: </p><div class="fragment"><div class="line">obj-&gt;~MyObject();</div>
<div class="line">pool.free(obj);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>address of the allocated memory block to be freed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>osOK on successful deallocation, osErrorParameter if given memory block id is nullptr or invalid, or osErrorResource if given memory block is in an invalid memory pool state.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>You may call this function from ISR context. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_memory_pool_8h_source.html#l00300">300</a> of file <a class="el" href="_memory_pool_8h_source.html">MemoryPool.h</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>rtos</b></li><li class="navelem"><a class="el" href="classrtos_1_1_memory_pool.html">MemoryPool</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Mbed OS Reference: QUECTEL_BG96_CellularContext Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="mbed-ce_55x55.png"/></td>
  <td id="projectalign">
   <div id="projectname">Mbed OS Reference
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classmbed_1_1_q_u_e_c_t_e_l___b_g96___cellular_context.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a>  </div>
  <div class="headertitle"><div class="title">QUECTEL_BG96_CellularContext Class Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for QUECTEL_BG96_CellularContext:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classmbed_1_1_q_u_e_c_t_e_l___b_g96___cellular_context.png" usemap="#QUECTEL_5FBG96_5FCellularContext_map" alt=""/>
  <map id="QUECTEL_5FBG96_5FCellularContext_map" name="QUECTEL_5FBG96_5FCellularContext_map">
<area href="classmbed_1_1_a_t___cellular_context.html" alt="AT_CellularContext" shape="rect" coords="0,224,200,248"/>
<area href="classmbed_1_1_cellular_context.html" title="CellularContext is CellularInterface/NetworkInterface with extensions for cellular connectivity." alt="CellularContext" shape="rect" coords="0,168,200,192"/>
<area href="class_cellular_interface.html" title="Common interface that is shared between cellular interfaces." alt="CellularInterface" shape="rect" coords="0,112,200,136"/>
<area href="class_network_interface.html" title="Common interface that is shared between network devices." alt="NetworkInterface" shape="rect" coords="0,56,200,80"/>
<area href="class_d_n_s.html" title="Base class for DNS provider." alt="DNS" shape="rect" coords="0,0,200,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:abb962f363d7a7ec29b27844a1e5f7ecc"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; void(<a class="el" href="group___net_socket.html#ga4dc6e8ec26b364f135278917c3f27c6e">nsapi_value_or_error_t</a> result, <a class="el" href="class_socket_address.html">SocketAddress</a> *address)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_interface.html#abb962f363d7a7ec29b27844a1e5f7ecc">hostbyname_cb_t</a></td></tr>
<tr class="memdesc:abb962f363d7a7ec29b27844a1e5f7ecc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hostname translation callback (for use with <a class="el" href="class_network_interface.html#ab43b64cae1f145615db7f697d34552d7" title="Translate a hostname to an IP address (asynchronous) using network interface name.">gethostbyname_async()</a>).  <a href="class_network_interface.html#abb962f363d7a7ec29b27844a1e5f7ecc">More...</a><br /></td></tr>
<tr class="separator:abb962f363d7a7ec29b27844a1e5f7ecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8dc0651d23c76c830d241236e22f0a1b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_a_t___cellular_context.html#a8dc0651d23c76c830d241236e22f0a1b">set_blocking</a> (bool blocking)</td></tr>
<tr class="memdesc:a8dc0651d23c76c830d241236e22f0a1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set asynchronous operation of <a class="el" href="classmbed_1_1_a_t___cellular_context.html#a6e5fe7426361973a91d288f11c047dfa" title="Attempt to connect to a cellular network.">connect()</a> and <a class="el" href="classmbed_1_1_a_t___cellular_context.html#a280bc602c16c7e591424b9aed3e2b17e" title="Stop the interface.">disconnect()</a> calls.  <a href="classmbed_1_1_a_t___cellular_context.html#a8dc0651d23c76c830d241236e22f0a1b">More...</a><br /></td></tr>
<tr class="separator:a8dc0651d23c76c830d241236e22f0a1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ab48210e24fc7efb4e1cada14c4b57b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_a_t___cellular_context.html#a2ab48210e24fc7efb4e1cada14c4b57b">get_ip_address</a> (<a class="el" href="class_socket_address.html">SocketAddress</a> *address)</td></tr>
<tr class="memdesc:a2ab48210e24fc7efb4e1cada14c4b57b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the local IP address.   <a href="classmbed_1_1_a_t___cellular_context.html#a2ab48210e24fc7efb4e1cada14c4b57b">More...</a><br /></td></tr>
<tr class="separator:a2ab48210e24fc7efb4e1cada14c4b57b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a241ab3896730d179348de54e86dcd36c"><td class="memItemLeft" align="right" valign="top">virtual char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_a_t___cellular_context.html#a241ab3896730d179348de54e86dcd36c">get_interface_name</a> (char *interface_name)</td></tr>
<tr class="memdesc:a241ab3896730d179348de54e86dcd36c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the network interface name.  <a href="classmbed_1_1_a_t___cellular_context.html#a241ab3896730d179348de54e86dcd36c">More...</a><br /></td></tr>
<tr class="separator:a241ab3896730d179348de54e86dcd36c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27082cfcaab9462699208893d05a70d1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_a_t___cellular_context.html#a27082cfcaab9462699208893d05a70d1">attach</a> (<a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; void(nsapi_event_t, intptr_t)&gt; status_cb)</td></tr>
<tr class="memdesc:a27082cfcaab9462699208893d05a70d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register callback for status reporting.  <a href="classmbed_1_1_a_t___cellular_context.html#a27082cfcaab9462699208893d05a70d1">More...</a><br /></td></tr>
<tr class="separator:a27082cfcaab9462699208893d05a70d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e5fe7426361973a91d288f11c047dfa"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_a_t___cellular_context.html#a6e5fe7426361973a91d288f11c047dfa">connect</a> ()</td></tr>
<tr class="memdesc:a6e5fe7426361973a91d288f11c047dfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to connect to a cellular network.  <a href="classmbed_1_1_a_t___cellular_context.html#a6e5fe7426361973a91d288f11c047dfa">More...</a><br /></td></tr>
<tr class="separator:a6e5fe7426361973a91d288f11c047dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4485df99d674a3e9492f317545f9c730"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_a_t___cellular_context.html#a4485df99d674a3e9492f317545f9c730">connect</a> (const char *sim_pin, const char *apn=0, const char *uname=0, const char *pwd=0)</td></tr>
<tr class="memdesc:a4485df99d674a3e9492f317545f9c730"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to connect to a cellular network with a PIN and credentials.  <a href="classmbed_1_1_a_t___cellular_context.html#a4485df99d674a3e9492f317545f9c730">More...</a><br /></td></tr>
<tr class="separator:a4485df99d674a3e9492f317545f9c730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a280bc602c16c7e591424b9aed3e2b17e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_a_t___cellular_context.html#a280bc602c16c7e591424b9aed3e2b17e">disconnect</a> ()</td></tr>
<tr class="memdesc:a280bc602c16c7e591424b9aed3e2b17e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop the interface.  <a href="classmbed_1_1_a_t___cellular_context.html#a280bc602c16c7e591424b9aed3e2b17e">More...</a><br /></td></tr>
<tr class="separator:a280bc602c16c7e591424b9aed3e2b17e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a840e46edfb6792d1c588cf95c0387cd6"><td class="memItemLeft" align="right" valign="top">virtual nsapi_connection_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_a_t___cellular_context.html#a840e46edfb6792d1c588cf95c0387cd6">get_connection_status</a> () const</td></tr>
<tr class="memdesc:a840e46edfb6792d1c588cf95c0387cd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the connection status.  <a href="classmbed_1_1_a_t___cellular_context.html#a840e46edfb6792d1c588cf95c0387cd6">More...</a><br /></td></tr>
<tr class="separator:a840e46edfb6792d1c588cf95c0387cd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6809216603111fe387d432f1a349ca18"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_a_t___cellular_context.html#a6809216603111fe387d432f1a349ca18">is_connected</a> ()</td></tr>
<tr class="memdesc:a6809216603111fe387d432f1a349ca18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the connection is currently established.  <a href="classmbed_1_1_a_t___cellular_context.html#a6809216603111fe387d432f1a349ca18">More...</a><br /></td></tr>
<tr class="separator:a6809216603111fe387d432f1a349ca18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6bdd14db4e305a45c0894c337b436ff"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_a_t___cellular_context.html#aa6bdd14db4e305a45c0894c337b436ff">set_plmn</a> (const char *plmn)</td></tr>
<tr class="memdesc:aa6bdd14db4e305a45c0894c337b436ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the plmn.  <a href="classmbed_1_1_a_t___cellular_context.html#aa6bdd14db4e305a45c0894c337b436ff">More...</a><br /></td></tr>
<tr class="separator:aa6bdd14db4e305a45c0894c337b436ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48e62c440e1c6bb29d0d92a5092a8dda"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_a_t___cellular_context.html#a48e62c440e1c6bb29d0d92a5092a8dda">set_sim_pin</a> (const char *sim_pin)</td></tr>
<tr class="memdesc:a48e62c440e1c6bb29d0d92a5092a8dda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the PIN code for SIM card.  <a href="classmbed_1_1_a_t___cellular_context.html#a48e62c440e1c6bb29d0d92a5092a8dda">More...</a><br /></td></tr>
<tr class="separator:a48e62c440e1c6bb29d0d92a5092a8dda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a779ee0ee864b5751bc6d9a4915e841c8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_a_t___cellular_context.html#a779ee0ee864b5751bc6d9a4915e841c8">set_credentials</a> (const char *apn, const char *uname=0, const char *pwd=0)</td></tr>
<tr class="memdesc:a779ee0ee864b5751bc6d9a4915e841c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the cellular network credentials.  <a href="classmbed_1_1_a_t___cellular_context.html#a779ee0ee864b5751bc6d9a4915e841c8">More...</a><br /></td></tr>
<tr class="separator:a779ee0ee864b5751bc6d9a4915e841c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8582bf96adee463f562f2eeba0dbbdc"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_a_t___cellular_context.html#aa8582bf96adee463f562f2eeba0dbbdc">get_pdpcontext_params</a> (<a class="el" href="classmbed_1_1_cellular_list.html">pdpContextList_t</a> &amp;params_list)</td></tr>
<tr class="memdesc:aa8582bf96adee463f562f2eeba0dbbdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the relevant information for an active nonsecondary PDP context.  <a href="classmbed_1_1_a_t___cellular_context.html#aa8582bf96adee463f562f2eeba0dbbdc">More...</a><br /></td></tr>
<tr class="separator:aa8582bf96adee463f562f2eeba0dbbdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a800824b23643765f630856bb064a0835"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_a_t___cellular_context.html#a800824b23643765f630856bb064a0835">get_rate_control</a> (CellularContext::RateControlExceptionReports &amp;reports, CellularContext::RateControlUplinkTimeUnit &amp;time_unit, int &amp;uplink_rate)</td></tr>
<tr class="memdesc:a800824b23643765f630856bb064a0835"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get APN rate control.  <a href="classmbed_1_1_a_t___cellular_context.html#a800824b23643765f630856bb064a0835">More...</a><br /></td></tr>
<tr class="separator:a800824b23643765f630856bb064a0835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8780d79e018226d7a357804985507fb"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_a_t___cellular_context.html#af8780d79e018226d7a357804985507fb">get_apn_backoff_timer</a> (int &amp;backoff_timer)</td></tr>
<tr class="memdesc:af8780d79e018226d7a357804985507fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get backoff timer value.  <a href="classmbed_1_1_a_t___cellular_context.html#af8780d79e018226d7a357804985507fb">More...</a><br /></td></tr>
<tr class="separator:af8780d79e018226d7a357804985507fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa497e462000128164fb5c331772fd388"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_a_t___cellular_context.html#aa497e462000128164fb5c331772fd388">set_device_ready</a> ()</td></tr>
<tr class="memdesc:aa497e462000128164fb5c331772fd388"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the interface.  <a href="classmbed_1_1_a_t___cellular_context.html#aa497e462000128164fb5c331772fd388">More...</a><br /></td></tr>
<tr class="separator:aa497e462000128164fb5c331772fd388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8a995c0dcea9eefce924cbffc5bb98c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_a_t___cellular_context.html#ae8a995c0dcea9eefce924cbffc5bb98c">set_sim_ready</a> ()</td></tr>
<tr class="memdesc:ae8a995c0dcea9eefce924cbffc5bb98c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the interface.  <a href="classmbed_1_1_a_t___cellular_context.html#ae8a995c0dcea9eefce924cbffc5bb98c">More...</a><br /></td></tr>
<tr class="separator:ae8a995c0dcea9eefce924cbffc5bb98c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64bc07548298bc314f33cc6e65ce7ae6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_a_t___cellular_context.html#a64bc07548298bc314f33cc6e65ce7ae6">register_to_network</a> ()</td></tr>
<tr class="memdesc:a64bc07548298bc314f33cc6e65ce7ae6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the interface.  <a href="classmbed_1_1_a_t___cellular_context.html#a64bc07548298bc314f33cc6e65ce7ae6">More...</a><br /></td></tr>
<tr class="separator:a64bc07548298bc314f33cc6e65ce7ae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad14e72745a22566ea1ab5e873c90b42b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_a_t___cellular_context.html#ad14e72745a22566ea1ab5e873c90b42b">attach_to_network</a> ()</td></tr>
<tr class="memdesc:ad14e72745a22566ea1ab5e873c90b42b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the interface.  <a href="classmbed_1_1_a_t___cellular_context.html#ad14e72745a22566ea1ab5e873c90b42b">More...</a><br /></td></tr>
<tr class="separator:ad14e72745a22566ea1ab5e873c90b42b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af261d2c17032adf48c97653c45f6fffe"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_a_t___cellular_context.html#af261d2c17032adf48c97653c45f6fffe">configure_hup</a> (PinName dcd_pin=NC, bool active_high=false)</td></tr>
<tr class="memdesc:af261d2c17032adf48c97653c45f6fffe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable hang-up detection.  <a href="classmbed_1_1_a_t___cellular_context.html#af261d2c17032adf48c97653c45f6fffe">More...</a><br /></td></tr>
<tr class="separator:af261d2c17032adf48c97653c45f6fffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afed6dc1cd3c93a1960b1e2fe83a05fb5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_cellular_context.html#afed6dc1cd3c93a1960b1e2fe83a05fb5">get_cid</a> () const</td></tr>
<tr class="memdesc:afed6dc1cd3c93a1960b1e2fe83a05fb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the pdp context id associated with this context.  <a href="classmbed_1_1_cellular_context.html#afed6dc1cd3c93a1960b1e2fe83a05fb5">More...</a><br /></td></tr>
<tr class="separator:afed6dc1cd3c93a1960b1e2fe83a05fb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78d88cf0e3037b00e2cbd42ccbb9b2e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_cellular_context.html#a78d88cf0e3037b00e2cbd42ccbb9b2e0">set_authentication_type</a> (AuthenticationType type)</td></tr>
<tr class="memdesc:a78d88cf0e3037b00e2cbd42ccbb9b2e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the authentication type to be used in user authentication if user name and password are defined.  <a href="classmbed_1_1_cellular_context.html#a78d88cf0e3037b00e2cbd42ccbb9b2e0">More...</a><br /></td></tr>
<tr class="separator:a78d88cf0e3037b00e2cbd42ccbb9b2e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab345524a30c3c408d28ac5abc64a24c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_cellular_interface.html">CellularInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cellular_interface.html#ab345524a30c3c408d28ac5abc64a24c8">cellularInterface</a> () final</td></tr>
<tr class="memdesc:ab345524a30c3c408d28ac5abc64a24c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return pointer to a <a class="el" href="class_cellular_interface.html" title="Common interface that is shared between cellular interfaces.">CellularInterface</a>.   <a href="class_cellular_interface.html#ab345524a30c3c408d28ac5abc64a24c8">More...</a><br /></td></tr>
<tr class="separator:ab345524a30c3c408d28ac5abc64a24c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68e37f9f2a19ab17cc5c7baebf6293de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cellular_interface.html#a68e37f9f2a19ab17cc5c7baebf6293de">set_default_parameters</a> () override</td></tr>
<tr class="memdesc:a68e37f9f2a19ab17cc5c7baebf6293de"><td class="mdescLeft">&#160;</td><td class="mdescRight">defined(DOXYGEN_ONLY)  <a href="class_cellular_interface.html#a68e37f9f2a19ab17cc5c7baebf6293de">More...</a><br /></td></tr>
<tr class="separator:a68e37f9f2a19ab17cc5c7baebf6293de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a94b10f0ae842556ebb0e0775b557cb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_interface.html#a4a94b10f0ae842556ebb0e0775b557cb">set_as_default</a> ()</td></tr>
<tr class="memdesc:a4a94b10f0ae842556ebb0e0775b557cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set network interface as default one.  <a href="class_network_interface.html#a4a94b10f0ae842556ebb0e0775b557cb">More...</a><br /></td></tr>
<tr class="separator:a4a94b10f0ae842556ebb0e0775b557cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf0ca1fccad1a27c1e76403676192347"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_interface.html#aaf0ca1fccad1a27c1e76403676192347">get_mac_address</a> ()</td></tr>
<tr class="memdesc:aaf0ca1fccad1a27c1e76403676192347"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the local MAC address.  <a href="class_network_interface.html#aaf0ca1fccad1a27c1e76403676192347">More...</a><br /></td></tr>
<tr class="separator:aaf0ca1fccad1a27c1e76403676192347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a526802de6e27e291d46e3e3e6a396978"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_interface.html#a526802de6e27e291d46e3e3e6a396978">set_mac_address</a> (uint8_t *mac_addr, <a class="el" href="group___net_socket.html#gaeaef3ae1ffcf0d50c66fa2ca37621281">nsapi_size_t</a> addr_len)</td></tr>
<tr class="memdesc:a526802de6e27e291d46e3e3e6a396978"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the MAC address to the interface.  <a href="class_network_interface.html#a526802de6e27e291d46e3e3e6a396978">More...</a><br /></td></tr>
<tr class="separator:a526802de6e27e291d46e3e3e6a396978"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77de8d1afa4b83dd6f560dc39251e1eb"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_interface.html#a77de8d1afa4b83dd6f560dc39251e1eb">get_ipv6_link_local_address</a> (<a class="el" href="class_socket_address.html">SocketAddress</a> *address)</td></tr>
<tr class="memdesc:a77de8d1afa4b83dd6f560dc39251e1eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the IPv6 link local address.  <a href="class_network_interface.html#a77de8d1afa4b83dd6f560dc39251e1eb">More...</a><br /></td></tr>
<tr class="separator:a77de8d1afa4b83dd6f560dc39251e1eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3709144cc9b275c18abe2a414872f140"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_interface.html#a3709144cc9b275c18abe2a414872f140">get_netmask</a> (<a class="el" href="class_socket_address.html">SocketAddress</a> *address)</td></tr>
<tr class="memdesc:a3709144cc9b275c18abe2a414872f140"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the local network mask.  <a href="class_network_interface.html#a3709144cc9b275c18abe2a414872f140">More...</a><br /></td></tr>
<tr class="separator:a3709144cc9b275c18abe2a414872f140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae69c5f0f38bd060ad04d10bc1277ae0e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_interface.html#ae69c5f0f38bd060ad04d10bc1277ae0e">get_gateway</a> (<a class="el" href="class_socket_address.html">SocketAddress</a> *address)</td></tr>
<tr class="memdesc:ae69c5f0f38bd060ad04d10bc1277ae0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the local gateway.  <a href="class_network_interface.html#ae69c5f0f38bd060ad04d10bc1277ae0e">More...</a><br /></td></tr>
<tr class="separator:ae69c5f0f38bd060ad04d10bc1277ae0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaa2847bf9555fb3b9915b31ec906dc7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_interface.html#afaa2847bf9555fb3b9915b31ec906dc7">set_network</a> (const <a class="el" href="class_socket_address.html">SocketAddress</a> &amp;ip_address, const <a class="el" href="class_socket_address.html">SocketAddress</a> &amp;netmask, const <a class="el" href="class_socket_address.html">SocketAddress</a> &amp;gateway)</td></tr>
<tr class="memdesc:afaa2847bf9555fb3b9915b31ec906dc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure this network interface to use a static IP address.  <a href="class_network_interface.html#afaa2847bf9555fb3b9915b31ec906dc7">More...</a><br /></td></tr>
<tr class="separator:afaa2847bf9555fb3b9915b31ec906dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29e2da4ebf1e48a023e9306d66332e8d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_interface.html#a29e2da4ebf1e48a023e9306d66332e8d">set_dhcp</a> (bool dhcp)</td></tr>
<tr class="memdesc:a29e2da4ebf1e48a023e9306d66332e8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable DHCP on connecting the network.  <a href="class_network_interface.html#a29e2da4ebf1e48a023e9306d66332e8d">More...</a><br /></td></tr>
<tr class="separator:a29e2da4ebf1e48a023e9306d66332e8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eeb3e01ec53546b61fd7b823a4980ef"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_interface.html#a5eeb3e01ec53546b61fd7b823a4980ef">gethostbyname</a> (const char *host, <a class="el" href="class_socket_address.html">SocketAddress</a> *address, nsapi_version_t version=<a class="el" href="group___net_socket.html#ggacde826f51019112728ee4ae4e10b8a4fa09ed8714a685448ae2e149c4a142ffe7">NSAPI_UNSPEC</a>, const char *interface_name=NULL)</td></tr>
<tr class="memdesc:a5eeb3e01ec53546b61fd7b823a4980ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate a hostname to an IP address with specific version using network interface name.  <a href="class_network_interface.html#a5eeb3e01ec53546b61fd7b823a4980ef">More...</a><br /></td></tr>
<tr class="separator:a5eeb3e01ec53546b61fd7b823a4980ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87a975b9ef736cef63334895c5770660"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga4dc6e8ec26b364f135278917c3f27c6e">nsapi_value_or_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_interface.html#a87a975b9ef736cef63334895c5770660">getaddrinfo</a> (const char *hostname, <a class="el" href="class_socket_address.html">SocketAddress</a> *hints, <a class="el" href="class_socket_address.html">SocketAddress</a> **res, const char *interface_name=NULL)</td></tr>
<tr class="memdesc:a87a975b9ef736cef63334895c5770660"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate a hostname to the multiple IP addresses with specific version using network interface name.  <a href="class_network_interface.html#a87a975b9ef736cef63334895c5770660">More...</a><br /></td></tr>
<tr class="separator:a87a975b9ef736cef63334895c5770660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab43b64cae1f145615db7f697d34552d7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga4dc6e8ec26b364f135278917c3f27c6e">nsapi_value_or_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_interface.html#ab43b64cae1f145615db7f697d34552d7">gethostbyname_async</a> (const char *host, <a class="el" href="class_network_interface.html#abb962f363d7a7ec29b27844a1e5f7ecc">hostbyname_cb_t</a> <a class="el" href="group__platform___callback.html#ga90e30db9c535d448cd949f7f55bb8f31">callback</a>, nsapi_version_t version=<a class="el" href="group___net_socket.html#ggacde826f51019112728ee4ae4e10b8a4fa09ed8714a685448ae2e149c4a142ffe7">NSAPI_UNSPEC</a>, const char *interface_name=NULL)</td></tr>
<tr class="memdesc:ab43b64cae1f145615db7f697d34552d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate a hostname to an IP address (asynchronous) using network interface name.  <a href="class_network_interface.html#ab43b64cae1f145615db7f697d34552d7">More...</a><br /></td></tr>
<tr class="separator:ab43b64cae1f145615db7f697d34552d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa964732e6c585b596adc760fe95f40f5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga4dc6e8ec26b364f135278917c3f27c6e">nsapi_value_or_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_interface.html#aa964732e6c585b596adc760fe95f40f5">getaddrinfo_async</a> (const char *hostname, <a class="el" href="class_socket_address.html">SocketAddress</a> *hints, <a class="el" href="class_network_interface.html#abb962f363d7a7ec29b27844a1e5f7ecc">hostbyname_cb_t</a> <a class="el" href="group__platform___callback.html#ga90e30db9c535d448cd949f7f55bb8f31">callback</a>, const char *interface_name=NULL)</td></tr>
<tr class="memdesc:aa964732e6c585b596adc760fe95f40f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate a hostname to the multiple IP addresses (asynchronous) using network interface name.  <a href="class_network_interface.html#aa964732e6c585b596adc760fe95f40f5">More...</a><br /></td></tr>
<tr class="separator:aa964732e6c585b596adc760fe95f40f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26000e958701f5b35886fac1757c0bf4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_interface.html#a26000e958701f5b35886fac1757c0bf4">gethostbyname_async_cancel</a> (int id)</td></tr>
<tr class="memdesc:a26000e958701f5b35886fac1757c0bf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel asynchronous hostname translation.  <a href="class_network_interface.html#a26000e958701f5b35886fac1757c0bf4">More...</a><br /></td></tr>
<tr class="separator:a26000e958701f5b35886fac1757c0bf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a260338652be8fba7b1004bc924fdb781"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_interface.html#a260338652be8fba7b1004bc924fdb781">add_dns_server</a> (const <a class="el" href="class_socket_address.html">SocketAddress</a> &amp;address, const char *interface_name)</td></tr>
<tr class="memdesc:a260338652be8fba7b1004bc924fdb781"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a domain name server to list of servers to query.  <a href="class_network_interface.html#a260338652be8fba7b1004bc924fdb781">More...</a><br /></td></tr>
<tr class="separator:a260338652be8fba7b1004bc924fdb781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ccb0f7a5af95e76d0dea335ab866047"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_interface.html#a0ccb0f7a5af95e76d0dea335ab866047">get_dns_server</a> (int index, <a class="el" href="class_socket_address.html">SocketAddress</a> *address, const char *interface_name=NULL)</td></tr>
<tr class="memdesc:a0ccb0f7a5af95e76d0dea335ab866047"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a domain name server from a list of servers to query.  <a href="class_network_interface.html#a0ccb0f7a5af95e76d0dea335ab866047">More...</a><br /></td></tr>
<tr class="separator:a0ccb0f7a5af95e76d0dea335ab866047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab61fc4dcb3f255e327c189325eee1e43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_interface.html#ab61fc4dcb3f255e327c189325eee1e43">add_event_listener</a> (<a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; void(nsapi_event_t, intptr_t)&gt; status_cb)</td></tr>
<tr class="memdesc:ab61fc4dcb3f255e327c189325eee1e43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add event listener for interface.  <a href="class_network_interface.html#ab61fc4dcb3f255e327c189325eee1e43">More...</a><br /></td></tr>
<tr class="separator:ab61fc4dcb3f255e327c189325eee1e43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3fb296eec26bfad22eb94c71c9c502d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_eth_interface.html">EthInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_interface.html#ad3fb296eec26bfad22eb94c71c9c502d">ethInterface</a> ()</td></tr>
<tr class="memdesc:ad3fb296eec26bfad22eb94c71c9c502d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return pointer to an <a class="el" href="class_eth_interface.html" title="Common interface between Ethernet hardware.">EthInterface</a>.  <a href="class_network_interface.html#ad3fb296eec26bfad22eb94c71c9c502d">More...</a><br /></td></tr>
<tr class="separator:ad3fb296eec26bfad22eb94c71c9c502d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09d99efafd15a9d84a77761372e838d5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_wi_fi_interface.html">WiFiInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_interface.html#a09d99efafd15a9d84a77761372e838d5">wifiInterface</a> ()</td></tr>
<tr class="memdesc:a09d99efafd15a9d84a77761372e838d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return pointer to a <a class="el" href="class_wi_fi_interface.html" title="Common interface between Wi-Fi devices.">WiFiInterface</a>.  <a href="class_network_interface.html#a09d99efafd15a9d84a77761372e838d5">More...</a><br /></td></tr>
<tr class="separator:a09d99efafd15a9d84a77761372e838d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65c1b846fba9d9008dafa54b31d4e1a0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_mesh_interface.html">MeshInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_interface.html#a65c1b846fba9d9008dafa54b31d4e1a0">meshInterface</a> ()</td></tr>
<tr class="memdesc:a65c1b846fba9d9008dafa54b31d4e1a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return pointer to a <a class="el" href="class_mesh_interface.html" title="Common interface that is shared between mesh hardware.">MeshInterface</a>.  <a href="class_network_interface.html#a65c1b846fba9d9008dafa54b31d4e1a0">More...</a><br /></td></tr>
<tr class="separator:a65c1b846fba9d9008dafa54b31d4e1a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada0ecf739088a765ebc7fbc4181bb375"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_e_m_a_c_interface.html">EMACInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_interface.html#ada0ecf739088a765ebc7fbc4181bb375">emacInterface</a> ()</td></tr>
<tr class="memdesc:ada0ecf739088a765ebc7fbc4181bb375"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return pointer to an <a class="el" href="class_e_m_a_c_interface.html" title="EMACInterface class Implementation of the NetworkInterface for an EMAC-based driver.">EMACInterface</a>.  <a href="class_network_interface.html#ada0ecf739088a765ebc7fbc4181bb375">More...</a><br /></td></tr>
<tr class="separator:ada0ecf739088a765ebc7fbc4181bb375"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a744ada8fe3585144f7920b0e272dbd42"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmbed_1_1_cellular_context.html">CellularContext</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_cellular_context.html#a744ada8fe3585144f7920b0e272dbd42">get_default_instance</a> ()</td></tr>
<tr class="memdesc:a744ada8fe3585144f7920b0e272dbd42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="class_network_interface.html#a00c2abaa91df1131639e63d980866244" title="Return the default network interface.">NetworkInterface::get_default_instance()</a>  <a href="classmbed_1_1_cellular_context.html#a744ada8fe3585144f7920b0e272dbd42">More...</a><br /></td></tr>
<tr class="separator:a744ada8fe3585144f7920b0e272dbd42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae58809e3aa566234e4eb49e1b0f75f6e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmbed_1_1_cellular_context.html">CellularContext</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_cellular_context.html#ae58809e3aa566234e4eb49e1b0f75f6e">get_default_nonip_instance</a> ()</td></tr>
<tr class="memdesc:ae58809e3aa566234e4eb49e1b0f75f6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instantiates a default Non-IP cellular interface.  <a href="classmbed_1_1_cellular_context.html#ae58809e3aa566234e4eb49e1b0f75f6e">More...</a><br /></td></tr>
<tr class="separator:ae58809e3aa566234e4eb49e1b0f75f6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a86fa27a2d01a4b1c92bf62db8e02b484"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classmbed_1_1_control_plane__netif.html">ControlPlane_netif</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_q_u_e_c_t_e_l___b_g96___cellular_context.html#a86fa27a2d01a4b1c92bf62db8e02b484">get_cp_netif</a> ()</td></tr>
<tr class="memdesc:a86fa27a2d01a4b1c92bf62db8e02b484"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the control plane AT command interface.  <a href="classmbed_1_1_q_u_e_c_t_e_l___b_g96___cellular_context.html#a86fa27a2d01a4b1c92bf62db8e02b484">More...</a><br /></td></tr>
<tr class="separator:a86fa27a2d01a4b1c92bf62db8e02b484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a704c535da2d14b3dd423aefefbe31724"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_q_u_e_c_t_e_l___b_g96___cellular_context.html#a704c535da2d14b3dd423aefefbe31724">do_user_authentication</a> ()</td></tr>
<tr class="memdesc:a704c535da2d14b3dd423aefefbe31724"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does the authentication for the PDP Context if user name and password are provided.  <a href="classmbed_1_1_q_u_e_c_t_e_l___b_g96___cellular_context.html#a704c535da2d14b3dd423aefefbe31724">More...</a><br /></td></tr>
<tr class="separator:a704c535da2d14b3dd423aefefbe31724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70e5d9bd4d3532095686b1a49c46c987"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_a_t___cellular_context.html#a70e5d9bd4d3532095686b1a49c46c987">cellular_callback</a> (nsapi_event_t ev, intptr_t ptr)</td></tr>
<tr class="memdesc:a70e5d9bd4d3532095686b1a49c46c987"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classmbed_1_1_cellular_device.html" title="Class CellularDevice.">CellularDevice</a> calls the status callback function on status changes on the network or <a class="el" href="classmbed_1_1_cellular_device.html" title="Class CellularDevice.">CellularDevice</a>.  <a href="classmbed_1_1_a_t___cellular_context.html#a70e5d9bd4d3532095686b1a49c46c987">More...</a><br /></td></tr>
<tr class="separator:a70e5d9bd4d3532095686b1a49c46c987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6335738beb53501916af0ecb9f468a4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_a_t___cellular_context.html#af6335738beb53501916af0ecb9f468a4">do_connect</a> ()</td></tr>
<tr class="memdesc:af6335738beb53501916af0ecb9f468a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Activates PDP context or in <a class="el" href="class_p_p_p.html">PPP</a> mode opens data channel.  <a href="classmbed_1_1_a_t___cellular_context.html#af6335738beb53501916af0ecb9f468a4">More...</a><br /></td></tr>
<tr class="separator:af6335738beb53501916af0ecb9f468a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b1f3733f48dba33b91fd6fb0b634a17"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_a_t___cellular_context.html#a4b1f3733f48dba33b91fd6fb0b634a17">get_timeout_for_operation</a> (ContextOperation op) const</td></tr>
<tr class="memdesc:a4b1f3733f48dba33b91fd6fb0b634a17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the operation specific timeout.  <a href="classmbed_1_1_a_t___cellular_context.html#a4b1f3733f48dba33b91fd6fb0b634a17">More...</a><br /></td></tr>
<tr class="separator:a4b1f3733f48dba33b91fd6fb0b634a17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7f31bf04d4a45686d6f1f8e05717c2e"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_a_t___cellular_context.html#aa7f31bf04d4a45686d6f1f8e05717c2e">get_nonip_context_type_str</a> ()</td></tr>
<tr class="memdesc:aa7f31bf04d4a45686d6f1f8e05717c2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get string name for NIDD context type.  <a href="classmbed_1_1_a_t___cellular_context.html#aa7f31bf04d4a45686d6f1f8e05717c2e">More...</a><br /></td></tr>
<tr class="separator:aa7f31bf04d4a45686d6f1f8e05717c2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb2efcd8c3bfe4c6fa3b1849970296d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_cellular_context.html#adb2efcd8c3bfe4c6fa3b1849970296d7">cp_data_received</a> ()</td></tr>
<tr class="memdesc:adb2efcd8c3bfe4c6fa3b1849970296d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Triggers control plane's operations needed when control plane data is received, like socket event, for example.  <a href="classmbed_1_1_cellular_context.html#adb2efcd8c3bfe4c6fa3b1849970296d7">More...</a><br /></td></tr>
<tr class="separator:adb2efcd8c3bfe4c6fa3b1849970296d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae484354de4658d0fc6594c8e1967447e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_cellular_context.html#ae484354de4658d0fc6594c8e1967447e">call_network_cb</a> (nsapi_connection_status_t status)</td></tr>
<tr class="memdesc:ae484354de4658d0fc6594c8e1967447e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper method to call callback function if it is provided.  <a href="classmbed_1_1_cellular_context.html#ae484354de4658d0fc6594c8e1967447e">More...</a><br /></td></tr>
<tr class="separator:ae484354de4658d0fc6594c8e1967447e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e2cdbe8fd0856af66be42f9b5d556de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_cellular_context.html#a0e2cdbe8fd0856af66be42f9b5d556de">validate_ip_address</a> ()</td></tr>
<tr class="memdesc:a0e2cdbe8fd0856af66be42f9b5d556de"><td class="mdescLeft">&#160;</td><td class="mdescRight">After we have connected successfully we must check that we have a valid IP address.  <a href="classmbed_1_1_cellular_context.html#a0e2cdbe8fd0856af66be42f9b5d556de">More...</a><br /></td></tr>
<tr class="separator:a0e2cdbe8fd0856af66be42f9b5d556de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a667034ebe0458faad26a819d6c6910ec"><td class="memItemLeft" align="right" valign="top">CellularContext::pdp_type_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_cellular_context.html#a667034ebe0458faad26a819d6c6910ec">string_to_pdp_type</a> (const char *pdp_type)</td></tr>
<tr class="memdesc:a667034ebe0458faad26a819d6c6910ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the given pdp type in char format to enum pdp_type_t.  <a href="classmbed_1_1_cellular_context.html#a667034ebe0458faad26a819d6c6910ec">More...</a><br /></td></tr>
<tr class="separator:a667034ebe0458faad26a819d6c6910ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock">
<p class="definition">Definition at line <a class="el" href="_q_u_e_c_t_e_l___b_g96___cellular_context_8h_source.html#l00024">24</a> of file <a class="el" href="_q_u_e_c_t_e_l___b_g96___cellular_context_8h_source.html">QUECTEL_BG96_CellularContext.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="abb962f363d7a7ec29b27844a1e5f7ecc" name="abb962f363d7a7ec29b27844a1e5f7ecc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb962f363d7a7ec29b27844a1e5f7ecc">&#9670;&#160;</a></span>hostbyname_cb_t</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt;void (<a class="el" href="group___net_socket.html#ga4dc6e8ec26b364f135278917c3f27c6e">nsapi_value_or_error_t</a> result, <a class="el" href="class_socket_address.html">SocketAddress</a> *address)&gt; <a class="el" href="class_network_interface.html#abb962f363d7a7ec29b27844a1e5f7ecc">hostbyname_cb_t</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hostname translation callback (for use with <a class="el" href="class_network_interface.html#ab43b64cae1f145615db7f697d34552d7" title="Translate a hostname to an IP address (asynchronous) using network interface name.">gethostbyname_async()</a>). </p>
<p ><a class="el" href="classmbed_1_1_callback.html" title="Callback class based on template specialization.">Callback</a> will be called after <a class="el" href="class_d_n_s.html" title="Base class for DNS provider.">DNS</a> resolution completes or a failure occurs.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classmbed_1_1_callback.html" title="Callback class based on template specialization.">Callback</a> should not take more than 10ms to execute, otherwise it might prevent underlying thread processing. A portable user of the callback should not make calls to network operations due to stack size limitations. The callback should not perform expensive operations such as socket recv/send calls or blocking operations.</dd></dl>
<p><br  />
 <code>result</code> : Negative error code on failure, or value that represents the number of <a class="el" href="class_d_n_s.html" title="Base class for DNS provider.">DNS</a> records <br  />
 <code>address</code> : On success, destination for the host <a class="el" href="class_socket_address.html" title="SocketAddress class.">SocketAddress</a>. </p>

<p class="definition">Definition at line <a class="el" href="_network_interface_8h_source.html#l00285">285</a> of file <a class="el" href="_network_interface_8h_source.html">NetworkInterface.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a86fa27a2d01a4b1c92bf62db8e02b484" name="a86fa27a2d01a4b1c92bf62db8e02b484"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86fa27a2d01a4b1c92bf62db8e02b484">&#9670;&#160;</a></span>get_cp_netif()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classmbed_1_1_control_plane__netif.html">ControlPlane_netif</a> * get_cp_netif </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the control plane AT command interface. </p>

<p>Reimplemented from <a class="el" href="classmbed_1_1_a_t___cellular_context.html#a86fa27a2d01a4b1c92bf62db8e02b484">AT_CellularContext</a>.</p>

</div>
</div>
<a id="a704c535da2d14b3dd423aefefbe31724" name="a704c535da2d14b3dd423aefefbe31724"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a704c535da2d14b3dd423aefefbe31724">&#9670;&#160;</a></span>do_user_authentication()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> do_user_authentication </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does the authentication for the PDP Context if user name and password are provided. </p>
<p >Can be overridden by the modem target if 3GPP default implementation if not an option</p>
<dl class="section return"><dt>Returns</dt><dd>NSAPI_ERROR_OK if no credentials provided or authentication was successful NSAPI_ERROR_AUTH_FAILURE if authentication failed NSAPI_ERROR_DEVICE_ERROR if communication with the modemm failed </dd></dl>

<p>Reimplemented from <a class="el" href="classmbed_1_1_a_t___cellular_context.html#a704c535da2d14b3dd423aefefbe31724">AT_CellularContext</a>.</p>

</div>
</div>
<a id="a8dc0651d23c76c830d241236e22f0a1b" name="a8dc0651d23c76c830d241236e22f0a1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dc0651d23c76c830d241236e22f0a1b">&#9670;&#160;</a></span>set_blocking()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> set_blocking </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blocking</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set asynchronous operation of <a class="el" href="classmbed_1_1_a_t___cellular_context.html#a6e5fe7426361973a91d288f11c047dfa" title="Attempt to connect to a cellular network.">connect()</a> and <a class="el" href="classmbed_1_1_a_t___cellular_context.html#a280bc602c16c7e591424b9aed3e2b17e" title="Stop the interface.">disconnect()</a> calls. </p>
<p >By default, interfaces are in synchronous mode which means that <a class="el" href="classmbed_1_1_a_t___cellular_context.html#a6e5fe7426361973a91d288f11c047dfa" title="Attempt to connect to a cellular network.">connect()</a> or <a class="el" href="classmbed_1_1_a_t___cellular_context.html#a280bc602c16c7e591424b9aed3e2b17e" title="Stop the interface.">disconnect()</a> blocks until it reach the target state or requested operation fails.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blocking</td><td>Use false to set <a class="el" href="class_network_interface.html" title="Common interface that is shared between network devices.">NetworkInterface</a> in asynchronous mode. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NSAPI_ERROR_OK on success </dd>
<dd>
NSAPI_ERROR_UNSUPPORTED if driver does not support asynchronous mode. </dd>
<dd>
negative error code on failure. </dd></dl>

<p>Implements <a class="el" href="classmbed_1_1_cellular_context.html#ae5f6827ba6e75a5d7653fa23933ba31c">CellularContext</a>.</p>

</div>
</div>
<a id="a2ab48210e24fc7efb4e1cada14c4b57b" name="a2ab48210e24fc7efb4e1cada14c4b57b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ab48210e24fc7efb4e1cada14c4b57b">&#9670;&#160;</a></span>get_ip_address()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> get_ip_address </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_socket_address.html">SocketAddress</a> *&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the local IP address.  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td><a class="el" href="class_socket_address.html" title="SocketAddress class.">SocketAddress</a> representation of the local IP address </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NSAPI_ERROR_OK</td><td>on success </td></tr>
    <tr><td class="paramname">NSAPI_ERROR_UNSUPPORTED</td><td>if this feature is not supported </td></tr>
    <tr><td class="paramname">NSAPI_ERROR_PARAMETER</td><td>if the provided pointer is invalid </td></tr>
    <tr><td class="paramname">NSAPI_ERROR_NO_ADDRESS</td><td>if the address cannot be obtained from stack  </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classmbed_1_1_cellular_context.html#a12d7fc3f5a94cd686c767f7749785b5b">CellularContext</a>.</p>

</div>
</div>
<a id="a241ab3896730d179348de54e86dcd36c" name="a241ab3896730d179348de54e86dcd36c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a241ab3896730d179348de54e86dcd36c">&#9670;&#160;</a></span>get_interface_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual char * get_interface_name </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>interface_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the network interface name. </p>
<dl class="section return"><dt>Returns</dt><dd>Null-terminated representation of the network interface name or null if interface not exists </dd></dl>

<p>Reimplemented from <a class="el" href="class_network_interface.html#a241ab3896730d179348de54e86dcd36c">NetworkInterface</a>.</p>

</div>
</div>
<a id="a27082cfcaab9462699208893d05a70d1" name="a27082cfcaab9462699208893d05a70d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27082cfcaab9462699208893d05a70d1">&#9670;&#160;</a></span>attach()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void attach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; void(nsapi_event_t, intptr_t)&gt;&#160;</td>
          <td class="paramname"><em>status_cb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register callback for status reporting. </p>
<p >The specified status callback function is called on the network, and the cellular device status changes. The parameters on the callback are the event type and event type dependent reason parameter.</p>
<dl class="section remark"><dt>Remarks</dt><dd>deleting CellularDevice/CellularContext in callback is not allowed. </dd>
<dd>
Allocating/adding lots of traces not recommended as callback is called mostly from State machines thread which is now 2048. You can change to main thread for example via EventQueue.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">status_cb</td><td>The callback for status changes. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classmbed_1_1_cellular_context.html#ad145e1c99cb61ba13825ee202b3035c2">CellularContext</a>.</p>

</div>
</div>
<a id="a6e5fe7426361973a91d288f11c047dfa" name="a6e5fe7426361973a91d288f11c047dfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e5fe7426361973a91d288f11c047dfa">&#9670;&#160;</a></span>connect() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> connect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to connect to a cellular network. </p>
<p >If the SIM requires a PIN, and it is invalid or not set, NSAPI_ERROR_AUTH_ERROR is returned.</p>
<dl class="section return"><dt>Returns</dt><dd>NSAPI_ERROR_OK on success, or negative error code on failure. </dd></dl>

<p>Implements <a class="el" href="classmbed_1_1_cellular_context.html#aaf6bf1dfffbe6a5626b7b52eaa542b6e">CellularContext</a>.</p>

</div>
</div>
<a id="a4485df99d674a3e9492f317545f9c730" name="a4485df99d674a3e9492f317545f9c730"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4485df99d674a3e9492f317545f9c730">&#9670;&#160;</a></span>connect() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> connect </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sim_pin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>apn</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>uname</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pwd</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to connect to a cellular network with a PIN and credentials. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sim_pin</td><td>PIN for the SIM card. </td></tr>
    <tr><td class="paramname">apn</td><td>Access point name (optional). </td></tr>
    <tr><td class="paramname">uname</td><td>Username (optional). </td></tr>
    <tr><td class="paramname">pwd</td><td>Password (optional). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NSAPI_ERROR_OK on success, or negative error code on failure. </dd></dl>

<p>Implements <a class="el" href="classmbed_1_1_cellular_context.html#aca1b490692f320fbf39daf0383b458c7">CellularContext</a>.</p>

</div>
</div>
<a id="a280bc602c16c7e591424b9aed3e2b17e" name="a280bc602c16c7e591424b9aed3e2b17e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a280bc602c16c7e591424b9aed3e2b17e">&#9670;&#160;</a></span>disconnect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> disconnect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stop the interface. </p>
<dl class="section return"><dt>Returns</dt><dd>NSAPI_ERROR_OK on success, or error code on failure. </dd></dl>

<p>Implements <a class="el" href="classmbed_1_1_cellular_context.html#afdda3f62c7d73df183ee2d352e8cd146">CellularContext</a>.</p>

</div>
</div>
<a id="a840e46edfb6792d1c588cf95c0387cd6" name="a840e46edfb6792d1c588cf95c0387cd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a840e46edfb6792d1c588cf95c0387cd6">&#9670;&#160;</a></span>get_connection_status()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual nsapi_connection_status_t get_connection_status </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the connection status. </p>
<dl class="section return"><dt>Returns</dt><dd>The connection status (</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="nsapi__types_8h_source.html">nsapi_types.h</a>). </dd></dl>

<p>Reimplemented from <a class="el" href="class_network_interface.html#a840e46edfb6792d1c588cf95c0387cd6">NetworkInterface</a>.</p>

</div>
</div>
<a id="a6809216603111fe387d432f1a349ca18" name="a6809216603111fe387d432f1a349ca18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6809216603111fe387d432f1a349ca18">&#9670;&#160;</a></span>is_connected()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool is_connected </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the connection is currently established. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the cellular module have successfully acquired a carrier and is connected to an external packet data network using <a class="el" href="class_p_p_p.html">PPP</a>, <code>false</code> otherwise. </dd></dl>

<p>Implements <a class="el" href="classmbed_1_1_cellular_context.html#a2c3ca3ca3b22d66e23d49d8a71d3344a">CellularContext</a>.</p>

</div>
</div>
<a id="aa6bdd14db4e305a45c0894c337b436ff" name="aa6bdd14db4e305a45c0894c337b436ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6bdd14db4e305a45c0894c337b436ff">&#9670;&#160;</a></span>set_plmn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void set_plmn </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>plmn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the plmn. </p>
<p >PLMN controls to what network device registers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">plmn</td><td>user to force what network to register. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classmbed_1_1_cellular_context.html#a06e2d77d6b0bcc0b18dc350d52030fb2">CellularContext</a>.</p>

</div>
</div>
<a id="a48e62c440e1c6bb29d0d92a5092a8dda" name="a48e62c440e1c6bb29d0d92a5092a8dda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48e62c440e1c6bb29d0d92a5092a8dda">&#9670;&#160;</a></span>set_sim_pin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void set_sim_pin </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sim_pin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the PIN code for SIM card. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sim_pin</td><td>PIN for the SIM card. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classmbed_1_1_cellular_context.html#a09532a00c37ad9783c51aa3bee7eb239">CellularContext</a>.</p>

</div>
</div>
<a id="a779ee0ee864b5751bc6d9a4915e841c8" name="a779ee0ee864b5751bc6d9a4915e841c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a779ee0ee864b5751bc6d9a4915e841c8">&#9670;&#160;</a></span>set_credentials()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void set_credentials </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>apn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>uname</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pwd</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the cellular network credentials. </p>
<p >Please check documentation of <a class="el" href="classmbed_1_1_a_t___cellular_context.html#a6e5fe7426361973a91d288f11c047dfa" title="Attempt to connect to a cellular network.">connect()</a> for default behavior of APN settings.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">apn</td><td>Access point name. </td></tr>
    <tr><td class="paramname">uname</td><td>Username (optional). </td></tr>
    <tr><td class="paramname">pwd</td><td>Password (optional). </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classmbed_1_1_cellular_context.html#a96881cc053547cae6b07cce19c5dc442">CellularContext</a>.</p>

</div>
</div>
<a id="aa8582bf96adee463f562f2eeba0dbbdc" name="aa8582bf96adee463f562f2eeba0dbbdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8582bf96adee463f562f2eeba0dbbdc">&#9670;&#160;</a></span>get_pdpcontext_params()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> get_pdpcontext_params </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmbed_1_1_cellular_list.html">pdpContextList_t</a> &amp;&#160;</td>
          <td class="paramname"><em>params_list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the relevant information for an active nonsecondary PDP context. </p>
<dl class="section remark"><dt>Remarks</dt><dd>optional params are not updated if not received from network. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params_list</td><td>reference to linked list, which is filled on successful call </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NSAPI_ERROR_OK on success NSAPI_ERROR_NO_MEMORY on memory failure NSAPI_ERROR_DEVICE_ERROR on other failures </dd></dl>

<p>Implements <a class="el" href="classmbed_1_1_cellular_context.html#ae63bacf44c11b95a91a845e492b99d2e">CellularContext</a>.</p>

</div>
</div>
<a id="a800824b23643765f630856bb064a0835" name="a800824b23643765f630856bb064a0835"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a800824b23643765f630856bb064a0835">&#9670;&#160;</a></span>get_rate_control()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> get_rate_control </td>
          <td>(</td>
          <td class="paramtype">CellularContext::RateControlExceptionReports &amp;&#160;</td>
          <td class="paramname"><em>reports</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CellularContext::RateControlUplinkTimeUnit &amp;&#160;</td>
          <td class="paramname"><em>time_unit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>uplink_rate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get APN rate control. </p>
<dl class="section remark"><dt>Remarks</dt><dd>optional params are not updated if not received from network, so use good defaults </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reports</td><td>Additional exception reports at maximum rate reached are allowed to be sent [optional] </td></tr>
    <tr><td class="paramname">time_unit</td><td>Uplink time unit with values 0=unrestricted, 1=minute, 2=hour, 3=day, 4=week [optional] </td></tr>
    <tr><td class="paramname">uplink_rate</td><td>Maximum number of messages per timeUnit [optional] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NSAPI_ERROR_OK on success NSAPI_ERROR_DEVICE_ERROR on case of failure </dd></dl>

<p>Implements <a class="el" href="classmbed_1_1_cellular_context.html#a901ef5833e3d8b1161a9874e91920da3">CellularContext</a>.</p>

</div>
</div>
<a id="af8780d79e018226d7a357804985507fb" name="af8780d79e018226d7a357804985507fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8780d79e018226d7a357804985507fb">&#9670;&#160;</a></span>get_apn_backoff_timer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> get_apn_backoff_timer </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>backoff_timer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get backoff timer value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">backoff_timer</td><td>Backoff timer value associated with PDP APN in seconds </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NSAPI_ERROR_OK on success NSAPI_ERROR_PARAMETER if no access point is set or found when activating context NSAPI_ERROR_DEVICE_ERROR on failure </dd></dl>

<p>Implements <a class="el" href="classmbed_1_1_cellular_context.html#a71dd255d6c641d44f302eebdd95a260f">CellularContext</a>.</p>

</div>
</div>
<a id="aa497e462000128164fb5c331772fd388" name="aa497e462000128164fb5c331772fd388"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa497e462000128164fb5c331772fd388">&#9670;&#160;</a></span>set_device_ready()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> set_device_ready </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start the interface. </p>
<p >Initializes the modem for communication. By default, this API is synchronous. API can be set to asynchronous with method set_blocking(...). In synchronous and asynchronous mode application can get result in from callback which is set with attach(...)</p>
<dl class="section return"><dt>Returns</dt><dd>NSAPI_ERROR_OK on success NSAPI_ERROR_NO_MEMORY on case of memory failure </dd></dl>

<p>Implements <a class="el" href="classmbed_1_1_cellular_context.html#ad5c2ba6e39d27930b416889dd7c2eb73">CellularContext</a>.</p>

</div>
</div>
<a id="ae8a995c0dcea9eefce924cbffc5bb98c" name="ae8a995c0dcea9eefce924cbffc5bb98c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8a995c0dcea9eefce924cbffc5bb98c">&#9670;&#160;</a></span>set_sim_ready()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> set_sim_ready </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start the interface. </p>
<p >Attempts to open the SIM. By default, this API is synchronous. API can be set to asynchronous with method set_blocking(...). In synchronous and asynchronous mode, the application can get result in from callback, which is set with attach(...)</p>
<dl class="section return"><dt>Returns</dt><dd>NSAPI_ERROR_OK on success NSAPI_ERROR_NO_MEMORY on case of memory failure </dd></dl>

<p>Implements <a class="el" href="classmbed_1_1_cellular_context.html#ac629603153bbe15d3922724693af61cf">CellularContext</a>.</p>

</div>
</div>
<a id="a64bc07548298bc314f33cc6e65ce7ae6" name="a64bc07548298bc314f33cc6e65ce7ae6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64bc07548298bc314f33cc6e65ce7ae6">&#9670;&#160;</a></span>register_to_network()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> register_to_network </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start the interface. </p>
<p >Attempts to register the device to cellular network. By default, this API is synchronous. API can be set to asynchronous with method set_blocking(...). In synchronous and asynchronous mode, the application can get result in from callback, which is set with attach(...)</p>
<dl class="section return"><dt>Returns</dt><dd>NSAPI_ERROR_OK on success NSAPI_ERROR_NO_MEMORY on case of memory failure </dd></dl>

<p>Implements <a class="el" href="classmbed_1_1_cellular_context.html#ab35444de5dc547082c4b5c9e48c48226">CellularContext</a>.</p>

</div>
</div>
<a id="ad14e72745a22566ea1ab5e873c90b42b" name="ad14e72745a22566ea1ab5e873c90b42b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad14e72745a22566ea1ab5e873c90b42b">&#9670;&#160;</a></span>attach_to_network()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> attach_to_network </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start the interface. </p>
<p >Attempts to attach the device to cellular network. By default, this API is synchronous. API can be set to asynchronous with method set_blocking(...). In synchronous and asynchronous mode, the application can get result in from callback, which is set with attach(...)</p>
<dl class="section return"><dt>Returns</dt><dd>NSAPI_ERROR_OK on success NSAPI_ERROR_NO_MEMORY on case of memory failure </dd></dl>

<p>Implements <a class="el" href="classmbed_1_1_cellular_context.html#ad7ca4059a56b61eb457de3bfd9e145f2">CellularContext</a>.</p>

</div>
</div>
<a id="af261d2c17032adf48c97653c45f6fffe" name="af261d2c17032adf48c97653c45f6fffe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af261d2c17032adf48c97653c45f6fffe">&#9670;&#160;</a></span>configure_hup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> configure_hup </td>
          <td>(</td>
          <td class="paramtype">PinName&#160;</td>
          <td class="paramname"><em>dcd_pin</em> = <code>NC</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>active_high</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable or disable hang-up detection. </p>
<p >This method will use data carrier detect to be able to detect disconnection much faster in <a class="el" href="class_p_p_p.html">PPP</a> mode.</p>
<p >When in <a class="el" href="class_p_p_p.html">PPP</a> data pump mode, it is helpful if the <a class="el" href="classmbed_1_1_file_handle.html" title="Class FileHandle.">FileHandle</a> will signal hang-up via POLLHUP, e.g., if the DCD line is deasserted on a UART. During command mode, this signaling is not desired.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dcd_pin</td><td>Pin used to set data carrier detect on/off for the given UART. NC if feature is disabled. </td></tr>
    <tr><td class="paramname">active_high</td><td>a boolean set to true if DCD polarity is active low</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NSAPI_ERROR_OK if success, NSAPI_ERROR_UNSUPPORTED if modem does not support this feature </dd></dl>

<p>Implements <a class="el" href="classmbed_1_1_cellular_context.html#a243998a145a2efbbea24a7995aa9c44e">CellularContext</a>.</p>

</div>
</div>
<a id="a70e5d9bd4d3532095686b1a49c46c987" name="a70e5d9bd4d3532095686b1a49c46c987"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70e5d9bd4d3532095686b1a49c46c987">&#9670;&#160;</a></span>cellular_callback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void cellular_callback </td>
          <td>(</td>
          <td class="paramtype">nsapi_event_t&#160;</td>
          <td class="paramname"><em>ev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">intptr_t&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The <a class="el" href="classmbed_1_1_cellular_device.html" title="Class CellularDevice.">CellularDevice</a> calls the status callback function on status changes on the network or <a class="el" href="classmbed_1_1_cellular_device.html" title="Class CellularDevice.">CellularDevice</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ev</td><td>event type </td></tr>
    <tr><td class="paramname">ptr</td><td>event-type dependent reason parameter </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classmbed_1_1_cellular_context.html#a94853ab7a8c3a4b60522c98c7704ce18">CellularContext</a>.</p>

</div>
</div>
<a id="af6335738beb53501916af0ecb9f468a4" name="af6335738beb53501916af0ecb9f468a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6335738beb53501916af0ecb9f468a4">&#9670;&#160;</a></span>do_connect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void do_connect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Activates PDP context or in <a class="el" href="class_p_p_p.html">PPP</a> mode opens data channel. </p>
<p >Can be overridden by the modem target if 3GPP default implementation if not an option </p>

<p>Reimplemented from <a class="el" href="classmbed_1_1_cellular_context.html#af6335738beb53501916af0ecb9f468a4">CellularContext</a>.</p>

<p>Reimplemented in <a class="el" href="classmbed_1_1_u_b_l_o_x___a_t___cellular_context.html#af6335738beb53501916af0ecb9f468a4">UBLOX_AT_CellularContext</a>.</p>

</div>
</div>
<a id="a4b1f3733f48dba33b91fd6fb0b634a17" name="a4b1f3733f48dba33b91fd6fb0b634a17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b1f3733f48dba33b91fd6fb0b634a17">&#9670;&#160;</a></span>get_timeout_for_operation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint32_t get_timeout_for_operation </td>
          <td>(</td>
          <td class="paramtype">ContextOperation&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the operation specific timeout. </p>
<p >Used in synchronous mode when setting the maximum waiting time. Modem specific implementation can override this to provide different timeouts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>current operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>timeout in milliseconds </dd></dl>

</div>
</div>
<a id="aa7f31bf04d4a45686d6f1f8e05717c2e" name="aa7f31bf04d4a45686d6f1f8e05717c2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7f31bf04d4a45686d6f1f8e05717c2e">&#9670;&#160;</a></span>get_nonip_context_type_str()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char * get_nonip_context_type_str </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get string name for NIDD context type. </p>
<dl class="section return"><dt>Returns</dt><dd>NIDD context text, e.g. Non-IP or NONIP </dd></dl>

<p>Implements <a class="el" href="classmbed_1_1_cellular_context.html#a7f89ca47850c5b3057033449743ea618">CellularContext</a>.</p>

<p>Reimplemented in <a class="el" href="classmbed_1_1_q_u_e_c_t_e_l___b_c95___cellular_context.html#aa7f31bf04d4a45686d6f1f8e05717c2e">QUECTEL_BC95_CellularContext</a>, and <a class="el" href="classmbed_1_1_u_b_l_o_x___n2_x_x___cellular_context.html#aa7f31bf04d4a45686d6f1f8e05717c2e">UBLOX_N2XX_CellularContext</a>.</p>

</div>
</div>
<a id="a744ada8fe3585144f7920b0e272dbd42" name="a744ada8fe3585144f7920b0e272dbd42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a744ada8fe3585144f7920b0e272dbd42">&#9670;&#160;</a></span>get_default_instance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmbed_1_1_cellular_context.html">CellularContext</a> * get_default_instance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as <a class="el" href="class_network_interface.html#a00c2abaa91df1131639e63d980866244" title="Return the default network interface.">NetworkInterface::get_default_instance()</a> </p>
<dl class="section note"><dt>Note</dt><dd>not to be used if <a class="el" href="classmbed_1_1_cellular_context.html#ae58809e3aa566234e4eb49e1b0f75f6e" title="Instantiates a default Non-IP cellular interface.">get_default_nonip_instance()</a> was already used </dd></dl>

</div>
</div>
<a id="ae58809e3aa566234e4eb49e1b0f75f6e" name="ae58809e3aa566234e4eb49e1b0f75f6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae58809e3aa566234e4eb49e1b0f75f6e">&#9670;&#160;</a></span>get_default_nonip_instance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmbed_1_1_cellular_context.html">CellularContext</a> * get_default_nonip_instance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Instantiates a default Non-IP cellular interface. </p>
<p >This function creates a new Non-IP PDP context.</p>
<dl class="section note"><dt>Note</dt><dd>not to be used if <a class="el" href="classmbed_1_1_cellular_context.html#a744ada8fe3585144f7920b0e272dbd42" title="Same as NetworkInterface::get_default_instance()">get_default_instance()</a> was already used</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A Non-IP cellular PDP context </dd></dl>

</div>
</div>
<a id="afed6dc1cd3c93a1960b1e2fe83a05fb5" name="afed6dc1cd3c93a1960b1e2fe83a05fb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afed6dc1cd3c93a1960b1e2fe83a05fb5">&#9670;&#160;</a></span>get_cid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int get_cid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the pdp context id associated with this context. </p>
<dl class="section return"><dt>Returns</dt><dd>cid </dd></dl>

</div>
</div>
<a id="a78d88cf0e3037b00e2cbd42ccbb9b2e0" name="a78d88cf0e3037b00e2cbd42ccbb9b2e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78d88cf0e3037b00e2cbd42ccbb9b2e0">&#9670;&#160;</a></span>set_authentication_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void set_authentication_type </td>
          <td>(</td>
          <td class="paramtype">AuthenticationType&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the authentication type to be used in user authentication if user name and password are defined. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>enum AuthenticationType </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adb2efcd8c3bfe4c6fa3b1849970296d7" name="adb2efcd8c3bfe4c6fa3b1849970296d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb2efcd8c3bfe4c6fa3b1849970296d7">&#9670;&#160;</a></span>cp_data_received()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cp_data_received </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Triggers control plane's operations needed when control plane data is received, like socket event, for example. </p>

</div>
</div>
<a id="ae484354de4658d0fc6594c8e1967447e" name="ae484354de4658d0fc6594c8e1967447e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae484354de4658d0fc6594c8e1967447e">&#9670;&#160;</a></span>call_network_cb()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void call_network_cb </td>
          <td>(</td>
          <td class="paramtype">nsapi_connection_status_t&#160;</td>
          <td class="paramname"><em>status</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper method to call callback function if it is provided. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">status</td><td>connection status which is parameter in callback function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0e2cdbe8fd0856af66be42f9b5d556de" name="a0e2cdbe8fd0856af66be42f9b5d556de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e2cdbe8fd0856af66be42f9b5d556de">&#9670;&#160;</a></span>validate_ip_address()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void validate_ip_address </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>After we have connected successfully we must check that we have a valid IP address. </p>
<p >Some modems/networks don't give IP address right after connect so we must poll it for a while. </p>

</div>
</div>
<a id="a667034ebe0458faad26a819d6c6910ec" name="a667034ebe0458faad26a819d6c6910ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a667034ebe0458faad26a819d6c6910ec">&#9670;&#160;</a></span>string_to_pdp_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CellularContext::pdp_type_t string_to_pdp_type </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pdp_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the given pdp type in char format to enum pdp_type_t. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pdp_type</td><td>pdp type in string format </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>converted pdp_type_t enum </dd></dl>

</div>
</div>
<a id="ab345524a30c3c408d28ac5abc64a24c8" name="ab345524a30c3c408d28ac5abc64a24c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab345524a30c3c408d28ac5abc64a24c8">&#9670;&#160;</a></span>cellularInterface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_cellular_interface.html">CellularInterface</a> * cellularInterface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return pointer to a <a class="el" href="class_cellular_interface.html" title="Common interface that is shared between cellular interfaces.">CellularInterface</a>.  </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to requested interface type or NULL if this class doesn't implement the interface.  </dd></dl>

<p>Reimplemented from <a class="el" href="class_network_interface.html#aed55ca6584533439ab78cfd487a2c56f">NetworkInterface</a>.</p>

<p class="definition">Definition at line <a class="el" href="_cellular_interface_8h_source.html#l00103">103</a> of file <a class="el" href="_cellular_interface_8h_source.html">CellularInterface.h</a>.</p>

</div>
</div>
<a id="a68e37f9f2a19ab17cc5c7baebf6293de" name="a68e37f9f2a19ab17cc5c7baebf6293de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68e37f9f2a19ab17cc5c7baebf6293de">&#9670;&#160;</a></span>set_default_parameters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void set_default_parameters </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>defined(DOXYGEN_ONLY) </p>
<p >Set default parameters on a cellular interface.</p>
<p >A cellular interface instantiated directly or using <a class="el" href="class_cellular_interface.html#ac9b9428fe1f7c68174b0f4465ae699b7" title="Get the default cellular interface.">CellularInterface::get_default_instance()</a> is initially unconfigured. This call can be used to set the default parameters that would have been set if the interface had been requested using <a class="el" href="class_network_interface.html#a00c2abaa91df1131639e63d980866244" title="Return the default network interface.">NetworkInterface::get_default_instance()</a> (see nsapi JSON configuration). </p>

<p>Reimplemented from <a class="el" href="class_network_interface.html#a123d2c4ef90c33aec33471ac040049c1">NetworkInterface</a>.</p>

</div>
</div>
<a id="a4a94b10f0ae842556ebb0e0775b557cb" name="a4a94b10f0ae842556ebb0e0775b557cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a94b10f0ae842556ebb0e0775b557cb">&#9670;&#160;</a></span>set_as_default()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void set_as_default </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set network interface as default one. </p>

<p>Reimplemented in <a class="el" href="class_e_m_a_c_interface.html#a344c00309ca7046be3644d12458d0e59">EMACInterface</a>, <a class="el" href="class_l3_i_p_interface.html#a344c00309ca7046be3644d12458d0e59">L3IPInterface</a>, and <a class="el" href="class_p_p_p_interface.html#a344c00309ca7046be3644d12458d0e59">PPPInterface</a>.</p>

</div>
</div>
<a id="aaf0ca1fccad1a27c1e76403676192347" name="aaf0ca1fccad1a27c1e76403676192347"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf0ca1fccad1a27c1e76403676192347">&#9670;&#160;</a></span>get_mac_address()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char * get_mac_address </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the local MAC address. </p>
<p >Provided MAC address is intended for info or debug purposes and may be not provided if the underlying network interface does not provide a MAC address.</p>
<dl class="section return"><dt>Returns</dt><dd>Null-terminated representation of the local MAC address or null if no MAC address is available. </dd></dl>

<p>Reimplemented in <a class="el" href="class_interface_nanostack.html#a1d3eff5846155587cbfbc854c1203d16">InterfaceNanostack</a>, and <a class="el" href="class_e_m_a_c_interface.html#a1d3eff5846155587cbfbc854c1203d16">EMACInterface</a>.</p>

</div>
</div>
<a id="a526802de6e27e291d46e3e3e6a396978" name="a526802de6e27e291d46e3e3e6a396978"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a526802de6e27e291d46e3e3e6a396978">&#9670;&#160;</a></span>set_mac_address()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> set_mac_address </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>mac_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___net_socket.html#gaeaef3ae1ffcf0d50c66fa2ca37621281">nsapi_size_t</a>&#160;</td>
          <td class="paramname"><em>addr_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the MAC address to the interface. </p>
<p >Set the provided MAC address on the network interface. The address must be unique globally. The address must be set before calling the interface <a class="el" href="classmbed_1_1_a_t___cellular_context.html#a6e5fe7426361973a91d288f11c047dfa" title="Attempt to connect to a cellular network.">connect()</a> method.</p>
<p >Not all interfaces are supporting MAC address set and an error is not returned for this method call. Verify the changed MAC address by checking packet captures from the used network interface.</p>
<p >6-byte EUI-48 MAC addresses are used for Ethernet while Mesh interface is using 8-byte EUI-64 address.</p>
<p >More information about obtaining MAC address can be found from: <a href="https://standards.ieee.org/products-services/regauth/index.html">https://standards.ieee.org/products-services/regauth/index.html</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mac_addr</td><td>Buffer containing the MAC address in hexadecimal format. </td></tr>
    <tr><td class="paramname">addr_len</td><td>Length of provided buffer in bytes (6 or 8) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NSAPI_ERROR_OK</td><td>on success </td></tr>
    <tr><td class="paramname">NSAPI_ERROR_UNSUPPORTED</td><td>if this feature is not supported </td></tr>
    <tr><td class="paramname">NSAPI_ERROR_PARAMETER</td><td>if address is not valid </td></tr>
    <tr><td class="paramname">NSAPI_ERROR_BUSY</td><td>if address can't be set. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_interface_nanostack.html#a1818a2ba00bb112906e17a78c79a8c3c">InterfaceNanostack</a>, and <a class="el" href="class_e_m_a_c_interface.html#a1818a2ba00bb112906e17a78c79a8c3c">EMACInterface</a>.</p>

</div>
</div>
<a id="a77de8d1afa4b83dd6f560dc39251e1eb" name="a77de8d1afa4b83dd6f560dc39251e1eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77de8d1afa4b83dd6f560dc39251e1eb">&#9670;&#160;</a></span>get_ipv6_link_local_address()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> get_ipv6_link_local_address </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_socket_address.html">SocketAddress</a> *&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the IPv6 link local address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td><a class="el" href="class_socket_address.html" title="SocketAddress class.">SocketAddress</a> representation of the link local IPv6 address </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NSAPI_ERROR_OK</td><td>on success </td></tr>
    <tr><td class="paramname">NSAPI_ERROR_UNSUPPORTED</td><td>if this feature is not supported </td></tr>
    <tr><td class="paramname">NSAPI_ERROR_PARAMETER</td><td>if the provided pointer is invalid </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_e_m_a_c_interface.html#a26e81e7450d1d68c4608209f565370cc">EMACInterface</a>.</p>

</div>
</div>
<a id="a3709144cc9b275c18abe2a414872f140" name="a3709144cc9b275c18abe2a414872f140"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3709144cc9b275c18abe2a414872f140">&#9670;&#160;</a></span>get_netmask()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> get_netmask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_socket_address.html">SocketAddress</a> *&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the local network mask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td><a class="el" href="class_socket_address.html" title="SocketAddress class.">SocketAddress</a> representation of netmask </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NSAPI_ERROR_OK</td><td>on success </td></tr>
    <tr><td class="paramname">NSAPI_ERROR_UNSUPPORTED</td><td>if this feature is not supported </td></tr>
    <tr><td class="paramname">NSAPI_ERROR_PARAMETER</td><td>if the provided pointer is invalid </td></tr>
    <tr><td class="paramname">NSAPI_ERROR_NO_ADDRESS</td><td>if the address cannot be obtained from stack </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_e_m_a_c_interface.html#adbcda6c56b87278605872eae2f992fdc">EMACInterface</a>, <a class="el" href="class_l3_i_p_interface.html#adbcda6c56b87278605872eae2f992fdc">L3IPInterface</a>, and <a class="el" href="class_p_p_p_interface.html#adbcda6c56b87278605872eae2f992fdc">PPPInterface</a>.</p>

</div>
</div>
<a id="ae69c5f0f38bd060ad04d10bc1277ae0e" name="ae69c5f0f38bd060ad04d10bc1277ae0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae69c5f0f38bd060ad04d10bc1277ae0e">&#9670;&#160;</a></span>get_gateway()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> get_gateway </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_socket_address.html">SocketAddress</a> *&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the local gateway. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td><a class="el" href="class_socket_address.html" title="SocketAddress class.">SocketAddress</a> representation of gateway address </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NSAPI_ERROR_OK</td><td>on success </td></tr>
    <tr><td class="paramname">NSAPI_ERROR_UNSUPPORTED</td><td>if this feature is not supported </td></tr>
    <tr><td class="paramname">NSAPI_ERROR_PARAMETER</td><td>if the provided pointer is invalid </td></tr>
    <tr><td class="paramname">NSAPI_ERROR_NO_ADDRESS</td><td>if the address cannot be obtained from stack </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classmbed_1_1_u_b_l_o_x___a_t___cellular_context.html#a5bd6a10f70055c0d531f980f66e59b21">UBLOX_AT_CellularContext</a>, <a class="el" href="class_e_m_a_c_interface.html#a614b733210566ac70c1b0dc7fa95b8e9">EMACInterface</a>, <a class="el" href="class_l3_i_p_interface.html#a614b733210566ac70c1b0dc7fa95b8e9">L3IPInterface</a>, and <a class="el" href="class_p_p_p_interface.html#a614b733210566ac70c1b0dc7fa95b8e9">PPPInterface</a>.</p>

</div>
</div>
<a id="afaa2847bf9555fb3b9915b31ec906dc7" name="afaa2847bf9555fb3b9915b31ec906dc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaa2847bf9555fb3b9915b31ec906dc7">&#9670;&#160;</a></span>set_network()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> set_network </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_socket_address.html">SocketAddress</a> &amp;&#160;</td>
          <td class="paramname"><em>ip_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_socket_address.html">SocketAddress</a> &amp;&#160;</td>
          <td class="paramname"><em>netmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_socket_address.html">SocketAddress</a> &amp;&#160;</td>
          <td class="paramname"><em>gateway</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Configure this network interface to use a static IP address. </p>
<p >Implicitly disables DHCP, which can be enabled in set_dhcp. Requires that the network is disconnected.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ip_address</td><td><a class="el" href="class_socket_address.html" title="SocketAddress class.">SocketAddress</a> object containing the local IP address </td></tr>
    <tr><td class="paramname">netmask</td><td><a class="el" href="class_socket_address.html" title="SocketAddress class.">SocketAddress</a> object containing the local network mask </td></tr>
    <tr><td class="paramname">gateway</td><td><a class="el" href="class_socket_address.html" title="SocketAddress class.">SocketAddress</a> object containing the local gateway </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NSAPI_ERROR_OK</td><td>on success </td></tr>
    <tr><td class="paramname">NSAPI_ERROR_UNSUPPORTED</td><td>if this function is unsupported </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_e_m_a_c_interface.html#a9919ef603c0c526ec73722610bd877ca">EMACInterface</a>, <a class="el" href="class_l3_i_p_interface.html#a9919ef603c0c526ec73722610bd877ca">L3IPInterface</a>, and <a class="el" href="class_p_p_p_interface.html#a9919ef603c0c526ec73722610bd877ca">PPPInterface</a>.</p>

</div>
</div>
<a id="a29e2da4ebf1e48a023e9306d66332e8d" name="a29e2da4ebf1e48a023e9306d66332e8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29e2da4ebf1e48a023e9306d66332e8d">&#9670;&#160;</a></span>set_dhcp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> set_dhcp </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dhcp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable or disable DHCP on connecting the network. </p>
<p >Enabled by default unless a static IP address has been assigned. Requires that the network is disconnected.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dhcp</td><td>True to enable DHCP. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NSAPI_ERROR_OK</td><td>on success. </td></tr>
    <tr><td class="paramname">NSAPI_ERROR_UNSUPPORTED</td><td>if operation is not supported. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_e_m_a_c_interface.html#a8e39d3de385c6227267f23666ea86eb3">EMACInterface</a>, and <a class="el" href="class_l3_i_p_interface.html#a8e39d3de385c6227267f23666ea86eb3">L3IPInterface</a>.</p>

</div>
</div>
<a id="a5eeb3e01ec53546b61fd7b823a4980ef" name="a5eeb3e01ec53546b61fd7b823a4980ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eeb3e01ec53546b61fd7b823a4980ef">&#9670;&#160;</a></span>gethostbyname()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> gethostbyname </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_socket_address.html">SocketAddress</a> *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nsapi_version_t&#160;</td>
          <td class="paramname"><em>version</em> = <code><a class="el" href="group___net_socket.html#ggacde826f51019112728ee4ae4e10b8a4fa09ed8714a685448ae2e149c4a142ffe7">NSAPI_UNSPEC</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>interface_name</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Translate a hostname to an IP address with specific version using network interface name. </p>
<p >The hostname may be either a domain name or an IP address. If the hostname is an IP address, no network transactions will be performed.</p>
<p >If no stack-specific <a class="el" href="class_d_n_s.html" title="Base class for DNS provider.">DNS</a> resolution is provided, the hostname will be resolve using a UDP socket on the stack.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>Hostname to resolve. </td></tr>
    <tr><td class="paramname">address</td><td>Pointer to a <a class="el" href="class_socket_address.html" title="SocketAddress class.">SocketAddress</a> to store the result. </td></tr>
    <tr><td class="paramname">version</td><td>IP version of address to resolve, NSAPI_UNSPEC indicates version is chosen by the stack (defaults to NSAPI_UNSPEC). </td></tr>
    <tr><td class="paramname">interface_name</td><td>Network interface name </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NSAPI_ERROR_OK</td><td>on success </td></tr>
    <tr><td class="paramname">int</td><td>Negative error code on failure. See <a class="el" href="class_network_stack.html#a5eeb3e01ec53546b61fd7b823a4980ef">NetworkStack::gethostbyname</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_d_n_s.html#ae247aa841e5b519a5e47305ee00bacd2">DNS</a>.</p>

</div>
</div>
<a id="a87a975b9ef736cef63334895c5770660" name="a87a975b9ef736cef63334895c5770660"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87a975b9ef736cef63334895c5770660">&#9670;&#160;</a></span>getaddrinfo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga4dc6e8ec26b364f135278917c3f27c6e">nsapi_value_or_error_t</a> getaddrinfo </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>hostname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_socket_address.html">SocketAddress</a> *&#160;</td>
          <td class="paramname"><em>hints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_socket_address.html">SocketAddress</a> **&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>interface_name</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Translate a hostname to the multiple IP addresses with specific version using network interface name. </p>
<p >The hostname may be either a domain name or an IP address. If the hostname is an IP address, no network transactions will be performed.</p>
<p >If no stack-specific <a class="el" href="class_d_n_s.html" title="Base class for DNS provider.">DNS</a> resolution is provided, the hostname will be resolve using a UDP socket on the stack.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hostname</td><td>Hostname to resolve. </td></tr>
    <tr><td class="paramname">hints</td><td>Pointer to a <a class="el" href="class_socket_address.html" title="SocketAddress class.">SocketAddress</a> with query parameters. </td></tr>
    <tr><td class="paramname">res</td><td>Pointer to a <a class="el" href="class_socket_address.html" title="SocketAddress class.">SocketAddress</a> array to store the result.. </td></tr>
    <tr><td class="paramname">interface_name</td><td>Network interface name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of results on success, negative error code on failure. </dd></dl>

<p>Implements <a class="el" href="class_d_n_s.html#a4e2299044fa2bbb37717a7661bb608f7">DNS</a>.</p>

</div>
</div>
<a id="ab43b64cae1f145615db7f697d34552d7" name="ab43b64cae1f145615db7f697d34552d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab43b64cae1f145615db7f697d34552d7">&#9670;&#160;</a></span>gethostbyname_async()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga4dc6e8ec26b364f135278917c3f27c6e">nsapi_value_or_error_t</a> gethostbyname_async </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_network_interface.html#abb962f363d7a7ec29b27844a1e5f7ecc">hostbyname_cb_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nsapi_version_t&#160;</td>
          <td class="paramname"><em>version</em> = <code><a class="el" href="group___net_socket.html#ggacde826f51019112728ee4ae4e10b8a4fa09ed8714a685448ae2e149c4a142ffe7">NSAPI_UNSPEC</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>interface_name</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Translate a hostname to an IP address (asynchronous) using network interface name. </p>
<p >The hostname may be either a domain name or a dotted IP address. If the hostname is an IP address, no network transactions will be performed.</p>
<p >If no stack-specific <a class="el" href="class_d_n_s.html" title="Base class for DNS provider.">DNS</a> resolution is provided, the hostname will be resolve using a UDP socket on the stack.</p>
<p >Call is non-blocking. Result of the <a class="el" href="class_d_n_s.html" title="Base class for DNS provider.">DNS</a> operation is returned by the callback. If this function returns failure, callback will not be called. In case result is success (IP address was found from <a class="el" href="class_d_n_s.html" title="Base class for DNS provider.">DNS</a> cache), callback will be called before function returns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>Hostname to resolve. </td></tr>
    <tr><td class="paramname">callback</td><td><a class="el" href="classmbed_1_1_callback.html" title="Callback class based on template specialization.">Callback</a> that is called for result. </td></tr>
    <tr><td class="paramname">version</td><td>IP version of address to resolve, NSAPI_UNSPEC indicates version is chosen by the stack (defaults to NSAPI_UNSPEC). </td></tr>
    <tr><td class="paramname">interface_name</td><td>Network interface name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on immediate success, negative error code on immediate failure or a positive unique id that represents the hostname translation operation and can be passed to cancel. </dd></dl>

<p>Implements <a class="el" href="class_d_n_s.html#aede5e7d96c7b2141f60a9fefec11e462">DNS</a>.</p>

</div>
</div>
<a id="aa964732e6c585b596adc760fe95f40f5" name="aa964732e6c585b596adc760fe95f40f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa964732e6c585b596adc760fe95f40f5">&#9670;&#160;</a></span>getaddrinfo_async()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga4dc6e8ec26b364f135278917c3f27c6e">nsapi_value_or_error_t</a> getaddrinfo_async </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>hostname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_socket_address.html">SocketAddress</a> *&#160;</td>
          <td class="paramname"><em>hints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_network_interface.html#abb962f363d7a7ec29b27844a1e5f7ecc">hostbyname_cb_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>interface_name</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Translate a hostname to the multiple IP addresses (asynchronous) using network interface name. </p>
<p >The hostname may be either a domain name or a dotted IP address. If the hostname is an IP address, no network transactions will be performed.</p>
<p >If no stack-specific <a class="el" href="class_d_n_s.html" title="Base class for DNS provider.">DNS</a> resolution is provided, the hostname will be resolve using a UDP socket on the stack.</p>
<p >Call is non-blocking. Result of the <a class="el" href="class_d_n_s.html" title="Base class for DNS provider.">DNS</a> operation is returned by the callback. If this function returns failure, callback will not be called. In case result is success (IP address was found from <a class="el" href="class_d_n_s.html" title="Base class for DNS provider.">DNS</a> cache), callback will be called before function returns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hostname</td><td>Hostname to resolve. </td></tr>
    <tr><td class="paramname">hints</td><td>Pointer to a <a class="el" href="class_socket_address.html" title="SocketAddress class.">SocketAddress</a> with query parameters. </td></tr>
    <tr><td class="paramname">callback</td><td><a class="el" href="classmbed_1_1_callback.html" title="Callback class based on template specialization.">Callback</a> that is called for result. </td></tr>
    <tr><td class="paramname">interface_name</td><td>Network interface name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on immediate success, negative error code on immediate failure or a positive unique id that represents the hostname translation operation and can be passed to cancel. </dd></dl>

<p>Implements <a class="el" href="class_d_n_s.html#afd29392442faa47f202cd69ede31dd03">DNS</a>.</p>

</div>
</div>
<a id="a26000e958701f5b35886fac1757c0bf4" name="a26000e958701f5b35886fac1757c0bf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26000e958701f5b35886fac1757c0bf4">&#9670;&#160;</a></span>gethostbyname_async_cancel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> gethostbyname_async_cancel </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cancel asynchronous hostname translation. </p>
<p >When translation is cancelled, callback will not be called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Unique id of the hostname translation operation (returned by gethostbyname_async) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NSAPI_ERROR_OK on success, negative error code on failure. </dd></dl>

<p>Implements <a class="el" href="class_d_n_s.html#a3ba06c19476ec03988c7cd7807823d63">DNS</a>.</p>

</div>
</div>
<a id="a260338652be8fba7b1004bc924fdb781" name="a260338652be8fba7b1004bc924fdb781"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a260338652be8fba7b1004bc924fdb781">&#9670;&#160;</a></span>add_dns_server()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> add_dns_server </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_socket_address.html">SocketAddress</a> &amp;&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>interface_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a domain name server to list of servers to query. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>Address for the dns host. </td></tr>
    <tr><td class="paramname">interface_name</td><td>Network interface name. Currently unused, the server is added for all interfaces. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NSAPI_ERROR_OK on success, negative error code on failure. </dd></dl>

<p>Implements <a class="el" href="class_d_n_s.html#ad222683619bf0a9e32e0499e25cd3a98">DNS</a>.</p>

</div>
</div>
<a id="a0ccb0f7a5af95e76d0dea335ab866047" name="a0ccb0f7a5af95e76d0dea335ab866047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ccb0f7a5af95e76d0dea335ab866047">&#9670;&#160;</a></span>get_dns_server()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> get_dns_server </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_socket_address.html">SocketAddress</a> *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>interface_name</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a domain name server from a list of servers to query. </p>
<p >Returns a <a class="el" href="class_d_n_s.html" title="Base class for DNS provider.">DNS</a> server address for a index. If returns error no more <a class="el" href="class_d_n_s.html" title="Base class for DNS provider.">DNS</a> servers to read.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index of the <a class="el" href="class_d_n_s.html" title="Base class for DNS provider.">DNS</a> server, starts from zero </td></tr>
    <tr><td class="paramname">address</td><td>Destination for the host address </td></tr>
    <tr><td class="paramname">interface_name</td><td>Network interface name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NSAPI_ERROR_OK on success, negative error code on failure </dd></dl>

</div>
</div>
<a id="ab61fc4dcb3f255e327c189325eee1e43" name="ab61fc4dcb3f255e327c189325eee1e43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab61fc4dcb3f255e327c189325eee1e43">&#9670;&#160;</a></span>add_event_listener()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void add_event_listener </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; void(nsapi_event_t, intptr_t)&gt;&#160;</td>
          <td class="paramname"><em>status_cb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add event listener for interface. </p>
<p >This API allows multiple callback to be registered for a single interface. When first called, internal list of event handlers are created and registered to interface through <a class="el" href="classmbed_1_1_a_t___cellular_context.html#a27082cfcaab9462699208893d05a70d1" title="Register callback for status reporting.">attach()</a> API.</p>
<p >Application may only use <a class="el" href="classmbed_1_1_a_t___cellular_context.html#a27082cfcaab9462699208893d05a70d1" title="Register callback for status reporting.">attach()</a> or <a class="el" href="class_network_interface.html#ab61fc4dcb3f255e327c189325eee1e43" title="Add event listener for interface.">add_event_listener()</a> interface. Mixing usage of both leads to undefined behavior.</p>
<dl class="section warning"><dt>Warning</dt><dd>This version of the function does not use the <code>std::nothrow</code> feature. Subsequently, the function may fail to allocate memory and cause a system error. To use the new version with the changes, set "nsapi.add-event-listener-return-change": 1 in the target overrides section in your mbed_app.json file.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">status_cb</td><td>The callback for status changes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad3fb296eec26bfad22eb94c71c9c502d" name="ad3fb296eec26bfad22eb94c71c9c502d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3fb296eec26bfad22eb94c71c9c502d">&#9670;&#160;</a></span>ethInterface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_eth_interface.html">EthInterface</a> * ethInterface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return pointer to an <a class="el" href="class_eth_interface.html" title="Common interface between Ethernet hardware.">EthInterface</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to requested interface type or NULL if this class doesn't implement the interface. </dd></dl>

<p>Reimplemented in <a class="el" href="class_eth_interface.html#a66f1410ed4de66447d3364907abb9094">EthInterface</a>.</p>

<p class="definition">Definition at line <a class="el" href="_network_interface_8h_source.html#l00445">445</a> of file <a class="el" href="_network_interface_8h_source.html">NetworkInterface.h</a>.</p>

</div>
</div>
<a id="a09d99efafd15a9d84a77761372e838d5" name="a09d99efafd15a9d84a77761372e838d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09d99efafd15a9d84a77761372e838d5">&#9670;&#160;</a></span>wifiInterface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_wi_fi_interface.html">WiFiInterface</a> * wifiInterface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return pointer to a <a class="el" href="class_wi_fi_interface.html" title="Common interface between Wi-Fi devices.">WiFiInterface</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to requested interface type or NULL if this class doesn't implement the interface. </dd></dl>

<p>Reimplemented in <a class="el" href="class_wi_fi_interface.html#ac47da289e164960eaeea7f2a4d155003">WiFiInterface</a>.</p>

<p class="definition">Definition at line <a class="el" href="_network_interface_8h_source.html#l00453">453</a> of file <a class="el" href="_network_interface_8h_source.html">NetworkInterface.h</a>.</p>

</div>
</div>
<a id="a65c1b846fba9d9008dafa54b31d4e1a0" name="a65c1b846fba9d9008dafa54b31d4e1a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65c1b846fba9d9008dafa54b31d4e1a0">&#9670;&#160;</a></span>meshInterface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_mesh_interface.html">MeshInterface</a> * meshInterface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return pointer to a <a class="el" href="class_mesh_interface.html" title="Common interface that is shared between mesh hardware.">MeshInterface</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to requested interface type or NULL if this class doesn't implement the interface. </dd></dl>

<p>Reimplemented in <a class="el" href="class_mesh_interface.html#a1a5135a4e8f7628515bae7599da85269">MeshInterface</a>.</p>

<p class="definition">Definition at line <a class="el" href="_network_interface_8h_source.html#l00461">461</a> of file <a class="el" href="_network_interface_8h_source.html">NetworkInterface.h</a>.</p>

</div>
</div>
<a id="ada0ecf739088a765ebc7fbc4181bb375" name="ada0ecf739088a765ebc7fbc4181bb375"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada0ecf739088a765ebc7fbc4181bb375">&#9670;&#160;</a></span>emacInterface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_e_m_a_c_interface.html">EMACInterface</a> * emacInterface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return pointer to an <a class="el" href="class_e_m_a_c_interface.html" title="EMACInterface class Implementation of the NetworkInterface for an EMAC-based driver.">EMACInterface</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to requested interface type or NULL if this class doesn't implement the interface. </dd></dl>

<p>Reimplemented in <a class="el" href="class_e_m_a_c_interface.html#a19fdf1bbd64f27f8189ee586d1f5df24">EMACInterface</a>.</p>

<p class="definition">Definition at line <a class="el" href="_network_interface_8h_source.html#l00469">469</a> of file <a class="el" href="_network_interface_8h_source.html">NetworkInterface.h</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>mbed</b></li><li class="navelem"><a class="el" href="classmbed_1_1_q_u_e_c_t_e_l___b_g96___cellular_context.html">QUECTEL_BG96_CellularContext</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>

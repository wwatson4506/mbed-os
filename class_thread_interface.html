<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Mbed OS Reference: ThreadInterface Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="mbed-ce_55x55.png"/></td>
  <td id="projectalign">
   <div id="projectname">Mbed OS Reference
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('class_thread_interface.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a>  </div>
  <div class="headertitle"><div class="title">ThreadInterface Class Reference<span class="mlabels"><span class="mlabel">final</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>Thread mesh network interface class.  
 <a href="class_thread_interface.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_thread_interface_8h_source.html">ThreadInterface.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ThreadInterface:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_thread_interface.png" usemap="#ThreadInterface_map" alt=""/>
  <map id="ThreadInterface_map" name="ThreadInterface_map">
<area href="class_mesh_interface_nanostack.html" alt="MeshInterfaceNanostack" shape="rect" coords="263,168,516,192"/>
<area href="class_interface_nanostack.html" alt="InterfaceNanostack" shape="rect" coords="0,112,253,136"/>
<area href="class_mesh_interface.html" title="Common interface that is shared between mesh hardware." alt="MeshInterface" shape="rect" coords="263,112,516,136"/>
<area href="classmbed_1_1_non_copyable.html" alt="NonCopyable&lt; MeshInterfaceNanostack &gt;" shape="rect" coords="526,112,779,136"/>
<area href="class_network_interface.html" title="Common interface that is shared between network devices." alt="NetworkInterface" shape="rect" coords="0,56,253,80"/>
<area href="class_network_interface.html" title="Common interface that is shared between network devices." alt="NetworkInterface" shape="rect" coords="263,56,516,80"/>
<area href="class_d_n_s.html" title="Base class for DNS provider." alt="DNS" shape="rect" coords="0,0,253,24"/>
<area href="class_d_n_s.html" title="Base class for DNS provider." alt="DNS" shape="rect" coords="263,0,516,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:abb962f363d7a7ec29b27844a1e5f7ecc"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; void(<a class="el" href="group___net_socket.html#ga4dc6e8ec26b364f135278917c3f27c6e">nsapi_value_or_error_t</a> result, <a class="el" href="class_socket_address.html">SocketAddress</a> *address)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_interface.html#abb962f363d7a7ec29b27844a1e5f7ecc">hostbyname_cb_t</a></td></tr>
<tr class="memdesc:abb962f363d7a7ec29b27844a1e5f7ecc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hostname translation callback (for use with <a class="el" href="class_network_interface.html#ab43b64cae1f145615db7f697d34552d7" title="Translate a hostname to an IP address (asynchronous) using network interface name.">gethostbyname_async()</a>).  <a href="class_network_interface.html#abb962f363d7a7ec29b27844a1e5f7ecc">More...</a><br /></td></tr>
<tr class="separator:abb962f363d7a7ec29b27844a1e5f7ecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a74bda7fdb29f8cd964e69046536433ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread_interface.html#a74bda7fdb29f8cd964e69046536433ae">device_eui64_set</a> (const uint8_t *eui64)</td></tr>
<tr class="memdesc:a74bda7fdb29f8cd964e69046536433ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the eui64 for the device configuration.  <a href="class_thread_interface.html#a74bda7fdb29f8cd964e69046536433ae">More...</a><br /></td></tr>
<tr class="separator:a74bda7fdb29f8cd964e69046536433ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c804e890fd9ceb65b966c9bfc62e2be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread_interface.html#a3c804e890fd9ceb65b966c9bfc62e2be">device_eui64_get</a> (uint8_t *eui64)</td></tr>
<tr class="memdesc:a3c804e890fd9ceb65b966c9bfc62e2be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the eui64 from the device configuration.  <a href="class_thread_interface.html#a3c804e890fd9ceb65b966c9bfc62e2be">More...</a><br /></td></tr>
<tr class="separator:a3c804e890fd9ceb65b966c9bfc62e2be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4a27cd30598ca101e2e49bce9f1b79d"><td class="memItemLeft" align="right" valign="top">mesh_error_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread_interface.html#aa4a27cd30598ca101e2e49bce9f1b79d">device_pskd_set</a> (const char *pskd)</td></tr>
<tr class="memdesc:aa4a27cd30598ca101e2e49bce9f1b79d"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets the PSKd for the device configuration.  <a href="class_thread_interface.html#aa4a27cd30598ca101e2e49bce9f1b79d">More...</a><br /></td></tr>
<tr class="separator:aa4a27cd30598ca101e2e49bce9f1b79d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4c9521c599e6a5c5a15a555df8062ca"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread_interface.html#ac4c9521c599e6a5c5a15a555df8062ca">MeshInterfaceNanostack</a> ()=default</td></tr>
<tr class="memdesc:ac4c9521c599e6a5c5a15a555df8062ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inherit <a class="el" href="class_mesh_interface_nanostack.html">MeshInterfaceNanostack</a> constructors.  <a href="class_thread_interface.html#ac4c9521c599e6a5c5a15a555df8062ca">More...</a><br /></td></tr>
<tr class="separator:ac4c9521c599e6a5c5a15a555df8062ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5868c13864562160d1bf2b84eb391af"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread_interface.html#aa5868c13864562160d1bf2b84eb391af">MeshInterfaceNanostack</a> (<a class="el" href="class_nanostack_rf_phy.html">NanostackRfPhy</a> *phy)</td></tr>
<tr class="memdesc:aa5868c13864562160d1bf2b84eb391af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inherit <a class="el" href="class_mesh_interface_nanostack.html">MeshInterfaceNanostack</a> constructors.  <a href="class_thread_interface.html#aa5868c13864562160d1bf2b84eb391af">More...</a><br /></td></tr>
<tr class="separator:aa5868c13864562160d1bf2b84eb391af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d62267f9ba6b06a4cf66d622e61cdd3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh_interface_nanostack.html#a1d62267f9ba6b06a4cf66d622e61cdd3">initialize</a> (<a class="el" href="class_nanostack_rf_phy.html">NanostackRfPhy</a> *phy)</td></tr>
<tr class="memdesc:a1d62267f9ba6b06a4cf66d622e61cdd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach phy and initialize the mesh.  <a href="class_mesh_interface_nanostack.html#a1d62267f9ba6b06a4cf66d622e61cdd3">More...</a><br /></td></tr>
<tr class="separator:a1d62267f9ba6b06a4cf66d622e61cdd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fa37e6a20d89bf8bdc2b4718bcd7cc7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_interface_nanostack.html#a2fa37e6a20d89bf8bdc2b4718bcd7cc7">connect</a> () override</td></tr>
<tr class="memdesc:a2fa37e6a20d89bf8bdc2b4718bcd7cc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the interface.  <a href="class_interface_nanostack.html#a2fa37e6a20d89bf8bdc2b4718bcd7cc7">More...</a><br /></td></tr>
<tr class="separator:a2fa37e6a20d89bf8bdc2b4718bcd7cc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1068e9b8dbc6acf7c66418051b08fdb6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_interface_nanostack.html#a1068e9b8dbc6acf7c66418051b08fdb6">disconnect</a> () override</td></tr>
<tr class="memdesc:a1068e9b8dbc6acf7c66418051b08fdb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop the interface.  <a href="class_interface_nanostack.html#a1068e9b8dbc6acf7c66418051b08fdb6">More...</a><br /></td></tr>
<tr class="separator:a1068e9b8dbc6acf7c66418051b08fdb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a839e3aefbadd82c35902dd53ef5a21fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_interface_nanostack.html#a839e3aefbadd82c35902dd53ef5a21fa">get_ip_address</a> (<a class="el" href="class_socket_address.html">SocketAddress</a> *address) override</td></tr>
<tr class="memdesc:a839e3aefbadd82c35902dd53ef5a21fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the local IP address.   <a href="class_interface_nanostack.html#a839e3aefbadd82c35902dd53ef5a21fa">More...</a><br /></td></tr>
<tr class="separator:a839e3aefbadd82c35902dd53ef5a21fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d3eff5846155587cbfbc854c1203d16"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_interface_nanostack.html#a1d3eff5846155587cbfbc854c1203d16">get_mac_address</a> () override</td></tr>
<tr class="memdesc:a1d3eff5846155587cbfbc854c1203d16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the internally stored MAC address /return MAC address of the interface.  <a href="class_interface_nanostack.html#a1d3eff5846155587cbfbc854c1203d16">More...</a><br /></td></tr>
<tr class="separator:a1d3eff5846155587cbfbc854c1203d16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1818a2ba00bb112906e17a78c79a8c3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_interface_nanostack.html#a1818a2ba00bb112906e17a78c79a8c3c">set_mac_address</a> (uint8_t *mac_addr, <a class="el" href="group___net_socket.html#gaeaef3ae1ffcf0d50c66fa2ca37621281">nsapi_size_t</a> addr_len) override</td></tr>
<tr class="memdesc:a1818a2ba00bb112906e17a78c79a8c3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the MAC address to the interface.   <a href="class_interface_nanostack.html#a1818a2ba00bb112906e17a78c79a8c3c">More...</a><br /></td></tr>
<tr class="separator:a1818a2ba00bb112906e17a78c79a8c3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91f2033b4f0a88ffc36eb43c11f3dba6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_interface_nanostack.html#a91f2033b4f0a88ffc36eb43c11f3dba6">attach</a> (<a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; void(nsapi_event_t, intptr_t)&gt; status_cb) override</td></tr>
<tr class="memdesc:a91f2033b4f0a88ffc36eb43c11f3dba6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register callback for status reporting.  <a href="class_interface_nanostack.html#a91f2033b4f0a88ffc36eb43c11f3dba6">More...</a><br /></td></tr>
<tr class="separator:a91f2033b4f0a88ffc36eb43c11f3dba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ba659ec308e54e6b45efb55b4195e95"><td class="memItemLeft" align="right" valign="top">nsapi_connection_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_interface_nanostack.html#a2ba659ec308e54e6b45efb55b4195e95">get_connection_status</a> () const override</td></tr>
<tr class="memdesc:a2ba659ec308e54e6b45efb55b4195e95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the connection status.  <a href="class_interface_nanostack.html#a2ba659ec308e54e6b45efb55b4195e95">More...</a><br /></td></tr>
<tr class="separator:a2ba659ec308e54e6b45efb55b4195e95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1d0593b3294d27a16a956d96b09d4e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_interface_nanostack.html#ac1d0593b3294d27a16a956d96b09d4e2">set_blocking</a> (bool blocking) override</td></tr>
<tr class="memdesc:ac1d0593b3294d27a16a956d96b09d4e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set blocking status of <a class="el" href="class_interface_nanostack.html#a2fa37e6a20d89bf8bdc2b4718bcd7cc7" title="Start the interface.">connect()</a> which by default should be blocking.  <a href="class_interface_nanostack.html#ac1d0593b3294d27a16a956d96b09d4e2">More...</a><br /></td></tr>
<tr class="separator:ac1d0593b3294d27a16a956d96b09d4e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac43227b70f06d806f5e40d55d63584f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_interface_nanostack.html#ac43227b70f06d806f5e40d55d63584f0">set_file_system_root_path</a> (const char *root_path)</td></tr>
<tr class="memdesc:ac43227b70f06d806f5e40d55d63584f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set file system root path.  <a href="class_interface_nanostack.html#ac43227b70f06d806f5e40d55d63584f0">More...</a><br /></td></tr>
<tr class="separator:ac43227b70f06d806f5e40d55d63584f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cf2a4dbb080605be8161204e767b829"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_interface_nanostack.html#a8cf2a4dbb080605be8161204e767b829">get_interface_id</a> () const</td></tr>
<tr class="memdesc:a8cf2a4dbb080605be8161204e767b829"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the interface ID.  <a href="class_interface_nanostack.html#a8cf2a4dbb080605be8161204e767b829">More...</a><br /></td></tr>
<tr class="separator:a8cf2a4dbb080605be8161204e767b829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a94b10f0ae842556ebb0e0775b557cb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_interface.html#a4a94b10f0ae842556ebb0e0775b557cb">set_as_default</a> ()</td></tr>
<tr class="memdesc:a4a94b10f0ae842556ebb0e0775b557cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set network interface as default one.  <a href="class_network_interface.html#a4a94b10f0ae842556ebb0e0775b557cb">More...</a><br /></td></tr>
<tr class="separator:a4a94b10f0ae842556ebb0e0775b557cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77de8d1afa4b83dd6f560dc39251e1eb"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_interface.html#a77de8d1afa4b83dd6f560dc39251e1eb">get_ipv6_link_local_address</a> (<a class="el" href="class_socket_address.html">SocketAddress</a> *address)</td></tr>
<tr class="memdesc:a77de8d1afa4b83dd6f560dc39251e1eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the IPv6 link local address.  <a href="class_network_interface.html#a77de8d1afa4b83dd6f560dc39251e1eb">More...</a><br /></td></tr>
<tr class="separator:a77de8d1afa4b83dd6f560dc39251e1eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3709144cc9b275c18abe2a414872f140"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_interface.html#a3709144cc9b275c18abe2a414872f140">get_netmask</a> (<a class="el" href="class_socket_address.html">SocketAddress</a> *address)</td></tr>
<tr class="memdesc:a3709144cc9b275c18abe2a414872f140"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the local network mask.  <a href="class_network_interface.html#a3709144cc9b275c18abe2a414872f140">More...</a><br /></td></tr>
<tr class="separator:a3709144cc9b275c18abe2a414872f140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae69c5f0f38bd060ad04d10bc1277ae0e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_interface.html#ae69c5f0f38bd060ad04d10bc1277ae0e">get_gateway</a> (<a class="el" href="class_socket_address.html">SocketAddress</a> *address)</td></tr>
<tr class="memdesc:ae69c5f0f38bd060ad04d10bc1277ae0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the local gateway.  <a href="class_network_interface.html#ae69c5f0f38bd060ad04d10bc1277ae0e">More...</a><br /></td></tr>
<tr class="separator:ae69c5f0f38bd060ad04d10bc1277ae0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a241ab3896730d179348de54e86dcd36c"><td class="memItemLeft" align="right" valign="top">virtual char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_interface.html#a241ab3896730d179348de54e86dcd36c">get_interface_name</a> (char *interface_name)</td></tr>
<tr class="memdesc:a241ab3896730d179348de54e86dcd36c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the network interface name.  <a href="class_network_interface.html#a241ab3896730d179348de54e86dcd36c">More...</a><br /></td></tr>
<tr class="separator:a241ab3896730d179348de54e86dcd36c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaa2847bf9555fb3b9915b31ec906dc7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_interface.html#afaa2847bf9555fb3b9915b31ec906dc7">set_network</a> (const <a class="el" href="class_socket_address.html">SocketAddress</a> &amp;ip_address, const <a class="el" href="class_socket_address.html">SocketAddress</a> &amp;netmask, const <a class="el" href="class_socket_address.html">SocketAddress</a> &amp;gateway)</td></tr>
<tr class="memdesc:afaa2847bf9555fb3b9915b31ec906dc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure this network interface to use a static IP address.  <a href="class_network_interface.html#afaa2847bf9555fb3b9915b31ec906dc7">More...</a><br /></td></tr>
<tr class="separator:afaa2847bf9555fb3b9915b31ec906dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29e2da4ebf1e48a023e9306d66332e8d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_interface.html#a29e2da4ebf1e48a023e9306d66332e8d">set_dhcp</a> (bool dhcp)</td></tr>
<tr class="memdesc:a29e2da4ebf1e48a023e9306d66332e8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable DHCP on connecting the network.  <a href="class_network_interface.html#a29e2da4ebf1e48a023e9306d66332e8d">More...</a><br /></td></tr>
<tr class="separator:a29e2da4ebf1e48a023e9306d66332e8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eeb3e01ec53546b61fd7b823a4980ef"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_interface.html#a5eeb3e01ec53546b61fd7b823a4980ef">gethostbyname</a> (const char *host, <a class="el" href="class_socket_address.html">SocketAddress</a> *address, nsapi_version_t version=<a class="el" href="group___net_socket.html#ggacde826f51019112728ee4ae4e10b8a4fa09ed8714a685448ae2e149c4a142ffe7">NSAPI_UNSPEC</a>, const char *interface_name=NULL)</td></tr>
<tr class="memdesc:a5eeb3e01ec53546b61fd7b823a4980ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate a hostname to an IP address with specific version using network interface name.  <a href="class_network_interface.html#a5eeb3e01ec53546b61fd7b823a4980ef">More...</a><br /></td></tr>
<tr class="separator:a5eeb3e01ec53546b61fd7b823a4980ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87a975b9ef736cef63334895c5770660"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga4dc6e8ec26b364f135278917c3f27c6e">nsapi_value_or_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_interface.html#a87a975b9ef736cef63334895c5770660">getaddrinfo</a> (const char *hostname, <a class="el" href="class_socket_address.html">SocketAddress</a> *hints, <a class="el" href="class_socket_address.html">SocketAddress</a> **res, const char *interface_name=NULL)</td></tr>
<tr class="memdesc:a87a975b9ef736cef63334895c5770660"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate a hostname to the multiple IP addresses with specific version using network interface name.  <a href="class_network_interface.html#a87a975b9ef736cef63334895c5770660">More...</a><br /></td></tr>
<tr class="separator:a87a975b9ef736cef63334895c5770660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab43b64cae1f145615db7f697d34552d7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga4dc6e8ec26b364f135278917c3f27c6e">nsapi_value_or_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_interface.html#ab43b64cae1f145615db7f697d34552d7">gethostbyname_async</a> (const char *host, <a class="el" href="class_network_interface.html#abb962f363d7a7ec29b27844a1e5f7ecc">hostbyname_cb_t</a> callback, nsapi_version_t version=<a class="el" href="group___net_socket.html#ggacde826f51019112728ee4ae4e10b8a4fa09ed8714a685448ae2e149c4a142ffe7">NSAPI_UNSPEC</a>, const char *interface_name=NULL)</td></tr>
<tr class="memdesc:ab43b64cae1f145615db7f697d34552d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate a hostname to an IP address (asynchronous) using network interface name.  <a href="class_network_interface.html#ab43b64cae1f145615db7f697d34552d7">More...</a><br /></td></tr>
<tr class="separator:ab43b64cae1f145615db7f697d34552d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa964732e6c585b596adc760fe95f40f5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga4dc6e8ec26b364f135278917c3f27c6e">nsapi_value_or_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_interface.html#aa964732e6c585b596adc760fe95f40f5">getaddrinfo_async</a> (const char *hostname, <a class="el" href="class_socket_address.html">SocketAddress</a> *hints, <a class="el" href="class_network_interface.html#abb962f363d7a7ec29b27844a1e5f7ecc">hostbyname_cb_t</a> callback, const char *interface_name=NULL)</td></tr>
<tr class="memdesc:aa964732e6c585b596adc760fe95f40f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate a hostname to the multiple IP addresses (asynchronous) using network interface name.  <a href="class_network_interface.html#aa964732e6c585b596adc760fe95f40f5">More...</a><br /></td></tr>
<tr class="separator:aa964732e6c585b596adc760fe95f40f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26000e958701f5b35886fac1757c0bf4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_interface.html#a26000e958701f5b35886fac1757c0bf4">gethostbyname_async_cancel</a> (int id)</td></tr>
<tr class="memdesc:a26000e958701f5b35886fac1757c0bf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel asynchronous hostname translation.  <a href="class_network_interface.html#a26000e958701f5b35886fac1757c0bf4">More...</a><br /></td></tr>
<tr class="separator:a26000e958701f5b35886fac1757c0bf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a260338652be8fba7b1004bc924fdb781"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_interface.html#a260338652be8fba7b1004bc924fdb781">add_dns_server</a> (const <a class="el" href="class_socket_address.html">SocketAddress</a> &amp;address, const char *interface_name)</td></tr>
<tr class="memdesc:a260338652be8fba7b1004bc924fdb781"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a domain name server to list of servers to query.  <a href="class_network_interface.html#a260338652be8fba7b1004bc924fdb781">More...</a><br /></td></tr>
<tr class="separator:a260338652be8fba7b1004bc924fdb781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ccb0f7a5af95e76d0dea335ab866047"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_interface.html#a0ccb0f7a5af95e76d0dea335ab866047">get_dns_server</a> (int index, <a class="el" href="class_socket_address.html">SocketAddress</a> *address, const char *interface_name=NULL)</td></tr>
<tr class="memdesc:a0ccb0f7a5af95e76d0dea335ab866047"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a domain name server from a list of servers to query.  <a href="class_network_interface.html#a0ccb0f7a5af95e76d0dea335ab866047">More...</a><br /></td></tr>
<tr class="separator:a0ccb0f7a5af95e76d0dea335ab866047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab61fc4dcb3f255e327c189325eee1e43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_interface.html#ab61fc4dcb3f255e327c189325eee1e43">add_event_listener</a> (<a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; void(nsapi_event_t, intptr_t)&gt; status_cb)</td></tr>
<tr class="memdesc:ab61fc4dcb3f255e327c189325eee1e43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add event listener for interface.  <a href="class_network_interface.html#ab61fc4dcb3f255e327c189325eee1e43">More...</a><br /></td></tr>
<tr class="separator:ab61fc4dcb3f255e327c189325eee1e43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3fb296eec26bfad22eb94c71c9c502d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_eth_interface.html">EthInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_interface.html#ad3fb296eec26bfad22eb94c71c9c502d">ethInterface</a> ()</td></tr>
<tr class="memdesc:ad3fb296eec26bfad22eb94c71c9c502d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return pointer to an <a class="el" href="class_eth_interface.html" title="Common interface between Ethernet hardware.">EthInterface</a>.  <a href="class_network_interface.html#ad3fb296eec26bfad22eb94c71c9c502d">More...</a><br /></td></tr>
<tr class="separator:ad3fb296eec26bfad22eb94c71c9c502d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09d99efafd15a9d84a77761372e838d5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_wi_fi_interface.html">WiFiInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_interface.html#a09d99efafd15a9d84a77761372e838d5">wifiInterface</a> ()</td></tr>
<tr class="memdesc:a09d99efafd15a9d84a77761372e838d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return pointer to a <a class="el" href="class_wi_fi_interface.html" title="Common interface between Wi-Fi devices.">WiFiInterface</a>.  <a href="class_network_interface.html#a09d99efafd15a9d84a77761372e838d5">More...</a><br /></td></tr>
<tr class="separator:a09d99efafd15a9d84a77761372e838d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65c1b846fba9d9008dafa54b31d4e1a0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_mesh_interface.html">MeshInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_interface.html#a65c1b846fba9d9008dafa54b31d4e1a0">meshInterface</a> ()</td></tr>
<tr class="memdesc:a65c1b846fba9d9008dafa54b31d4e1a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return pointer to a <a class="el" href="class_mesh_interface.html" title="Common interface that is shared between mesh hardware.">MeshInterface</a>.  <a href="class_network_interface.html#a65c1b846fba9d9008dafa54b31d4e1a0">More...</a><br /></td></tr>
<tr class="separator:a65c1b846fba9d9008dafa54b31d4e1a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a5135a4e8f7628515bae7599da85269"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_mesh_interface.html">MeshInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh_interface.html#a1a5135a4e8f7628515bae7599da85269">meshInterface</a> () final</td></tr>
<tr class="memdesc:a1a5135a4e8f7628515bae7599da85269"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return pointer to a <a class="el" href="class_mesh_interface.html" title="Common interface that is shared between mesh hardware.">MeshInterface</a>.   <a href="class_mesh_interface.html#a1a5135a4e8f7628515bae7599da85269">More...</a><br /></td></tr>
<tr class="separator:a1a5135a4e8f7628515bae7599da85269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada0ecf739088a765ebc7fbc4181bb375"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_e_m_a_c_interface.html">EMACInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_interface.html#ada0ecf739088a765ebc7fbc4181bb375">emacInterface</a> ()</td></tr>
<tr class="memdesc:ada0ecf739088a765ebc7fbc4181bb375"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return pointer to an <a class="el" href="class_e_m_a_c_interface.html" title="EMACInterface class Implementation of the NetworkInterface for an EMAC-based driver.">EMACInterface</a>.  <a href="class_network_interface.html#ada0ecf739088a765ebc7fbc4181bb375">More...</a><br /></td></tr>
<tr class="separator:ada0ecf739088a765ebc7fbc4181bb375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed55ca6584533439ab78cfd487a2c56f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_cellular_interface.html">CellularInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_interface.html#aed55ca6584533439ab78cfd487a2c56f">cellularInterface</a> ()</td></tr>
<tr class="memdesc:aed55ca6584533439ab78cfd487a2c56f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return pointer to a <a class="el" href="class_cellular_interface.html" title="Common interface that is shared between cellular interfaces.">CellularInterface</a>.  <a href="class_network_interface.html#aed55ca6584533439ab78cfd487a2c56f">More...</a><br /></td></tr>
<tr class="separator:aed55ca6584533439ab78cfd487a2c56f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a123d2c4ef90c33aec33471ac040049c1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_interface.html#a123d2c4ef90c33aec33471ac040049c1">set_default_parameters</a> ()</td></tr>
<tr class="memdesc:a123d2c4ef90c33aec33471ac040049c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">defined(DOXYGEN_ONLY)  <a href="class_network_interface.html#a123d2c4ef90c33aec33471ac040049c1">More...</a><br /></td></tr>
<tr class="separator:a123d2c4ef90c33aec33471ac040049c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a00c2abaa91df1131639e63d980866244"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_network_interface.html">NetworkInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_interface.html#a00c2abaa91df1131639e63d980866244">get_default_instance</a> ()</td></tr>
<tr class="memdesc:a00c2abaa91df1131639e63d980866244"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the default network interface.  <a href="class_network_interface.html#a00c2abaa91df1131639e63d980866244">More...</a><br /></td></tr>
<tr class="separator:a00c2abaa91df1131639e63d980866244"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07dd7bc45b7305e67e868d66c7729b09"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_mesh_interface.html">MeshInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh_interface.html#a07dd7bc45b7305e67e868d66c7729b09">get_default_instance</a> ()</td></tr>
<tr class="memdesc:a07dd7bc45b7305e67e868d66c7729b09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the default Mesh interface.  <a href="class_mesh_interface.html#a07dd7bc45b7305e67e868d66c7729b09">More...</a><br /></td></tr>
<tr class="separator:a07dd7bc45b7305e67e868d66c7729b09"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Thread mesh network interface class. </p>
<p >Configure <a class="el" href="class_nanostack.html">Nanostack</a> to use Thread protocol. </p>

<p class="definition">Definition at line <a class="el" href="_thread_interface_8h_source.html#l00026">26</a> of file <a class="el" href="_thread_interface_8h_source.html">ThreadInterface.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="abb962f363d7a7ec29b27844a1e5f7ecc" name="abb962f363d7a7ec29b27844a1e5f7ecc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb962f363d7a7ec29b27844a1e5f7ecc">&#9670;&#160;</a></span>hostbyname_cb_t</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt;void (<a class="el" href="group___net_socket.html#ga4dc6e8ec26b364f135278917c3f27c6e">nsapi_value_or_error_t</a> result, <a class="el" href="class_socket_address.html">SocketAddress</a> *address)&gt; <a class="el" href="class_network_interface.html#abb962f363d7a7ec29b27844a1e5f7ecc">hostbyname_cb_t</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hostname translation callback (for use with <a class="el" href="class_network_interface.html#ab43b64cae1f145615db7f697d34552d7" title="Translate a hostname to an IP address (asynchronous) using network interface name.">gethostbyname_async()</a>). </p>
<p >Callback will be called after <a class="el" href="class_d_n_s.html" title="Base class for DNS provider.">DNS</a> resolution completes or a failure occurs.</p>
<dl class="section note"><dt>Note</dt><dd>Callback should not take more than 10ms to execute, otherwise it might prevent underlying thread processing. A portable user of the callback should not make calls to network operations due to stack size limitations. The callback should not perform expensive operations such as socket recv/send calls or blocking operations.</dd></dl>
<p><br  />
 <code>result</code> : Negative error code on failure, or value that represents the number of <a class="el" href="class_d_n_s.html" title="Base class for DNS provider.">DNS</a> records <br  />
 <code>address</code> : On success, destination for the host <a class="el" href="class_socket_address.html" title="SocketAddress class.">SocketAddress</a>. </p>

<p class="definition">Definition at line <a class="el" href="_network_interface_8h_source.html#l00285">285</a> of file <a class="el" href="_network_interface_8h_source.html">NetworkInterface.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a74bda7fdb29f8cd964e69046536433ae" name="a74bda7fdb29f8cd964e69046536433ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74bda7fdb29f8cd964e69046536433ae">&#9670;&#160;</a></span>device_eui64_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void device_eui64_set </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>eui64</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the eui64 for the device configuration. </p>
<p >By default this value is read from the radio driver. The value must be set before calling the connect function. </p>

</div>
</div>
<a id="a3c804e890fd9ceb65b966c9bfc62e2be" name="a3c804e890fd9ceb65b966c9bfc62e2be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c804e890fd9ceb65b966c9bfc62e2be">&#9670;&#160;</a></span>device_eui64_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void device_eui64_get </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>eui64</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the eui64 from the device configuration. </p>
<p >By default this value is read from the radio driver, but it may have been set by <a class="el" href="class_thread_interface.html#a74bda7fdb29f8cd964e69046536433ae" title="Sets the eui64 for the device configuration.">device_eui64_set()</a>. </p>

</div>
</div>
<a id="aa4a27cd30598ca101e2e49bce9f1b79d" name="aa4a27cd30598ca101e2e49bce9f1b79d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4a27cd30598ca101e2e49bce9f1b79d">&#9670;&#160;</a></span>device_pskd_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mesh_error_t device_pskd_set </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pskd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sets the PSKd for the device configuration. </p>
<p >The default value is overwritten, which is defined in the mbed_lib.json file in the mesh-api The value must be set before calling the connect function. </p><dl class="section return"><dt>Returns</dt><dd>MESH_ERROR_NONE on success. </dd>
<dd>
MESH_ERROR_PARAM in case of illegal parameters. </dd>
<dd>
MESH_ERROR_MEMORY in case of memory error. </dd></dl>

</div>
</div>
<a id="ac4c9521c599e6a5c5a15a555df8062ca" name="ac4c9521c599e6a5c5a15a555df8062ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4c9521c599e6a5c5a15a555df8062ca">&#9670;&#160;</a></span>MeshInterfaceNanostack() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mesh_interface_nanostack.html">MeshInterfaceNanostack</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inherit <a class="el" href="class_mesh_interface_nanostack.html">MeshInterfaceNanostack</a> constructors. </p>

</div>
</div>
<a id="aa5868c13864562160d1bf2b84eb391af" name="aa5868c13864562160d1bf2b84eb391af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5868c13864562160d1bf2b84eb391af">&#9670;&#160;</a></span>MeshInterfaceNanostack() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mesh_interface_nanostack.html">MeshInterfaceNanostack</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_nanostack_rf_phy.html">NanostackRfPhy</a> *&#160;</td>
          <td class="paramname"><em>phy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inherit <a class="el" href="class_mesh_interface_nanostack.html">MeshInterfaceNanostack</a> constructors. </p>

<p class="definition">Definition at line <a class="el" href="_mesh_interface_nanostack_8h_source.html#l00182">182</a> of file <a class="el" href="_mesh_interface_nanostack_8h_source.html">MeshInterfaceNanostack.h</a>.</p>

</div>
</div>
<a id="a1d62267f9ba6b06a4cf66d622e61cdd3" name="a1d62267f9ba6b06a4cf66d622e61cdd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d62267f9ba6b06a4cf66d622e61cdd3">&#9670;&#160;</a></span>initialize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> initialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_nanostack_rf_phy.html">NanostackRfPhy</a> *&#160;</td>
          <td class="paramname"><em>phy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attach phy and initialize the mesh. </p>
<p >Initializes a mesh interface on the given phy. Not needed if the phy is passed to the mesh's constructor.</p>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative on failure </dd></dl>

</div>
</div>
<a id="a2fa37e6a20d89bf8bdc2b4718bcd7cc7" name="a2fa37e6a20d89bf8bdc2b4718bcd7cc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fa37e6a20d89bf8bdc2b4718bcd7cc7">&#9670;&#160;</a></span>connect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> connect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start the interface. </p>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative error code on failure </dd></dl>

<p>Implements <a class="el" href="class_network_interface.html#aaf6bf1dfffbe6a5626b7b52eaa542b6e">NetworkInterface</a>.</p>

</div>
</div>
<a id="a1068e9b8dbc6acf7c66418051b08fdb6" name="a1068e9b8dbc6acf7c66418051b08fdb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1068e9b8dbc6acf7c66418051b08fdb6">&#9670;&#160;</a></span>disconnect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> disconnect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stop the interface. </p>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative error code on failure </dd></dl>

<p>Implements <a class="el" href="class_network_interface.html#afdda3f62c7d73df183ee2d352e8cd146">NetworkInterface</a>.</p>

</div>
</div>
<a id="a839e3aefbadd82c35902dd53ef5a21fa" name="a839e3aefbadd82c35902dd53ef5a21fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a839e3aefbadd82c35902dd53ef5a21fa">&#9670;&#160;</a></span>get_ip_address()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> get_ip_address </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_socket_address.html">SocketAddress</a> *&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the local IP address.  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td><a class="el" href="class_socket_address.html" title="SocketAddress class.">SocketAddress</a> representation of the local IP address </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NSAPI_ERROR_OK</td><td>on success </td></tr>
    <tr><td class="paramname">NSAPI_ERROR_UNSUPPORTED</td><td>if this feature is not supported </td></tr>
    <tr><td class="paramname">NSAPI_ERROR_PARAMETER</td><td>if the provided pointer is invalid </td></tr>
    <tr><td class="paramname">NSAPI_ERROR_NO_ADDRESS</td><td>if the address cannot be obtained from stack  </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_network_interface.html#a2ab48210e24fc7efb4e1cada14c4b57b">NetworkInterface</a>.</p>

</div>
</div>
<a id="a1d3eff5846155587cbfbc854c1203d16" name="a1d3eff5846155587cbfbc854c1203d16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d3eff5846155587cbfbc854c1203d16">&#9670;&#160;</a></span>get_mac_address()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * get_mac_address </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the internally stored MAC address /return MAC address of the interface. </p>

<p>Reimplemented from <a class="el" href="class_network_interface.html#aaf0ca1fccad1a27c1e76403676192347">NetworkInterface</a>.</p>

</div>
</div>
<a id="a1818a2ba00bb112906e17a78c79a8c3c" name="a1818a2ba00bb112906e17a78c79a8c3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1818a2ba00bb112906e17a78c79a8c3c">&#9670;&#160;</a></span>set_mac_address()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> set_mac_address </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>mac_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___net_socket.html#gaeaef3ae1ffcf0d50c66fa2ca37621281">nsapi_size_t</a>&#160;</td>
          <td class="paramname"><em>addr_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the MAC address to the interface.  </p>
<p >Set the provided MAC address on the network interface. The address must be unique globally. The address must be set before calling the interface <a class="el" href="class_interface_nanostack.html#a2fa37e6a20d89bf8bdc2b4718bcd7cc7" title="Start the interface.">connect()</a> method.</p>
<p >Not all interfaces are supporting MAC address set and an error is not returned for this method call. Verify the changed MAC address by checking packet captures from the used network interface.</p>
<p >6-byte EUI-48 MAC addresses are used for Ethernet while Mesh interface is using 8-byte EUI-64 address.</p>
<p >More information about obtaining MAC address can be found from: <a href="https://standards.ieee.org/products-services/regauth/index.html">https://standards.ieee.org/products-services/regauth/index.html</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mac_addr</td><td>Buffer containing the MAC address in hexadecimal format. </td></tr>
    <tr><td class="paramname">addr_len</td><td>Length of provided buffer in bytes (6 or 8) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NSAPI_ERROR_OK</td><td>on success </td></tr>
    <tr><td class="paramname">NSAPI_ERROR_UNSUPPORTED</td><td>if this feature is not supported </td></tr>
    <tr><td class="paramname">NSAPI_ERROR_PARAMETER</td><td>if address is not valid </td></tr>
    <tr><td class="paramname">NSAPI_ERROR_BUSY</td><td>if address can't be set.  </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_network_interface.html#a526802de6e27e291d46e3e3e6a396978">NetworkInterface</a>.</p>

</div>
</div>
<a id="a91f2033b4f0a88ffc36eb43c11f3dba6" name="a91f2033b4f0a88ffc36eb43c11f3dba6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91f2033b4f0a88ffc36eb43c11f3dba6">&#9670;&#160;</a></span>attach()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void attach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; void(nsapi_event_t, intptr_t)&gt;&#160;</td>
          <td class="paramname"><em>status_cb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register callback for status reporting. </p>
<p >The specified status callback function will be called on status changes on the network. The parameters on the callback are the event type and event-type dependent reason parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">status_cb</td><td>The callback for status changes </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_network_interface.html#a27082cfcaab9462699208893d05a70d1">NetworkInterface</a>.</p>

</div>
</div>
<a id="a2ba659ec308e54e6b45efb55b4195e95" name="a2ba659ec308e54e6b45efb55b4195e95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ba659ec308e54e6b45efb55b4195e95">&#9670;&#160;</a></span>get_connection_status()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">nsapi_connection_status_t get_connection_status </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the connection status. </p>
<dl class="section return"><dt>Returns</dt><dd>The connection status according to ConnectionStatusType </dd></dl>

<p>Reimplemented from <a class="el" href="class_network_interface.html#a840e46edfb6792d1c588cf95c0387cd6">NetworkInterface</a>.</p>

</div>
</div>
<a id="ac1d0593b3294d27a16a956d96b09d4e2" name="ac1d0593b3294d27a16a956d96b09d4e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1d0593b3294d27a16a956d96b09d4e2">&#9670;&#160;</a></span>set_blocking()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> set_blocking </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blocking</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set blocking status of <a class="el" href="class_interface_nanostack.html#a2fa37e6a20d89bf8bdc2b4718bcd7cc7" title="Start the interface.">connect()</a> which by default should be blocking. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blocking</td><td>true if connect is blocking </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative error code on failure </dd></dl>

<p>Reimplemented from <a class="el" href="class_network_interface.html#a8dc0651d23c76c830d241236e22f0a1b">NetworkInterface</a>.</p>

</div>
</div>
<a id="ac43227b70f06d806f5e40d55d63584f0" name="ac43227b70f06d806f5e40d55d63584f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac43227b70f06d806f5e40d55d63584f0">&#9670;&#160;</a></span>set_file_system_root_path()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> set_file_system_root_path </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>root_path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set file system root path. </p>
<p >Set file system root path that stack will use to write and read its data. Setting root_path to NULL will disable file system usage.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root_path</td><td>Address to NUL-terminated root-path string or NULL to disable file system usage. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MESH_ERROR_NONE on success, MESH_ERROR_MEMORY in case of memory failure, MESH_ERROR_UNKNOWN in case of other error. </dd></dl>

</div>
</div>
<a id="a8cf2a4dbb080605be8161204e767b829" name="a8cf2a4dbb080605be8161204e767b829"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cf2a4dbb080605be8161204e767b829">&#9670;&#160;</a></span>get_interface_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int8_t get_interface_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the interface ID. </p>
<dl class="section return"><dt>Returns</dt><dd>Interface identifier </dd></dl>

<p class="definition">Definition at line <a class="el" href="_mesh_interface_nanostack_8h_source.html#l00145">145</a> of file <a class="el" href="_mesh_interface_nanostack_8h_source.html">MeshInterfaceNanostack.h</a>.</p>

</div>
</div>
<a id="a00c2abaa91df1131639e63d980866244" name="a00c2abaa91df1131639e63d980866244"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00c2abaa91df1131639e63d980866244">&#9670;&#160;</a></span>get_default_instance() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_network_interface.html">NetworkInterface</a> * get_default_instance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the default network interface. </p>
<p >Returns the default network interface, as determined by JSON option target.network-default-interface-type or other overrides.</p>
<p >The type of the interface returned can be tested by calling <a class="el" href="class_network_interface.html#ad3fb296eec26bfad22eb94c71c9c502d" title="Return pointer to an EthInterface.">ethInterface()</a>, <a class="el" href="class_network_interface.html#a09d99efafd15a9d84a77761372e838d5" title="Return pointer to a WiFiInterface.">wifiInterface()</a>, <a class="el" href="class_mesh_interface.html#a1a5135a4e8f7628515bae7599da85269" title="Return pointer to a MeshInterface.">meshInterface()</a>, <a class="el" href="class_network_interface.html#aed55ca6584533439ab78cfd487a2c56f" title="Return pointer to a CellularInterface.">cellularInterface()</a>, <a class="el" href="class_network_interface.html#ada0ecf739088a765ebc7fbc4181bb375" title="Return pointer to an EMACInterface.">emacInterface()</a> and checking for NULL pointers.</p>
<p >The default behavior is to return the default interface for the interface type specified by target.network-default-interface-type. Targets should set this in their targets.json to guide default selection, and applications may override.</p>
<p >The interface returned should be already configured for use such that its <a class="el" href="class_interface_nanostack.html#a2fa37e6a20d89bf8bdc2b4718bcd7cc7" title="Start the interface.">connect()</a> method works with no parameters. For connection types needing configuration, settings should normally be obtained from JSON - the settings for the core types are under the "nsapi" JSON config tree.</p>
<p >The list of possible settings for default interface type is open-ended, as is the number of possible providers. Core providers are:</p>
<ul>
<li>ETHERNET: <a class="el" href="class_ethernet_interface.html" title="Implementation of the NetworkStack for an EMAC-based Ethernet driver.">EthernetInterface</a>, using default <a class="el" href="class_e_m_a_c.html" title="This interface should be used to abstract low level access to networking hardware All operations rece...">EMAC</a> and <a class="el" href="class_onboard_network_stack.html" title="mbed OS API for onboard IP stack abstraction">OnboardNetworkStack</a></li>
<li>MESH: <a class="el" href="class_thread_interface.html" title="Thread mesh network interface class.">ThreadInterface</a> or <a class="el" href="class_lo_w_p_a_n_n_d_interface.html" title="6LoWPAN-ND mesh network interface class">LoWPANNDInterface</a>, using default <a class="el" href="class_nanostack_rf_phy.html" title="Radio PHY driver class for Nanostack.">NanostackRfPhy</a></li>
<li>CELLULAR: OnboardModemInterface</li>
<li>WIFI: None - always provided by a specific class</li>
</ul>
<p >Specific drivers may be activated by other settings of the default-network-interface-type configuration. This will depend on the target and the driver. For example a board may have its default setting as "AUTO" which causes it to autodetect an Ethernet cable. This should be described in the target's documentation.</p>
<p >An application can override all target settings by implementing <a class="el" href="class_network_interface.html#a00c2abaa91df1131639e63d980866244" title="Return the default network interface.">NetworkInterface::get_default_instance()</a> themselves - the default definition is weak, and calls get_target_default_instance(). </p>

</div>
</div>
<a id="a07dd7bc45b7305e67e868d66c7729b09" name="a07dd7bc45b7305e67e868d66c7729b09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07dd7bc45b7305e67e868d66c7729b09">&#9670;&#160;</a></span>get_default_instance() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_mesh_interface.html">MeshInterface</a> * get_default_instance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the default Mesh interface. </p>
<p >This is provided as a weak method so applications can override. Default behavior is to get the target's default interface, if any.</p>
<dl class="section return"><dt>Returns</dt><dd>pointer to interface, if any. </dd></dl>

</div>
</div>
<a id="a4a94b10f0ae842556ebb0e0775b557cb" name="a4a94b10f0ae842556ebb0e0775b557cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a94b10f0ae842556ebb0e0775b557cb">&#9670;&#160;</a></span>set_as_default()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void set_as_default </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set network interface as default one. </p>

<p>Reimplemented in <a class="el" href="class_e_m_a_c_interface.html#a344c00309ca7046be3644d12458d0e59">EMACInterface</a>, <a class="el" href="class_l3_i_p_interface.html#a344c00309ca7046be3644d12458d0e59">L3IPInterface</a>, and <a class="el" href="class_p_p_p_interface.html#a344c00309ca7046be3644d12458d0e59">PPPInterface</a>.</p>

</div>
</div>
<a id="a77de8d1afa4b83dd6f560dc39251e1eb" name="a77de8d1afa4b83dd6f560dc39251e1eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77de8d1afa4b83dd6f560dc39251e1eb">&#9670;&#160;</a></span>get_ipv6_link_local_address()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> get_ipv6_link_local_address </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_socket_address.html">SocketAddress</a> *&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the IPv6 link local address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td><a class="el" href="class_socket_address.html" title="SocketAddress class.">SocketAddress</a> representation of the link local IPv6 address </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NSAPI_ERROR_OK</td><td>on success </td></tr>
    <tr><td class="paramname">NSAPI_ERROR_UNSUPPORTED</td><td>if this feature is not supported </td></tr>
    <tr><td class="paramname">NSAPI_ERROR_PARAMETER</td><td>if the provided pointer is invalid </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_e_m_a_c_interface.html#a26e81e7450d1d68c4608209f565370cc">EMACInterface</a>.</p>

</div>
</div>
<a id="a3709144cc9b275c18abe2a414872f140" name="a3709144cc9b275c18abe2a414872f140"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3709144cc9b275c18abe2a414872f140">&#9670;&#160;</a></span>get_netmask()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> get_netmask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_socket_address.html">SocketAddress</a> *&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the local network mask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td><a class="el" href="class_socket_address.html" title="SocketAddress class.">SocketAddress</a> representation of netmask </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NSAPI_ERROR_OK</td><td>on success </td></tr>
    <tr><td class="paramname">NSAPI_ERROR_UNSUPPORTED</td><td>if this feature is not supported </td></tr>
    <tr><td class="paramname">NSAPI_ERROR_PARAMETER</td><td>if the provided pointer is invalid </td></tr>
    <tr><td class="paramname">NSAPI_ERROR_NO_ADDRESS</td><td>if the address cannot be obtained from stack </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_e_m_a_c_interface.html#adbcda6c56b87278605872eae2f992fdc">EMACInterface</a>, <a class="el" href="class_l3_i_p_interface.html#adbcda6c56b87278605872eae2f992fdc">L3IPInterface</a>, and <a class="el" href="class_p_p_p_interface.html#adbcda6c56b87278605872eae2f992fdc">PPPInterface</a>.</p>

</div>
</div>
<a id="ae69c5f0f38bd060ad04d10bc1277ae0e" name="ae69c5f0f38bd060ad04d10bc1277ae0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae69c5f0f38bd060ad04d10bc1277ae0e">&#9670;&#160;</a></span>get_gateway()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> get_gateway </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_socket_address.html">SocketAddress</a> *&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the local gateway. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td><a class="el" href="class_socket_address.html" title="SocketAddress class.">SocketAddress</a> representation of gateway address </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NSAPI_ERROR_OK</td><td>on success </td></tr>
    <tr><td class="paramname">NSAPI_ERROR_UNSUPPORTED</td><td>if this feature is not supported </td></tr>
    <tr><td class="paramname">NSAPI_ERROR_PARAMETER</td><td>if the provided pointer is invalid </td></tr>
    <tr><td class="paramname">NSAPI_ERROR_NO_ADDRESS</td><td>if the address cannot be obtained from stack </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classmbed_1_1_u_b_l_o_x___a_t___cellular_context.html#a5bd6a10f70055c0d531f980f66e59b21">UBLOX_AT_CellularContext</a>, <a class="el" href="class_e_m_a_c_interface.html#a614b733210566ac70c1b0dc7fa95b8e9">EMACInterface</a>, <a class="el" href="class_l3_i_p_interface.html#a614b733210566ac70c1b0dc7fa95b8e9">L3IPInterface</a>, and <a class="el" href="class_p_p_p_interface.html#a614b733210566ac70c1b0dc7fa95b8e9">PPPInterface</a>.</p>

</div>
</div>
<a id="a241ab3896730d179348de54e86dcd36c" name="a241ab3896730d179348de54e86dcd36c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a241ab3896730d179348de54e86dcd36c">&#9670;&#160;</a></span>get_interface_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual char * get_interface_name </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>interface_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the network interface name. </p>
<dl class="section return"><dt>Returns</dt><dd>Null-terminated representation of the network interface name or null if interface not exists </dd></dl>

<p>Reimplemented in <a class="el" href="classmbed_1_1_a_t___cellular_context.html#a241ab3896730d179348de54e86dcd36c">AT_CellularContext</a>, <a class="el" href="class_e_m_a_c_interface.html#a1228bd8a05b0645ecccc4dce3b0143b8">EMACInterface</a>, <a class="el" href="class_l3_i_p_interface.html#a1228bd8a05b0645ecccc4dce3b0143b8">L3IPInterface</a>, and <a class="el" href="class_p_p_p_interface.html#a1228bd8a05b0645ecccc4dce3b0143b8">PPPInterface</a>.</p>

</div>
</div>
<a id="afaa2847bf9555fb3b9915b31ec906dc7" name="afaa2847bf9555fb3b9915b31ec906dc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaa2847bf9555fb3b9915b31ec906dc7">&#9670;&#160;</a></span>set_network()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> set_network </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_socket_address.html">SocketAddress</a> &amp;&#160;</td>
          <td class="paramname"><em>ip_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_socket_address.html">SocketAddress</a> &amp;&#160;</td>
          <td class="paramname"><em>netmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_socket_address.html">SocketAddress</a> &amp;&#160;</td>
          <td class="paramname"><em>gateway</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Configure this network interface to use a static IP address. </p>
<p >Implicitly disables DHCP, which can be enabled in set_dhcp. Requires that the network is disconnected.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ip_address</td><td><a class="el" href="class_socket_address.html" title="SocketAddress class.">SocketAddress</a> object containing the local IP address </td></tr>
    <tr><td class="paramname">netmask</td><td><a class="el" href="class_socket_address.html" title="SocketAddress class.">SocketAddress</a> object containing the local network mask </td></tr>
    <tr><td class="paramname">gateway</td><td><a class="el" href="class_socket_address.html" title="SocketAddress class.">SocketAddress</a> object containing the local gateway </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NSAPI_ERROR_OK</td><td>on success </td></tr>
    <tr><td class="paramname">NSAPI_ERROR_UNSUPPORTED</td><td>if this function is unsupported </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_e_m_a_c_interface.html#a9919ef603c0c526ec73722610bd877ca">EMACInterface</a>, <a class="el" href="class_l3_i_p_interface.html#a9919ef603c0c526ec73722610bd877ca">L3IPInterface</a>, and <a class="el" href="class_p_p_p_interface.html#a9919ef603c0c526ec73722610bd877ca">PPPInterface</a>.</p>

</div>
</div>
<a id="a29e2da4ebf1e48a023e9306d66332e8d" name="a29e2da4ebf1e48a023e9306d66332e8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29e2da4ebf1e48a023e9306d66332e8d">&#9670;&#160;</a></span>set_dhcp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> set_dhcp </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dhcp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable or disable DHCP on connecting the network. </p>
<p >Enabled by default unless a static IP address has been assigned. Requires that the network is disconnected.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dhcp</td><td>True to enable DHCP. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NSAPI_ERROR_OK</td><td>on success. </td></tr>
    <tr><td class="paramname">NSAPI_ERROR_UNSUPPORTED</td><td>if operation is not supported. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_e_m_a_c_interface.html#a8e39d3de385c6227267f23666ea86eb3">EMACInterface</a>, and <a class="el" href="class_l3_i_p_interface.html#a8e39d3de385c6227267f23666ea86eb3">L3IPInterface</a>.</p>

</div>
</div>
<a id="a5eeb3e01ec53546b61fd7b823a4980ef" name="a5eeb3e01ec53546b61fd7b823a4980ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eeb3e01ec53546b61fd7b823a4980ef">&#9670;&#160;</a></span>gethostbyname()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> gethostbyname </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_socket_address.html">SocketAddress</a> *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nsapi_version_t&#160;</td>
          <td class="paramname"><em>version</em> = <code><a class="el" href="group___net_socket.html#ggacde826f51019112728ee4ae4e10b8a4fa09ed8714a685448ae2e149c4a142ffe7">NSAPI_UNSPEC</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>interface_name</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Translate a hostname to an IP address with specific version using network interface name. </p>
<p >The hostname may be either a domain name or an IP address. If the hostname is an IP address, no network transactions will be performed.</p>
<p >If no stack-specific <a class="el" href="class_d_n_s.html" title="Base class for DNS provider.">DNS</a> resolution is provided, the hostname will be resolve using a UDP socket on the stack.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>Hostname to resolve. </td></tr>
    <tr><td class="paramname">address</td><td>Pointer to a <a class="el" href="class_socket_address.html" title="SocketAddress class.">SocketAddress</a> to store the result. </td></tr>
    <tr><td class="paramname">version</td><td>IP version of address to resolve, NSAPI_UNSPEC indicates version is chosen by the stack (defaults to NSAPI_UNSPEC). </td></tr>
    <tr><td class="paramname">interface_name</td><td>Network interface name </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NSAPI_ERROR_OK</td><td>on success </td></tr>
    <tr><td class="paramname">int</td><td>Negative error code on failure. See <a class="el" href="class_network_stack.html#a5eeb3e01ec53546b61fd7b823a4980ef">NetworkStack::gethostbyname</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_d_n_s.html#ae247aa841e5b519a5e47305ee00bacd2">DNS</a>.</p>

</div>
</div>
<a id="a87a975b9ef736cef63334895c5770660" name="a87a975b9ef736cef63334895c5770660"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87a975b9ef736cef63334895c5770660">&#9670;&#160;</a></span>getaddrinfo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga4dc6e8ec26b364f135278917c3f27c6e">nsapi_value_or_error_t</a> getaddrinfo </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>hostname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_socket_address.html">SocketAddress</a> *&#160;</td>
          <td class="paramname"><em>hints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_socket_address.html">SocketAddress</a> **&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>interface_name</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Translate a hostname to the multiple IP addresses with specific version using network interface name. </p>
<p >The hostname may be either a domain name or an IP address. If the hostname is an IP address, no network transactions will be performed.</p>
<p >If no stack-specific <a class="el" href="class_d_n_s.html" title="Base class for DNS provider.">DNS</a> resolution is provided, the hostname will be resolve using a UDP socket on the stack.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hostname</td><td>Hostname to resolve. </td></tr>
    <tr><td class="paramname">hints</td><td>Pointer to a <a class="el" href="class_socket_address.html" title="SocketAddress class.">SocketAddress</a> with query parameters. </td></tr>
    <tr><td class="paramname">res</td><td>Pointer to a <a class="el" href="class_socket_address.html" title="SocketAddress class.">SocketAddress</a> array to store the result.. </td></tr>
    <tr><td class="paramname">interface_name</td><td>Network interface name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of results on success, negative error code on failure. </dd></dl>

<p>Implements <a class="el" href="class_d_n_s.html#a4e2299044fa2bbb37717a7661bb608f7">DNS</a>.</p>

</div>
</div>
<a id="ab43b64cae1f145615db7f697d34552d7" name="ab43b64cae1f145615db7f697d34552d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab43b64cae1f145615db7f697d34552d7">&#9670;&#160;</a></span>gethostbyname_async()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga4dc6e8ec26b364f135278917c3f27c6e">nsapi_value_or_error_t</a> gethostbyname_async </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_network_interface.html#abb962f363d7a7ec29b27844a1e5f7ecc">hostbyname_cb_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nsapi_version_t&#160;</td>
          <td class="paramname"><em>version</em> = <code><a class="el" href="group___net_socket.html#ggacde826f51019112728ee4ae4e10b8a4fa09ed8714a685448ae2e149c4a142ffe7">NSAPI_UNSPEC</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>interface_name</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Translate a hostname to an IP address (asynchronous) using network interface name. </p>
<p >The hostname may be either a domain name or a dotted IP address. If the hostname is an IP address, no network transactions will be performed.</p>
<p >If no stack-specific <a class="el" href="class_d_n_s.html" title="Base class for DNS provider.">DNS</a> resolution is provided, the hostname will be resolve using a UDP socket on the stack.</p>
<p >Call is non-blocking. Result of the <a class="el" href="class_d_n_s.html" title="Base class for DNS provider.">DNS</a> operation is returned by the callback. If this function returns failure, callback will not be called. In case result is success (IP address was found from <a class="el" href="class_d_n_s.html" title="Base class for DNS provider.">DNS</a> cache), callback will be called before function returns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>Hostname to resolve. </td></tr>
    <tr><td class="paramname">callback</td><td>Callback that is called for result. </td></tr>
    <tr><td class="paramname">version</td><td>IP version of address to resolve, NSAPI_UNSPEC indicates version is chosen by the stack (defaults to NSAPI_UNSPEC). </td></tr>
    <tr><td class="paramname">interface_name</td><td>Network interface name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on immediate success, negative error code on immediate failure or a positive unique id that represents the hostname translation operation and can be passed to cancel. </dd></dl>

<p>Implements <a class="el" href="class_d_n_s.html#aede5e7d96c7b2141f60a9fefec11e462">DNS</a>.</p>

</div>
</div>
<a id="aa964732e6c585b596adc760fe95f40f5" name="aa964732e6c585b596adc760fe95f40f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa964732e6c585b596adc760fe95f40f5">&#9670;&#160;</a></span>getaddrinfo_async()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga4dc6e8ec26b364f135278917c3f27c6e">nsapi_value_or_error_t</a> getaddrinfo_async </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>hostname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_socket_address.html">SocketAddress</a> *&#160;</td>
          <td class="paramname"><em>hints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_network_interface.html#abb962f363d7a7ec29b27844a1e5f7ecc">hostbyname_cb_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>interface_name</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Translate a hostname to the multiple IP addresses (asynchronous) using network interface name. </p>
<p >The hostname may be either a domain name or a dotted IP address. If the hostname is an IP address, no network transactions will be performed.</p>
<p >If no stack-specific <a class="el" href="class_d_n_s.html" title="Base class for DNS provider.">DNS</a> resolution is provided, the hostname will be resolve using a UDP socket on the stack.</p>
<p >Call is non-blocking. Result of the <a class="el" href="class_d_n_s.html" title="Base class for DNS provider.">DNS</a> operation is returned by the callback. If this function returns failure, callback will not be called. In case result is success (IP address was found from <a class="el" href="class_d_n_s.html" title="Base class for DNS provider.">DNS</a> cache), callback will be called before function returns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hostname</td><td>Hostname to resolve. </td></tr>
    <tr><td class="paramname">hints</td><td>Pointer to a <a class="el" href="class_socket_address.html" title="SocketAddress class.">SocketAddress</a> with query parameters. </td></tr>
    <tr><td class="paramname">callback</td><td>Callback that is called for result. </td></tr>
    <tr><td class="paramname">interface_name</td><td>Network interface name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on immediate success, negative error code on immediate failure or a positive unique id that represents the hostname translation operation and can be passed to cancel. </dd></dl>

<p>Implements <a class="el" href="class_d_n_s.html#afd29392442faa47f202cd69ede31dd03">DNS</a>.</p>

</div>
</div>
<a id="a26000e958701f5b35886fac1757c0bf4" name="a26000e958701f5b35886fac1757c0bf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26000e958701f5b35886fac1757c0bf4">&#9670;&#160;</a></span>gethostbyname_async_cancel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> gethostbyname_async_cancel </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cancel asynchronous hostname translation. </p>
<p >When translation is cancelled, callback will not be called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Unique id of the hostname translation operation (returned by gethostbyname_async) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NSAPI_ERROR_OK on success, negative error code on failure. </dd></dl>

<p>Implements <a class="el" href="class_d_n_s.html#a3ba06c19476ec03988c7cd7807823d63">DNS</a>.</p>

</div>
</div>
<a id="a260338652be8fba7b1004bc924fdb781" name="a260338652be8fba7b1004bc924fdb781"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a260338652be8fba7b1004bc924fdb781">&#9670;&#160;</a></span>add_dns_server()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> add_dns_server </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_socket_address.html">SocketAddress</a> &amp;&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>interface_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a domain name server to list of servers to query. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>Address for the dns host. </td></tr>
    <tr><td class="paramname">interface_name</td><td>Network interface name. Currently unused, the server is added for all interfaces. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NSAPI_ERROR_OK on success, negative error code on failure. </dd></dl>

<p>Implements <a class="el" href="class_d_n_s.html#ad222683619bf0a9e32e0499e25cd3a98">DNS</a>.</p>

</div>
</div>
<a id="a0ccb0f7a5af95e76d0dea335ab866047" name="a0ccb0f7a5af95e76d0dea335ab866047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ccb0f7a5af95e76d0dea335ab866047">&#9670;&#160;</a></span>get_dns_server()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> get_dns_server </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_socket_address.html">SocketAddress</a> *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>interface_name</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a domain name server from a list of servers to query. </p>
<p >Returns a <a class="el" href="class_d_n_s.html" title="Base class for DNS provider.">DNS</a> server address for a index. If returns error no more <a class="el" href="class_d_n_s.html" title="Base class for DNS provider.">DNS</a> servers to read.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index of the <a class="el" href="class_d_n_s.html" title="Base class for DNS provider.">DNS</a> server, starts from zero </td></tr>
    <tr><td class="paramname">address</td><td>Destination for the host address </td></tr>
    <tr><td class="paramname">interface_name</td><td>Network interface name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NSAPI_ERROR_OK on success, negative error code on failure </dd></dl>

</div>
</div>
<a id="ab61fc4dcb3f255e327c189325eee1e43" name="ab61fc4dcb3f255e327c189325eee1e43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab61fc4dcb3f255e327c189325eee1e43">&#9670;&#160;</a></span>add_event_listener()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void add_event_listener </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; void(nsapi_event_t, intptr_t)&gt;&#160;</td>
          <td class="paramname"><em>status_cb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add event listener for interface. </p>
<p >This API allows multiple callback to be registered for a single interface. When first called, internal list of event handlers are created and registered to interface through <a class="el" href="class_interface_nanostack.html#a91f2033b4f0a88ffc36eb43c11f3dba6" title="Register callback for status reporting.">attach()</a> API.</p>
<p >Application may only use <a class="el" href="class_interface_nanostack.html#a91f2033b4f0a88ffc36eb43c11f3dba6" title="Register callback for status reporting.">attach()</a> or <a class="el" href="class_network_interface.html#ab61fc4dcb3f255e327c189325eee1e43" title="Add event listener for interface.">add_event_listener()</a> interface. Mixing usage of both leads to undefined behavior.</p>
<dl class="section warning"><dt>Warning</dt><dd>This version of the function does not use the <code>std::nothrow</code> feature. Subsequently, the function may fail to allocate memory and cause a system error. To use the new version with the changes, set "nsapi.add-event-listener-return-change": 1 in the target overrides section in your mbed_app.json file.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">status_cb</td><td>The callback for status changes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad3fb296eec26bfad22eb94c71c9c502d" name="ad3fb296eec26bfad22eb94c71c9c502d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3fb296eec26bfad22eb94c71c9c502d">&#9670;&#160;</a></span>ethInterface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_eth_interface.html">EthInterface</a> * ethInterface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return pointer to an <a class="el" href="class_eth_interface.html" title="Common interface between Ethernet hardware.">EthInterface</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to requested interface type or NULL if this class doesn't implement the interface. </dd></dl>

<p>Reimplemented in <a class="el" href="class_eth_interface.html#a66f1410ed4de66447d3364907abb9094">EthInterface</a>.</p>

<p class="definition">Definition at line <a class="el" href="_network_interface_8h_source.html#l00445">445</a> of file <a class="el" href="_network_interface_8h_source.html">NetworkInterface.h</a>.</p>

</div>
</div>
<a id="a09d99efafd15a9d84a77761372e838d5" name="a09d99efafd15a9d84a77761372e838d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09d99efafd15a9d84a77761372e838d5">&#9670;&#160;</a></span>wifiInterface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_wi_fi_interface.html">WiFiInterface</a> * wifiInterface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return pointer to a <a class="el" href="class_wi_fi_interface.html" title="Common interface between Wi-Fi devices.">WiFiInterface</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to requested interface type or NULL if this class doesn't implement the interface. </dd></dl>

<p>Reimplemented in <a class="el" href="class_wi_fi_interface.html#ac47da289e164960eaeea7f2a4d155003">WiFiInterface</a>.</p>

<p class="definition">Definition at line <a class="el" href="_network_interface_8h_source.html#l00453">453</a> of file <a class="el" href="_network_interface_8h_source.html">NetworkInterface.h</a>.</p>

</div>
</div>
<a id="a65c1b846fba9d9008dafa54b31d4e1a0" name="a65c1b846fba9d9008dafa54b31d4e1a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65c1b846fba9d9008dafa54b31d4e1a0">&#9670;&#160;</a></span>meshInterface() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_mesh_interface.html">MeshInterface</a> * meshInterface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return pointer to a <a class="el" href="class_mesh_interface.html" title="Common interface that is shared between mesh hardware.">MeshInterface</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to requested interface type or NULL if this class doesn't implement the interface. </dd></dl>

<p>Reimplemented in <a class="el" href="class_mesh_interface.html#a1a5135a4e8f7628515bae7599da85269">MeshInterface</a>.</p>

<p class="definition">Definition at line <a class="el" href="_network_interface_8h_source.html#l00461">461</a> of file <a class="el" href="_network_interface_8h_source.html">NetworkInterface.h</a>.</p>

</div>
</div>
<a id="a1a5135a4e8f7628515bae7599da85269" name="a1a5135a4e8f7628515bae7599da85269"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a5135a4e8f7628515bae7599da85269">&#9670;&#160;</a></span>meshInterface() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mesh_interface.html">MeshInterface</a> * meshInterface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return pointer to a <a class="el" href="class_mesh_interface.html" title="Common interface that is shared between mesh hardware.">MeshInterface</a>.  </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to requested interface type or NULL if this class doesn't implement the interface.  </dd></dl>

<p>Reimplemented from <a class="el" href="class_network_interface.html#a65c1b846fba9d9008dafa54b31d4e1a0">NetworkInterface</a>.</p>

<p class="definition">Definition at line <a class="el" href="_mesh_interface_8h_source.html#l00034">34</a> of file <a class="el" href="_mesh_interface_8h_source.html">MeshInterface.h</a>.</p>

</div>
</div>
<a id="ada0ecf739088a765ebc7fbc4181bb375" name="ada0ecf739088a765ebc7fbc4181bb375"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada0ecf739088a765ebc7fbc4181bb375">&#9670;&#160;</a></span>emacInterface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_e_m_a_c_interface.html">EMACInterface</a> * emacInterface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return pointer to an <a class="el" href="class_e_m_a_c_interface.html" title="EMACInterface class Implementation of the NetworkInterface for an EMAC-based driver.">EMACInterface</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to requested interface type or NULL if this class doesn't implement the interface. </dd></dl>

<p>Reimplemented in <a class="el" href="class_e_m_a_c_interface.html#a19fdf1bbd64f27f8189ee586d1f5df24">EMACInterface</a>.</p>

<p class="definition">Definition at line <a class="el" href="_network_interface_8h_source.html#l00469">469</a> of file <a class="el" href="_network_interface_8h_source.html">NetworkInterface.h</a>.</p>

</div>
</div>
<a id="aed55ca6584533439ab78cfd487a2c56f" name="aed55ca6584533439ab78cfd487a2c56f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed55ca6584533439ab78cfd487a2c56f">&#9670;&#160;</a></span>cellularInterface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_cellular_interface.html">CellularInterface</a> * cellularInterface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return pointer to a <a class="el" href="class_cellular_interface.html" title="Common interface that is shared between cellular interfaces.">CellularInterface</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to requested interface type or NULL if this class doesn't implement the interface. </dd></dl>

<p>Reimplemented in <a class="el" href="class_cellular_interface.html#ab345524a30c3c408d28ac5abc64a24c8">CellularInterface</a>.</p>

<p class="definition">Definition at line <a class="el" href="_network_interface_8h_source.html#l00477">477</a> of file <a class="el" href="_network_interface_8h_source.html">NetworkInterface.h</a>.</p>

</div>
</div>
<a id="a123d2c4ef90c33aec33471ac040049c1" name="a123d2c4ef90c33aec33471ac040049c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a123d2c4ef90c33aec33471ac040049c1">&#9670;&#160;</a></span>set_default_parameters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void set_default_parameters </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>defined(DOXYGEN_ONLY) </p>
<p >Set default parameters on an interface.</p>
<p >A network interface instantiated directly or using calls such as <a class="el" href="class_wi_fi_interface.html#a6341e2fee78baf07a8211dd9d323829c" title="Get the default Wi-Fi interface.">WiFiInterface::get_default_instance()</a> is initially unconfigured. This call can be used to set the default parameters that would have been set if the interface had been requested using <a class="el" href="class_network_interface.html#a00c2abaa91df1131639e63d980866244" title="Return the default network interface.">NetworkInterface::get_default_instance()</a> (see nsapi JSON configuration). </p>

<p>Reimplemented in <a class="el" href="class_cellular_interface.html#a68e37f9f2a19ab17cc5c7baebf6293de">CellularInterface</a>, and <a class="el" href="class_wi_fi_interface.html#a68e37f9f2a19ab17cc5c7baebf6293de">WiFiInterface</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_thread_interface.html">ThreadInterface</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>

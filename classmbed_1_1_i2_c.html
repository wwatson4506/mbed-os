<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Mbed OS Reference: I2C Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="mbed-ce_55x55.png"/></td>
  <td id="projectalign">
   <div id="projectname">Mbed OS Reference
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classmbed_1_1_i2_c.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle"><div class="title">I2C Class Reference<div class="ingroups"><a class="el" href="group__mbed-os-public.html">Public API</a> &raquo; <a class="el" href="group__drivers-public-api.html">Drivers</a> &raquo; <a class="el" href="group__drivers-public-api-i2c.html">I2C</a> &raquo; <a class="el" href="group__drivers___i2_c.html">I2C class</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>An I2C Master, used for communicating with I2C slave devices.  
 <a href="classmbed_1_1_i2_c.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_i2_c_8h_source.html">I2C.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for I2C:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classmbed_1_1_i2_c.png" usemap="#I2C_map" alt=""/>
  <map id="I2C_map" name="I2C_map">
<area href="classmbed_1_1_non_copyable.html" alt="NonCopyable&lt; I2C &gt;" shape="rect" coords="0,0,132,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aee84581f841e97427a9f6191665e8006"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_i2_c.html#aee84581f841e97427a9f6191665e8006">Result</a> : int { <a class="el" href="classmbed_1_1_i2_c.html#aee84581f841e97427a9f6191665e8006a41246e9c8691b7e33bc79b345e06b48e">ACK</a> = 0
, <a class="el" href="classmbed_1_1_i2_c.html#aee84581f841e97427a9f6191665e8006a1c986c1141c1160cd172cbde2ce18166">NACK</a>
, <a class="el" href="classmbed_1_1_i2_c.html#aee84581f841e97427a9f6191665e8006aad9dee005a3d0f9137b2ac1e0869f89b">TIMEOUT</a>
, <a class="el" href="classmbed_1_1_i2_c.html#aee84581f841e97427a9f6191665e8006abe760b0a0ddca24057cc39ceb94aff45">OTHER_ERROR</a>
 }</td></tr>
<tr class="memdesc:aee84581f841e97427a9f6191665e8006"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result code for <a class="el" href="classmbed_1_1_i2_c.html" title="An I2C Master, used for communicating with I2C slave devices.">I2C</a> operations.  <a href="classmbed_1_1_i2_c.html#aee84581f841e97427a9f6191665e8006">More...</a><br /></td></tr>
<tr class="separator:aee84581f841e97427a9f6191665e8006"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae03582cfdc35c4471effe2fa9b0d68af"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_i2_c.html#ae03582cfdc35c4471effe2fa9b0d68af">I2C</a> (PinName sda, PinName scl)</td></tr>
<tr class="memdesc:ae03582cfdc35c4471effe2fa9b0d68af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="classmbed_1_1_i2_c.html" title="An I2C Master, used for communicating with I2C slave devices.">I2C</a> Master interface, connected to the specified pins.  <a href="classmbed_1_1_i2_c.html#ae03582cfdc35c4471effe2fa9b0d68af">More...</a><br /></td></tr>
<tr class="separator:ae03582cfdc35c4471effe2fa9b0d68af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79547c09b58602282ee52092afb03372"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_i2_c.html#a79547c09b58602282ee52092afb03372">I2C</a> (const <a class="el" href="structi2c__pinmap__t.html">i2c_pinmap_t</a> &amp;static_pinmap)</td></tr>
<tr class="memdesc:a79547c09b58602282ee52092afb03372"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="classmbed_1_1_i2_c.html" title="An I2C Master, used for communicating with I2C slave devices.">I2C</a> Master interface, connected to the specified pins.  <a href="classmbed_1_1_i2_c.html#a79547c09b58602282ee52092afb03372">More...</a><br /></td></tr>
<tr class="separator:a79547c09b58602282ee52092afb03372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1e803ef5789767c69d9676cafa1fc15"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_i2_c.html#ab1e803ef5789767c69d9676cafa1fc15">frequency</a> (int hz)</td></tr>
<tr class="memdesc:ab1e803ef5789767c69d9676cafa1fc15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the frequency of the <a class="el" href="classmbed_1_1_i2_c.html" title="An I2C Master, used for communicating with I2C slave devices.">I2C</a> interface.  <a href="classmbed_1_1_i2_c.html#ab1e803ef5789767c69d9676cafa1fc15">More...</a><br /></td></tr>
<tr class="separator:ab1e803ef5789767c69d9676cafa1fc15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16a28f7b5087a9493701c2b35cb77f3f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_i2_c.html#aee84581f841e97427a9f6191665e8006">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_i2_c.html#a16a28f7b5087a9493701c2b35cb77f3f">read</a> (int address, char *data, int length, bool repeated=false)</td></tr>
<tr class="memdesc:a16a28f7b5087a9493701c2b35cb77f3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read from an I2C slave.  <a href="classmbed_1_1_i2_c.html#a16a28f7b5087a9493701c2b35cb77f3f">More...</a><br /></td></tr>
<tr class="separator:a16a28f7b5087a9493701c2b35cb77f3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81a5b394ae924d714e8ec6ab4bbdf4f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_i2_c.html#aee84581f841e97427a9f6191665e8006">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_i2_c.html#a81a5b394ae924d714e8ec6ab4bbdf4f2">write</a> (int address, const char *data, int length, bool repeated=false)</td></tr>
<tr class="memdesc:a81a5b394ae924d714e8ec6ab4bbdf4f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write to an I2C slave.  <a href="classmbed_1_1_i2_c.html#a81a5b394ae924d714e8ec6ab4bbdf4f2">More...</a><br /></td></tr>
<tr class="separator:a81a5b394ae924d714e8ec6ab4bbdf4f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedc96a40e844bc2efc8bbef1b0782702"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_i2_c.html#aedc96a40e844bc2efc8bbef1b0782702">start</a> (void)</td></tr>
<tr class="memdesc:aedc96a40e844bc2efc8bbef1b0782702"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a start condition on the I2C bus.  <a href="classmbed_1_1_i2_c.html#aedc96a40e844bc2efc8bbef1b0782702">More...</a><br /></td></tr>
<tr class="separator:aedc96a40e844bc2efc8bbef1b0782702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f8eac061d88e58f11e99759f9609700"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_i2_c.html#a6f8eac061d88e58f11e99759f9609700">read_byte</a> (bool ack)</td></tr>
<tr class="memdesc:a6f8eac061d88e58f11e99759f9609700"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a single byte from the I2C bus.  <a href="classmbed_1_1_i2_c.html#a6f8eac061d88e58f11e99759f9609700">More...</a><br /></td></tr>
<tr class="separator:a6f8eac061d88e58f11e99759f9609700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37956c174106ecc64cae8f87dcf9fc7a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_i2_c.html#a37956c174106ecc64cae8f87dcf9fc7a">read</a> (int ack)</td></tr>
<tr class="memdesc:a37956c174106ecc64cae8f87dcf9fc7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a single byte from the I2C bus.  <a href="classmbed_1_1_i2_c.html#a37956c174106ecc64cae8f87dcf9fc7a">More...</a><br /></td></tr>
<tr class="separator:a37956c174106ecc64cae8f87dcf9fc7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a288f41e052362d155a131a80f1f4c3c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_i2_c.html#aee84581f841e97427a9f6191665e8006">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_i2_c.html#a288f41e052362d155a131a80f1f4c3c0">write_byte</a> (int data)</td></tr>
<tr class="memdesc:a288f41e052362d155a131a80f1f4c3c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a single byte out on the I2C bus.  <a href="classmbed_1_1_i2_c.html#a288f41e052362d155a131a80f1f4c3c0">More...</a><br /></td></tr>
<tr class="separator:a288f41e052362d155a131a80f1f4c3c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07ce23b0e107f3f23e7a12a96c21145e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_i2_c.html#a07ce23b0e107f3f23e7a12a96c21145e">write</a> (int data)</td></tr>
<tr class="memdesc:a07ce23b0e107f3f23e7a12a96c21145e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a single byte out on the I2C bus.  <a href="classmbed_1_1_i2_c.html#a07ce23b0e107f3f23e7a12a96c21145e">More...</a><br /></td></tr>
<tr class="separator:a07ce23b0e107f3f23e7a12a96c21145e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacf6bf8e121fea8b0a92d7197b73fe27"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_i2_c.html#aacf6bf8e121fea8b0a92d7197b73fe27">stop</a> (void)</td></tr>
<tr class="memdesc:aacf6bf8e121fea8b0a92d7197b73fe27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a stop condition on the I2C bus.  <a href="classmbed_1_1_i2_c.html#aacf6bf8e121fea8b0a92d7197b73fe27">More...</a><br /></td></tr>
<tr class="separator:aacf6bf8e121fea8b0a92d7197b73fe27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad67df83ace240f53c1276e24a37ff84c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_i2_c.html#ad67df83ace240f53c1276e24a37ff84c">lock</a> (void)</td></tr>
<tr class="memdesc:ad67df83ace240f53c1276e24a37ff84c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquire exclusive access to this I2C bus.  <a href="classmbed_1_1_i2_c.html#ad67df83ace240f53c1276e24a37ff84c">More...</a><br /></td></tr>
<tr class="separator:ad67df83ace240f53c1276e24a37ff84c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d882b4e464e4f4bd59eab6c75297bda"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_i2_c.html#a5d882b4e464e4f4bd59eab6c75297bda">unlock</a> (void)</td></tr>
<tr class="memdesc:a5d882b4e464e4f4bd59eab6c75297bda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release exclusive access to this I2C bus.  <a href="classmbed_1_1_i2_c.html#a5d882b4e464e4f4bd59eab6c75297bda">More...</a><br /></td></tr>
<tr class="separator:a5d882b4e464e4f4bd59eab6c75297bda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a273f3dc6765aea3f2bdca0e70ae9697c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_i2_c.html#a273f3dc6765aea3f2bdca0e70ae9697c">transfer</a> (int address, const char *tx_buffer, int tx_length, char *rx_buffer, int rx_length, const <a class="el" href="classmbed_1_1_callback.html">event_callback_t</a> &amp;<a class="el" href="group__platform___callback.html#ga90e30db9c535d448cd949f7f55bb8f31">callback</a>, int event=<a class="el" href="group__hal___i2_c_events.html#ga86242d44f90efd0b4ebdb0e587559d78">I2C_EVENT_TRANSFER_COMPLETE</a>, bool repeated=false)</td></tr>
<tr class="memdesc:a273f3dc6765aea3f2bdca0e70ae9697c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start nonblocking I2C transfer.  <a href="classmbed_1_1_i2_c.html#a273f3dc6765aea3f2bdca0e70ae9697c">More...</a><br /></td></tr>
<tr class="separator:a273f3dc6765aea3f2bdca0e70ae9697c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90253410d768f60403698f5f383d1931"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_i2_c.html#a90253410d768f60403698f5f383d1931">abort_transfer</a> ()</td></tr>
<tr class="memdesc:a90253410d768f60403698f5f383d1931"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abort the ongoing <a class="el" href="classmbed_1_1_i2_c.html" title="An I2C Master, used for communicating with I2C slave devices.">I2C</a> transfer.  <a href="classmbed_1_1_i2_c.html#a90253410d768f60403698f5f383d1931">More...</a><br /></td></tr>
<tr class="separator:a90253410d768f60403698f5f383d1931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a273c521d9f320d5c1b84975af701890f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_i2_c.html#aee84581f841e97427a9f6191665e8006">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_i2_c.html#a273c521d9f320d5c1b84975af701890f">transfer_and_wait</a> (int address, const char *tx_buffer, int tx_length, char *rx_buffer, int rx_length, rtos::Kernel::Clock::duration_u32 timeout=<a class="el" href="namespacertos_1_1_kernel.html#a29baed0762de3912b6b7592150a9498e">rtos::Kernel::wait_for_u32_forever</a>, bool repeated=false)</td></tr>
<tr class="memdesc:a273c521d9f320d5c1b84975af701890f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start I2C transfer and wait until it is complete.  <a href="classmbed_1_1_i2_c.html#a273c521d9f320d5c1b84975af701890f">More...</a><br /></td></tr>
<tr class="separator:a273c521d9f320d5c1b84975af701890f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >An I2C Master, used for communicating with I2C slave devices. </p>
<p >There are three different forms of the I2C API usable via this class: </p><ul>
<li>
Transaction-based I2C </li>
<li>
Single-byte I2C </li>
<li>
Asynchronous I2C </li>
</ul>
<p >All three of these APIs let you execute I2C operations, but they work differently.</p>
<h1>Transaction-Based API</h1>
<p >The simplest API, which should be appropriate for most use cases, is the transaction-based API, which is accessed through the <a class="el" href="classmbed_1_1_i2_c.html#a16a28f7b5087a9493701c2b35cb77f3f">read() </a> and the <a class="el" href="classmbed_1_1_i2_c.html#a81a5b394ae924d714e8ec6ab4bbdf4f2">write() </a> functions. These functions execute an entire I2C transaction (the start condition, address, data bytes, and stop condition) in a single function call.</p>
<p >The bytes to be read/written are passed in through an array, which requires that you can predict the size of the data ahead of time. If this information is not known, you may want to use the single-byte API instead (see below).</p>
<p >Example of using the transaction-based API to read the temperature from an LM75BD: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;mbed.h&quot;</span></div>
<div class="line"><a class="code hl_class" href="classmbed_1_1_i2_c.html">I2C</a> i2c(I2C_SDA , I2C_SCL);</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> addr7bit = 0x48;      <span class="comment">// 7-bit I2C address</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> addr8bit = 0x48 &lt;&lt; 1; <span class="comment">// 8-bit I2C address, 0x90</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="keywordtype">char</span> cmd[2];</div>
<div class="line">    <span class="keywordflow">while</span> (1) {</div>
<div class="line">        cmd[0] = 0x01;</div>
<div class="line">        cmd[1] = 0x00;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// read and write takes the 8-bit version of the address.</span></div>
<div class="line">        <span class="comment">// set up configuration register (at 0x01)</span></div>
<div class="line">        <a class="code hl_enumeration" href="classmbed_1_1_i2_c.html#aee84581f841e97427a9f6191665e8006">I2C::Result</a> result = i2c.write(addr8bit, cmd, 2);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span>(result != <a class="code hl_enumvalue" href="classmbed_1_1_i2_c.html#aee84581f841e97427a9f6191665e8006a41246e9c8691b7e33bc79b345e06b48e">I2C::ACK</a>)</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// Chip not accessible, handle error....</span></div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        ThisThread::sleep_for(500);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// read temperature register</span></div>
<div class="line">        cmd[0] = 0x00;</div>
<div class="line">        i2c.write(addr8bit, cmd, 1, <span class="keyword">true</span>); <span class="comment">// Set repeated to true so that we don&#39;t give up the bus after this transaction</span></div>
<div class="line">        i2c.read(addr8bit | 1, cmd, 2);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordtype">float</span> tmp = (float((cmd[0]&lt;&lt;8)|cmd[1]) / 256.0);</div>
<div class="line">        printf(<span class="stringliteral">&quot;Temp = %.2f\n&quot;</span>, tmp);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="ttc" id="aclassmbed_1_1_i2_c_html"><div class="ttname"><a href="classmbed_1_1_i2_c.html">mbed::I2C</a></div><div class="ttdoc">An I2C Master, used for communicating with I2C slave devices.</div><div class="ttdef"><b>Definition:</b> <a href="_i2_c_8h_source.html#l00211">I2C.h:211</a></div></div>
<div class="ttc" id="aclassmbed_1_1_i2_c_html_aee84581f841e97427a9f6191665e8006"><div class="ttname"><a href="classmbed_1_1_i2_c.html#aee84581f841e97427a9f6191665e8006">mbed::I2C::Result</a></div><div class="ttdeci">Result</div><div class="ttdoc">Result code for I2C operations.</div><div class="ttdef"><b>Definition:</b> <a href="_i2_c_8h_source.html#l00218">I2C.h:218</a></div></div>
<div class="ttc" id="aclassmbed_1_1_i2_c_html_aee84581f841e97427a9f6191665e8006a41246e9c8691b7e33bc79b345e06b48e"><div class="ttname"><a href="classmbed_1_1_i2_c.html#aee84581f841e97427a9f6191665e8006a41246e9c8691b7e33bc79b345e06b48e">mbed::I2C::ACK</a></div><div class="ttdeci">@ ACK</div><div class="ttdoc">ACK was received.</div><div class="ttdef"><b>Definition:</b> <a href="_i2_c_8h_source.html#l00220">I2C.h:220</a></div></div>
</div><!-- fragment --><h1>Single-Byte API</h1>
<p >The single-byte API consists of the <a class="el" href="classmbed_1_1_i2_c.html#aedc96a40e844bc2efc8bbef1b0782702">start() </a>, <a class="el" href="classmbed_1_1_i2_c.html#a288f41e052362d155a131a80f1f4c3c0">write_byte() </a>, <a class="el" href="classmbed_1_1_i2_c.html#a6f8eac061d88e58f11e99759f9609700">read_byte() </a>, and <a class="el" href="classmbed_1_1_i2_c.html#aacf6bf8e121fea8b0a92d7197b73fe27">stop() </a> functions. With the single-byte API, you have manual control over each condition and data byte put onto the <a class="el" href="classmbed_1_1_i2_c.html" title="An I2C Master, used for communicating with I2C slave devices.">I2C</a> bus. This is useful for dealing with devices which can return variable amounts of data in one <a class="el" href="classmbed_1_1_i2_c.html" title="An I2C Master, used for communicating with I2C slave devices.">I2C</a> operation, or when you don't want to create buffers to store the data. However, this API is more verbose than the transaction-based API and will have a bit more overhead since there's more code executing per byte.</p>
<p >The following is an example that accomplishes the same thing as the above code, but using the single-byte API. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;mbed.h&quot;</span></div>
<div class="line"><a class="code hl_class" href="classmbed_1_1_i2_c.html">I2C</a> i2c(I2C_SDA , I2C_SCL);</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> addr7bit = 0x48;      <span class="comment">// 7-bit I2C address</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> addr8bit = 0x48 &lt;&lt; 1; <span class="comment">// 8-bit I2C address, 0x90</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="keywordflow">while</span> (1) {</div>
<div class="line">        <span class="comment">// read and write takes the 8-bit version of the address.</span></div>
<div class="line">        <span class="comment">// set up configuration register (at 0x01)</span></div>
<div class="line">        i2c.lock();</div>
<div class="line">        i2c.start();</div>
<div class="line">        <a class="code hl_enumeration" href="classmbed_1_1_i2_c.html#aee84581f841e97427a9f6191665e8006">I2C::Result</a> result = i2c.write_byte(addr8bit); <span class="comment">// Write address, LSBit low to indicate write</span></div>
<div class="line">        i2c.write_byte(0x01);</div>
<div class="line">        i2c.write_byte(0x00);</div>
<div class="line">        i2c.stop();</div>
<div class="line">        i2c.unlock();</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span>(result != <a class="code hl_enumvalue" href="classmbed_1_1_i2_c.html#aee84581f841e97427a9f6191665e8006a41246e9c8691b7e33bc79b345e06b48e">I2C::ACK</a>)</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// Chip not accessible, handle error....</span></div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        ThisThread::sleep_for(500);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Set register to read</span></div>
<div class="line">        i2c.lock();</div>
<div class="line">        i2c.start();</div>
<div class="line">        i2c.write_byte(addr8bit); <span class="comment">// Write address</span></div>
<div class="line">        i2c.write_byte(0x00);</div>
<div class="line">        <span class="comment">// To create a repeated start condition, we do not call stop() here</span></div>
<div class="line"> </div>
<div class="line">        i2c.start();</div>
<div class="line">        i2c.write_byte(addr8bit | 1); <span class="comment">// Write address, LSBit high to indicate read</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Read the two byte temperature word</span></div>
<div class="line">        uint16_t temperatureBinary = 0;</div>
<div class="line">        temperatureBinary |= <span class="keyword">static_cast&lt;</span>uint16_t<span class="keyword">&gt;</span>(i2c.read_byte(<span class="keyword">true</span>)) &lt;&lt; 8;</div>
<div class="line">        temperatureBinary |= <span class="keyword">static_cast&lt;</span>uint16_t<span class="keyword">&gt;</span>(i2c.read_byte(<span class="keyword">false</span>)); <span class="comment">// send NACK to indicate last byte</span></div>
<div class="line">        i2c.stop();</div>
<div class="line">        i2c.unlock();</div>
<div class="line"> </div>
<div class="line">        <span class="keywordtype">float</span> tmp = (float(temperatureBinary) / 256.0);</div>
<div class="line">        printf(<span class="stringliteral">&quot;Temp = %.2f\n&quot;</span>, tmp);</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section attention"><dt>Attention</dt><dd>If a single <a class="el" href="classmbed_1_1_i2_c.html" title="An I2C Master, used for communicating with I2C slave devices.">I2C</a> object is being shared among multiple threads, you should surround usage of the single-byte API with <a class="el" href="classmbed_1_1_i2_c.html#ad67df83ace240f53c1276e24a37ff84c">lock() </a> and <a class="el" href="classmbed_1_1_i2_c.html#a5d882b4e464e4f4bd59eab6c75297bda">unlock() </a>. This ensures that a transaction by one thread is not interrupted by another. It may also improve performance because the backing mutex will not need to be locked for each byte.</dd></dl>
<h1>Asynchronous API</h1>
<p >The asynchronous API allows you to run I2C operations in the background. This API is only available if your device has the I2C_ASYNCH feature. To use this API, use <a class="el" href="classmbed_1_1_i2_c.html#a273f3dc6765aea3f2bdca0e70ae9697c">transfer() </a> to start an operation and <a class="el" href="classmbed_1_1_i2_c.html#a90253410d768f60403698f5f383d1931">abort_transfer() </a> to stop it. Alternately, use the <a class="el" href="classmbed_1_1_i2_c.html#a273c521d9f320d5c1b84975af701890f">transfer_and_wait() </a> function to block the current thread until the transfer finishes.</p>
<p >Some devices implement these features using DMA, others use interrupts, so be mindful that there may still be significant CPU usage if you have multiple and/or high-rate transfers going on.</p>
<h1>A Note about Addressing</h1>
<p >Most I2C devices make use of 7-bit addresses (see <a href="https://www.i2c-bus.org/addressing/">here</a> for details). Mbed OS, however, works with addresses in 8-bit format, where the least significant bit specifies if the transaction is a read (1) or a write (0). Due to this, you will generally need to use bitshifts and bitwise ORs when passing addresses to <a class="el" href="classmbed_1_1_i2_c.html" title="An I2C Master, used for communicating with I2C slave devices.">I2C</a> functions. See the documentation on each function for details.</p>
<p >I2C also has a <a href="https://www.i2c-bus.org/addressing/10-bit-addressing/">10-bit addressing mode</a>, where the address is sent in two physical bytes on the bus. Some, but not all, Mbed targets support this mode &ndash; refer to your MCU datasheet and your target's HAL code for details. For 10-bit addresses, use the same format to pass them to <a class="el" href="classmbed_1_1_i2_c.html" title="An I2C Master, used for communicating with I2C slave devices.">I2C</a> functions &ndash; shift them left by one and set the LSBit to indicate the read/write direction. On MCUs that do not natively support 10-bit addressing, you can emulate support by using the single-byte API to send two address bytes; see the linked page above for details.</p>
<h1>Other Info</h1>
<p >The <a class="el" href="classmbed_1_1_i2_c.html" title="An I2C Master, used for communicating with I2C slave devices.">I2C</a> class is thread-safe, and uses a mutex to prevent multiple threads from using it at the same time.</p>
<dl class="section warning"><dt>Warning</dt><dd>Mbed OS requires that you only create one instance of the <a class="el" href="classmbed_1_1_i2_c.html" title="An I2C Master, used for communicating with I2C slave devices.">I2C</a> class per physical I2C bus on your chip. This means that if you have multiple sensors connected together on a bus, you must create one <a class="el" href="classmbed_1_1_i2_c.html" title="An I2C Master, used for communicating with I2C slave devices.">I2C</a> object at the top level and pass it in to the drivers for each sensor. Violating this directive will cause undefined behavior in your code.</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Due to how I2C works, if multiple devices are sharing a bus which support different I2C speeds, you cannot go faster than the maximum bus speed of any of the devices. Otherwise, slower devices may misinterpret messages that are too fast for them and cause interference on the bus. For example, if you have two 400kHz devices and one 100kHz device on a bus, you must run the entire bus at 100kHz! </dd></dl>

<p class="definition">Definition at line <a class="el" href="_i2_c_8h_source.html#l00211">211</a> of file <a class="el" href="_i2_c_8h_source.html">I2C.h</a>.</p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="aee84581f841e97427a9f6191665e8006" name="aee84581f841e97427a9f6191665e8006"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee84581f841e97427a9f6191665e8006">&#9670;&#160;</a></span>Result</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classmbed_1_1_i2_c.html#aee84581f841e97427a9f6191665e8006">Result</a> : int</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Result code for <a class="el" href="classmbed_1_1_i2_c.html" title="An I2C Master, used for communicating with I2C slave devices.">I2C</a> operations. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aee84581f841e97427a9f6191665e8006a41246e9c8691b7e33bc79b345e06b48e" name="aee84581f841e97427a9f6191665e8006a41246e9c8691b7e33bc79b345e06b48e"></a>ACK&#160;</td><td class="fielddoc"><p >ACK was received. </p>
</td></tr>
<tr><td class="fieldname"><a id="aee84581f841e97427a9f6191665e8006a1c986c1141c1160cd172cbde2ce18166" name="aee84581f841e97427a9f6191665e8006a1c986c1141c1160cd172cbde2ce18166"></a>NACK&#160;</td><td class="fielddoc"><p >NACK was received. </p>
</td></tr>
<tr><td class="fieldname"><a id="aee84581f841e97427a9f6191665e8006aad9dee005a3d0f9137b2ac1e0869f89b" name="aee84581f841e97427a9f6191665e8006aad9dee005a3d0f9137b2ac1e0869f89b"></a>TIMEOUT&#160;</td><td class="fielddoc"><p ><a class="el" href="classmbed_1_1_timeout.html">Timeout</a> waiting for <a class="el" href="classmbed_1_1_i2_c.html" title="An I2C Master, used for communicating with I2C slave devices.">I2C</a> hardware. </p>
</td></tr>
<tr><td class="fieldname"><a id="aee84581f841e97427a9f6191665e8006abe760b0a0ddca24057cc39ceb94aff45" name="aee84581f841e97427a9f6191665e8006abe760b0a0ddca24057cc39ceb94aff45"></a>OTHER_ERROR&#160;</td><td class="fielddoc"><p >Other error in <a class="el" href="classmbed_1_1_i2_c.html" title="An I2C Master, used for communicating with I2C slave devices.">I2C</a> operation. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_i2_c_8h_source.html#l00218">218</a> of file <a class="el" href="_i2_c_8h_source.html">I2C.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae03582cfdc35c4471effe2fa9b0d68af" name="ae03582cfdc35c4471effe2fa9b0d68af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae03582cfdc35c4471effe2fa9b0d68af">&#9670;&#160;</a></span>I2C() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_i2_c.html">I2C</a> </td>
          <td>(</td>
          <td class="paramtype">PinName&#160;</td>
          <td class="paramname"><em>sda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PinName&#160;</td>
          <td class="paramname"><em>scl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an <a class="el" href="classmbed_1_1_i2_c.html" title="An I2C Master, used for communicating with I2C slave devices.">I2C</a> Master interface, connected to the specified pins. </p>
<p >The new object defaults to 100kHz speed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sda</td><td><a class="el" href="classmbed_1_1_i2_c.html" title="An I2C Master, used for communicating with I2C slave devices.">I2C</a> data line pin </td></tr>
    <tr><td class="paramname">scl</td><td><a class="el" href="classmbed_1_1_i2_c.html" title="An I2C Master, used for communicating with I2C slave devices.">I2C</a> clock line pin </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a79547c09b58602282ee52092afb03372" name="a79547c09b58602282ee52092afb03372"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79547c09b58602282ee52092afb03372">&#9670;&#160;</a></span>I2C() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_i2_c.html">I2C</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structi2c__pinmap__t.html">i2c_pinmap_t</a> &amp;&#160;</td>
          <td class="paramname"><em>static_pinmap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an <a class="el" href="classmbed_1_1_i2_c.html" title="An I2C Master, used for communicating with I2C slave devices.">I2C</a> Master interface, connected to the specified pins. </p>
<p >The new object defaults to 100kHz speed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">static_pinmap</td><td>reference to structure which holds static pinmap. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab1e803ef5789767c69d9676cafa1fc15" name="ab1e803ef5789767c69d9676cafa1fc15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1e803ef5789767c69d9676cafa1fc15">&#9670;&#160;</a></span>frequency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void frequency </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>hz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the frequency of the <a class="el" href="classmbed_1_1_i2_c.html" title="An I2C Master, used for communicating with I2C slave devices.">I2C</a> interface. </p>
<p >If you do not call this function, the <a class="el" href="classmbed_1_1_i2_c.html" title="An I2C Master, used for communicating with I2C slave devices.">I2C</a> will run at 100kHz speed.</p>
<p >Note: Some underlying HALs only support a very limited set of common <a class="el" href="classmbed_1_1_i2_c.html" title="An I2C Master, used for communicating with I2C slave devices.">I2C</a> frequencies, such as 100kHz and 400kHz. Other implementations support all frequencies. If the frequency you set is not supported, you will get an assertion failure after calling this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hz</td><td>The bus frequency in hertz </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a16a28f7b5087a9493701c2b35cb77f3f" name="a16a28f7b5087a9493701c2b35cb77f3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16a28f7b5087a9493701c2b35cb77f3f">&#9670;&#160;</a></span>read() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_i2_c.html#aee84581f841e97427a9f6191665e8006">Result</a> read </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>repeated</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read from an I2C slave. </p>
<p >Performs a complete read transaction. The least significant bit of the address must be 1 to indicate a read.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>8/11-bit <a class="el" href="classmbed_1_1_i2_c.html" title="An I2C Master, used for communicating with I2C slave devices.">I2C</a> slave address [ (7 or 10 bit addr &lt;&lt; 1) | 1 ] </td></tr>
    <tr><td class="paramname">data</td><td>Pointer to the byte-array to read data in to </td></tr>
    <tr><td class="paramname">length</td><td>Number of bytes to read </td></tr>
    <tr><td class="paramname">repeated</td><td>Set up for a repeated start. If true, the Mbed processor does not relinquish the bus after this read operation. You may then call <a class="el" href="classmbed_1_1_i2_c.html#a81a5b394ae924d714e8ec6ab4bbdf4f2" title="Write to an I2C slave.">write()</a>, <a class="el" href="classmbed_1_1_i2_c.html#a16a28f7b5087a9493701c2b35cb77f3f" title="Read from an I2C slave.">read()</a>, or <a class="el" href="classmbed_1_1_i2_c.html#aedc96a40e844bc2efc8bbef1b0782702" title="Creates a start condition on the I2C bus.">start()</a> again to start another operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result enum describing whether the <a class="el" href="classmbed_1_1_i2_c.html" title="An I2C Master, used for communicating with I2C slave devices.">I2C</a> transaction succeeded or failed </dd></dl>

</div>
</div>
<a id="a81a5b394ae924d714e8ec6ab4bbdf4f2" name="a81a5b394ae924d714e8ec6ab4bbdf4f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81a5b394ae924d714e8ec6ab4bbdf4f2">&#9670;&#160;</a></span>write() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_i2_c.html#aee84581f841e97427a9f6191665e8006">Result</a> write </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>repeated</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write to an I2C slave. </p>
<p >Performs a complete write transaction. The least significant bit of the address must be 0 to indicate a write.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>8/11-bit <a class="el" href="classmbed_1_1_i2_c.html" title="An I2C Master, used for communicating with I2C slave devices.">I2C</a> slave address [ (7 or 10 bit addr &lt;&lt; 1) | 0 ] </td></tr>
    <tr><td class="paramname">data</td><td>Pointer to the byte-array data to send </td></tr>
    <tr><td class="paramname">length</td><td>Number of bytes to send </td></tr>
    <tr><td class="paramname">repeated</td><td>Set up for a repeated start. If true, the Mbed processor does not relinquish the bus after this write operation. You may then call <a class="el" href="classmbed_1_1_i2_c.html#a81a5b394ae924d714e8ec6ab4bbdf4f2" title="Write to an I2C slave.">write()</a>, <a class="el" href="classmbed_1_1_i2_c.html#a16a28f7b5087a9493701c2b35cb77f3f" title="Read from an I2C slave.">read()</a>, or <a class="el" href="classmbed_1_1_i2_c.html#aedc96a40e844bc2efc8bbef1b0782702" title="Creates a start condition on the I2C bus.">start()</a> again to start another operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result enum describing whether the <a class="el" href="classmbed_1_1_i2_c.html" title="An I2C Master, used for communicating with I2C slave devices.">I2C</a> transaction succeeded or failed </dd></dl>

</div>
</div>
<a id="aedc96a40e844bc2efc8bbef1b0782702" name="aedc96a40e844bc2efc8bbef1b0782702"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedc96a40e844bc2efc8bbef1b0782702">&#9670;&#160;</a></span>start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void start </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a start condition on the I2C bus. </p>
<p >After calling this function, you should call <a class="el" href="classmbed_1_1_i2_c.html#a288f41e052362d155a131a80f1f4c3c0">write_byte()</a> to send the I2C address. </p>

</div>
</div>
<a id="a6f8eac061d88e58f11e99759f9609700" name="a6f8eac061d88e58f11e99759f9609700"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f8eac061d88e58f11e99759f9609700">&#9670;&#160;</a></span>read_byte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int read_byte </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ack</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a single byte from the I2C bus. </p>
<p >After calling this function, you may call it again to read another byte from the slave. Alternately, you may call <a class="el" href="classmbed_1_1_i2_c.html#aacf6bf8e121fea8b0a92d7197b73fe27">stop()</a> to stop the current transaction, or <a class="el" href="classmbed_1_1_i2_c.html#aedc96a40e844bc2efc8bbef1b0782702">start()</a> to start a new transaction.</p>
<p >Note: Reads are not acknowledged by the slave device in <a class="el" href="classmbed_1_1_i2_c.html" title="An I2C Master, used for communicating with I2C slave devices.">I2C</a>, which is why this function does not return an ACK/NACK result.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ack</td><td>indicates if the byte is to be acknowledged (true = acknowledge). Use false to indicate to the slave that you don't want to read any more data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the byte read, or -1 on error. </dd></dl>

</div>
</div>
<a id="a37956c174106ecc64cae8f87dcf9fc7a" name="a37956c174106ecc64cae8f87dcf9fc7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37956c174106ecc64cae8f87dcf9fc7a">&#9670;&#160;</a></span>read() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int read </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ack</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a single byte from the I2C bus. </p>
<p >This function is a legacy alias for <a class="el" href="classmbed_1_1_i2_c.html#a6f8eac061d88e58f11e99759f9609700">read_byte()</a></p>
<p >After calling this function, you may call it again to read another byte from the slave. Alternately, you may call <a class="el" href="classmbed_1_1_i2_c.html#aacf6bf8e121fea8b0a92d7197b73fe27">stop()</a> to stop the current transaction, or <a class="el" href="classmbed_1_1_i2_c.html#aedc96a40e844bc2efc8bbef1b0782702">start()</a> to start a new transaction.</p>
<p >Note: Reads are not acknowledged by the slave device in <a class="el" href="classmbed_1_1_i2_c.html" title="An I2C Master, used for communicating with I2C slave devices.">I2C</a>, which is why this function does not return an ACK/NACK result.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ack</td><td>indicates if the byte is to be acknowledged (1 = acknowledge)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the byte read </dd></dl>

<p class="definition">Definition at line <a class="el" href="_i2_c_8h_source.html#l00323">323</a> of file <a class="el" href="_i2_c_8h_source.html">I2C.h</a>.</p>

</div>
</div>
<a id="a288f41e052362d155a131a80f1f4c3c0" name="a288f41e052362d155a131a80f1f4c3c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a288f41e052362d155a131a80f1f4c3c0">&#9670;&#160;</a></span>write_byte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_i2_c.html#aee84581f841e97427a9f6191665e8006">Result</a> write_byte </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a single byte out on the I2C bus. </p>
<p >The very first <a class="el" href="classmbed_1_1_i2_c.html#a288f41e052362d155a131a80f1f4c3c0" title="Write a single byte out on the I2C bus.">write_byte()</a> call after calling <a class="el" href="classmbed_1_1_i2_c.html#aedc96a40e844bc2efc8bbef1b0782702" title="Creates a start condition on the I2C bus.">start()</a> is used to set up the slave address.</p>
<p >After calling this function, you may call <a class="el" href="classmbed_1_1_i2_c.html#a288f41e052362d155a131a80f1f4c3c0">write_byte()</a> again to write bytes in a write operation, or <a class="el" href="classmbed_1_1_i2_c.html#a6f8eac061d88e58f11e99759f9609700">read_byte()</a> to read bytes in a read operation. Once done, call <a class="el" href="classmbed_1_1_i2_c.html#aacf6bf8e121fea8b0a92d7197b73fe27">stop()</a> to stop the current transaction or <a class="el" href="classmbed_1_1_i2_c.html#aedc96a40e844bc2efc8bbef1b0782702">start()</a> to start a new transaction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>data to write out on bus. Note: This is an int, not a uint8_t, to support addressing modes with more than 7 bits.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result enum describing whether the <a class="el" href="classmbed_1_1_i2_c.html" title="An I2C Master, used for communicating with I2C slave devices.">I2C</a> byte was acknowledged or not </dd></dl>

</div>
</div>
<a id="a07ce23b0e107f3f23e7a12a96c21145e" name="a07ce23b0e107f3f23e7a12a96c21145e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07ce23b0e107f3f23e7a12a96c21145e">&#9670;&#160;</a></span>write() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int write </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a single byte out on the I2C bus. </p>
<p >Deprecated version of <a class="el" href="classmbed_1_1_i2_c.html#a288f41e052362d155a131a80f1f4c3c0">write_byte()</a>, with a legacy return code format.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>data to write out on bus</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'0' - NAK was received '1' - ACK was received, '2' - timeout </dd></dl>

</div>
</div>
<a id="aacf6bf8e121fea8b0a92d7197b73fe27" name="aacf6bf8e121fea8b0a92d7197b73fe27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacf6bf8e121fea8b0a92d7197b73fe27">&#9670;&#160;</a></span>stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stop </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a stop condition on the I2C bus. </p>
<p >This puts the bus back into an idle state where new transactions can be initiated by this device or others. </p>

</div>
</div>
<a id="ad67df83ace240f53c1276e24a37ff84c" name="ad67df83ace240f53c1276e24a37ff84c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad67df83ace240f53c1276e24a37ff84c">&#9670;&#160;</a></span>lock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void lock </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Acquire exclusive access to this I2C bus. </p>

</div>
</div>
<a id="a5d882b4e464e4f4bd59eab6c75297bda" name="a5d882b4e464e4f4bd59eab6c75297bda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d882b4e464e4f4bd59eab6c75297bda">&#9670;&#160;</a></span>unlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void unlock </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Release exclusive access to this I2C bus. </p>

</div>
</div>
<a id="a273f3dc6765aea3f2bdca0e70ae9697c" name="a273f3dc6765aea3f2bdca0e70ae9697c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a273f3dc6765aea3f2bdca0e70ae9697c">&#9670;&#160;</a></span>transfer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int transfer </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>tx_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tx_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>rx_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rx_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmbed_1_1_callback.html">event_callback_t</a> &amp;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>event</em> = <code><a class="el" href="group__hal___i2_c_events.html#ga86242d44f90efd0b4ebdb0e587559d78">I2C_EVENT_TRANSFER_COMPLETE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>repeated</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start nonblocking I2C transfer. </p>
<p >The I2C peripheral will begin a transmit and/or receive operation in the background. If only a transmit or receive buffer is specified, only a transmit or receive will be done. If both buffers are specified, first the transmission is done to the given slave address, then the specified number of bytes are received.</p>
<p >If you wish to find out when the transfer is done, pass a callback function to the callback argument and set the event argument to the events you wish to receive. This callback will be called when the transfer completes or errors out. Be careful: if you only request the I2C_EVENT_TRANSFER_COMPLETE event, and the transfer errors, the callback will never be called.</p>
<p >Internally, the chip vendor may implement this function using either DMA or interrupts.</p>
<p >This function locks the deep sleep until any event has occurred.</p>
<p >You may not call any other functions on this class instance until the transfer is complete, has errored, or is aborted. Trying to start multiple transfers at once will return an error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>8/11 bit I2C slave address </td></tr>
    <tr><td class="paramname">tx_buffer</td><td>The TX buffer with data to be transferred. May be nullptr if tx_length is 0. </td></tr>
    <tr><td class="paramname">tx_length</td><td>The length of TX buffer in bytes. If 0, no transmission is done. </td></tr>
    <tr><td class="paramname">rx_buffer</td><td>The RX buffer, which is used for received data. May be nullptr if tx_length is 0. </td></tr>
    <tr><td class="paramname">rx_length</td><td>The length of RX buffer in bytes If 0, no reception is done. </td></tr>
    <tr><td class="paramname">event</td><td>The logical OR of events to modify. May be I2C_EVENT_ALL, or some combination of the flags I2C_EVENT_ERROR, I2C_EVENT_ERROR_NO_SLAVE, I2C_EVENT_TRANSFER_COMPLETE, or I2C_EVENT_TRANSFER_EARLY_NACK </td></tr>
    <tr><td class="paramname">callback</td><td>The event callback function </td></tr>
    <tr><td class="paramname">repeated</td><td>Set up for a repeated start. If true, the Mbed processor does not relinquish the bus after this write operation. You may then call <a class="el" href="classmbed_1_1_i2_c.html#a81a5b394ae924d714e8ec6ab4bbdf4f2" title="Write to an I2C slave.">write()</a>, <a class="el" href="classmbed_1_1_i2_c.html#a16a28f7b5087a9493701c2b35cb77f3f" title="Read from an I2C slave.">read()</a>, or <a class="el" href="classmbed_1_1_i2_c.html#aedc96a40e844bc2efc8bbef1b0782702" title="Creates a start condition on the I2C bus.">start()</a> again to start another operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero if the transfer has started, or -1 if <a class="el" href="classmbed_1_1_i2_c.html" title="An I2C Master, used for communicating with I2C slave devices.">I2C</a> peripheral is busy </dd></dl>

</div>
</div>
<a id="a90253410d768f60403698f5f383d1931" name="a90253410d768f60403698f5f383d1931"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90253410d768f60403698f5f383d1931">&#9670;&#160;</a></span>abort_transfer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void abort_transfer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Abort the ongoing <a class="el" href="classmbed_1_1_i2_c.html" title="An I2C Master, used for communicating with I2C slave devices.">I2C</a> transfer. </p>

</div>
</div>
<a id="a273c521d9f320d5c1b84975af701890f" name="a273c521d9f320d5c1b84975af701890f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a273c521d9f320d5c1b84975af701890f">&#9670;&#160;</a></span>transfer_and_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_i2_c.html#aee84581f841e97427a9f6191665e8006">Result</a> transfer_and_wait </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>tx_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tx_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>rx_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rx_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rtos::Kernel::Clock::duration_u32&#160;</td>
          <td class="paramname"><em>timeout</em> = <code><a class="el" href="namespacertos_1_1_kernel.html#a29baed0762de3912b6b7592150a9498e">rtos::Kernel::wait_for_u32_forever</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>repeated</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start I2C transfer and wait until it is complete. </p>
<p >Like the transactional API this blocks the current thread, however all work is done in the background and other threads may execute.</p>
<p >The I2C peripheral will begin a transmit and/or receive operation in the background. If only a transmit or receive buffer is specified, only a transmit or receive will be done. If both buffers are specified, first the transmission is done to the given slave address, then the specified number of bytes are received.</p>
<p >Internally, the chip vendor may implement this function using either DMA or interrupts.</p>
<p >This function locks the deep sleep until it returns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>8/11 bit I2C slave address </td></tr>
    <tr><td class="paramname">tx_buffer</td><td>The TX buffer with data to be transferred. May be nullptr if tx_length is 0. </td></tr>
    <tr><td class="paramname">tx_length</td><td>The length of TX buffer in bytes. If 0, no transmission is done. </td></tr>
    <tr><td class="paramname">rx_buffer</td><td>The RX buffer, which is used for received data. May be nullptr if tx_length is 0. </td></tr>
    <tr><td class="paramname">rx_length</td><td>The length of RX buffer in bytes If 0, no reception is done. </td></tr>
    <tr><td class="paramname">timeout</td><td>timeout value. Use <a class="el" href="namespacertos_1_1_kernel.html#a29baed0762de3912b6b7592150a9498e" title="Magic &quot;wait forever&quot; constant for Kernel::Clock::duration_u32-based APIs.">rtos::Kernel::wait_for_u32_forever</a> to wait forever (the default). </td></tr>
    <tr><td class="paramname">repeated</td><td>Set up for a repeated start. If true, the Mbed processor does not relinquish the bus after this operation. You may then call <a class="el" href="classmbed_1_1_i2_c.html#a81a5b394ae924d714e8ec6ab4bbdf4f2" title="Write to an I2C slave.">write()</a>, <a class="el" href="classmbed_1_1_i2_c.html#a16a28f7b5087a9493701c2b35cb77f3f" title="Read from an I2C slave.">read()</a>, or <a class="el" href="classmbed_1_1_i2_c.html#aedc96a40e844bc2efc8bbef1b0782702" title="Creates a start condition on the I2C bus.">start()</a> again to start another operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result code describing whether the transfer succeeded or not. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>mbed</b></li><li class="navelem"><a class="el" href="classmbed_1_1_i2_c.html">I2C</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>

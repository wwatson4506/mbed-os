<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Mbed OS Reference: ATHandler Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="mbed-ce_55x55.png"/></td>
  <td id="projectalign">
   <div id="projectname">Mbed OS Reference
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classmbed_1_1_a_t_handler.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle"><div class="title">ATHandler Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Class for sending AT commands and parsing AT responses.  
 <a href="classmbed_1_1_a_t_handler.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_a_t_handler_8h_source.html">ATHandler.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a505519cd954e4ae87fe28826093abe0d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_a_t_handler.html#a505519cd954e4ae87fe28826093abe0d">ATHandler</a> (<a class="el" href="classmbed_1_1_file_handle.html">FileHandle</a> *fh, <a class="el" href="classevents_1_1_event_queue.html">events::EventQueue</a> &amp;queue, uint32_t timeout, const char *output_delimiter, uint16_t send_delay=0)</td></tr>
<tr class="memdesc:a505519cd954e4ae87fe28826093abe0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="classmbed_1_1_a_t_handler.html#a505519cd954e4ae87fe28826093abe0d">More...</a><br /></td></tr>
<tr class="separator:a505519cd954e4ae87fe28826093abe0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdbab906b80cbe6206a3ca08a7ecb4d9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_a_t_handler.html#afdbab906b80cbe6206a3ca08a7ecb4d9">ATHandler</a> (<a class="el" href="classmbed_1_1_file_handle.html">FileHandle</a> *fh, <a class="el" href="classevents_1_1_event_queue.html">events::EventQueue</a> &amp;queue, mbed::chrono::milliseconds_u32 timeout, const char *output_delimiter, std::chrono::duration&lt; uint16_t, std::milli &gt; send_delay=std::chrono::milliseconds(0))</td></tr>
<tr class="memdesc:afdbab906b80cbe6206a3ca08a7ecb4d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="classmbed_1_1_a_t_handler.html#afdbab906b80cbe6206a3ca08a7ecb4d9">More...</a><br /></td></tr>
<tr class="separator:afdbab906b80cbe6206a3ca08a7ecb4d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e6fdd5f4f2d389d1dd5002f0d44016a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_file_handle.html">FileHandle</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_a_t_handler.html#a7e6fdd5f4f2d389d1dd5002f0d44016a">get_file_handle</a> ()</td></tr>
<tr class="memdesc:a7e6fdd5f4f2d389d1dd5002f0d44016a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return used file handle.  <a href="classmbed_1_1_a_t_handler.html#a7e6fdd5f4f2d389d1dd5002f0d44016a">More...</a><br /></td></tr>
<tr class="separator:a7e6fdd5f4f2d389d1dd5002f0d44016a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa81aed607133209dade63a226818224d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_a_t_handler.html#aa81aed607133209dade63a226818224d">lock</a> ()</td></tr>
<tr class="memdesc:aa81aed607133209dade63a226818224d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locks the mutex for file handle if AT_HANDLER_MUTEX is defined.  <a href="classmbed_1_1_a_t_handler.html#aa81aed607133209dade63a226818224d">More...</a><br /></td></tr>
<tr class="separator:aa81aed607133209dade63a226818224d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9278be8203e1c42e2619179882ae4403"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_a_t_handler.html#a9278be8203e1c42e2619179882ae4403">unlock</a> ()</td></tr>
<tr class="memdesc:a9278be8203e1c42e2619179882ae4403"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlocks the mutex for file handle if AT_HANDLER_MUTEX is defined.  <a href="classmbed_1_1_a_t_handler.html#a9278be8203e1c42e2619179882ae4403">More...</a><br /></td></tr>
<tr class="separator:a9278be8203e1c42e2619179882ae4403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30a107a0b46c626d38b509d45522740b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_a_t_handler.html#a30a107a0b46c626d38b509d45522740b">unlock_return_error</a> ()</td></tr>
<tr class="memdesc:a30a107a0b46c626d38b509d45522740b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locks the mutex for file handle if AT_HANDLER_MUTEX is defined and returns the last error.  <a href="classmbed_1_1_a_t_handler.html#a30a107a0b46c626d38b509d45522740b">More...</a><br /></td></tr>
<tr class="separator:a30a107a0b46c626d38b509d45522740b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafade422b098e9d5f32d7db472a49295"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_a_t_handler.html#aafade422b098e9d5f32d7db472a49295">set_urc_handler</a> (const char *prefix, <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; void()&gt; <a class="el" href="group__platform___callback.html#ga90e30db9c535d448cd949f7f55bb8f31">callback</a>)</td></tr>
<tr class="memdesc:aafade422b098e9d5f32d7db472a49295"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set callback function for URC.  <a href="classmbed_1_1_a_t_handler.html#aafade422b098e9d5f32d7db472a49295">More...</a><br /></td></tr>
<tr class="separator:aafade422b098e9d5f32d7db472a49295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaae8bda42cb333fdf44f52f13980cf51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_a_t_handler.html#aaae8bda42cb333fdf44f52f13980cf51">get_last_error</a> () const</td></tr>
<tr class="memdesc:aaae8bda42cb333fdf44f52f13980cf51"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the last error while parsing AT responses.  <a href="classmbed_1_1_a_t_handler.html#aaae8bda42cb333fdf44f52f13980cf51">More...</a><br /></td></tr>
<tr class="separator:aaae8bda42cb333fdf44f52f13980cf51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5447ca70389b51d097d5b434941e07e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmbed_1_1device__err__t.html">device_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_a_t_handler.html#a5447ca70389b51d097d5b434941e07e9">get_last_device_error</a> () const</td></tr>
<tr class="memdesc:a5447ca70389b51d097d5b434941e07e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the last device error while parsing AT responses.  <a href="classmbed_1_1_a_t_handler.html#a5447ca70389b51d097d5b434941e07e9">More...</a><br /></td></tr>
<tr class="separator:a5447ca70389b51d097d5b434941e07e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a077d7ca5be9dd42253ed7d375e8f2511"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_a_t_handler.html#a077d7ca5be9dd42253ed7d375e8f2511">set_at_timeout</a> (uint32_t timeout_milliseconds, bool default_timeout=false)</td></tr>
<tr class="memdesc:a077d7ca5be9dd42253ed7d375e8f2511"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set timeout in milliseconds for AT commands.  <a href="classmbed_1_1_a_t_handler.html#a077d7ca5be9dd42253ed7d375e8f2511">More...</a><br /></td></tr>
<tr class="separator:a077d7ca5be9dd42253ed7d375e8f2511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51e773bb652428f9cd091db48ab0ea00"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_a_t_handler.html#a51e773bb652428f9cd091db48ab0ea00">set_at_timeout</a> (mbed::chrono::milliseconds_u32 timeout, bool default_timeout=false)</td></tr>
<tr class="memdesc:a51e773bb652428f9cd091db48ab0ea00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set timeout in milliseconds for AT commands.  <a href="classmbed_1_1_a_t_handler.html#a51e773bb652428f9cd091db48ab0ea00">More...</a><br /></td></tr>
<tr class="separator:a51e773bb652428f9cd091db48ab0ea00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaba238ba396aff9525ade172d0078c9c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_a_t_handler.html#aaba238ba396aff9525ade172d0078c9c">restore_at_timeout</a> ()</td></tr>
<tr class="memdesc:aaba238ba396aff9525ade172d0078c9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore timeout to previous timeout.  <a href="classmbed_1_1_a_t_handler.html#aaba238ba396aff9525ade172d0078c9c">More...</a><br /></td></tr>
<tr class="separator:aaba238ba396aff9525ade172d0078c9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc021e1f6d5e6619942e33f9d6d63cda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_a_t_handler.html#afc021e1f6d5e6619942e33f9d6d63cda">clear_error</a> ()</td></tr>
<tr class="memdesc:afc021e1f6d5e6619942e33f9d6d63cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear pending error flag.  <a href="classmbed_1_1_a_t_handler.html#afc021e1f6d5e6619942e33f9d6d63cda">More...</a><br /></td></tr>
<tr class="separator:afc021e1f6d5e6619942e33f9d6d63cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adac116554b543b7c4228c018a85882f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_a_t_handler.html#adac116554b543b7c4228c018a85882f5">flush</a> ()</td></tr>
<tr class="memdesc:adac116554b543b7c4228c018a85882f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flushes the underlying stream.  <a href="classmbed_1_1_a_t_handler.html#adac116554b543b7c4228c018a85882f5">More...</a><br /></td></tr>
<tr class="separator:adac116554b543b7c4228c018a85882f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab94148c9e6284e96c9a59f338043468c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_a_t_handler.html#ab94148c9e6284e96c9a59f338043468c">process_oob</a> ()</td></tr>
<tr class="memdesc:ab94148c9e6284e96c9a59f338043468c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to find oob's from the AT response.  <a href="classmbed_1_1_a_t_handler.html#ab94148c9e6284e96c9a59f338043468c">More...</a><br /></td></tr>
<tr class="separator:ab94148c9e6284e96c9a59f338043468c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a457d28c782590107c21c9d1f20d33b1a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_a_t_handler.html#a457d28c782590107c21c9d1f20d33b1a">set_is_filehandle_usable</a> (bool usable)</td></tr>
<tr class="memdesc:a457d28c782590107c21c9d1f20d33b1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set is file handle usable.  <a href="classmbed_1_1_a_t_handler.html#a457d28c782590107c21c9d1f20d33b1a">More...</a><br /></td></tr>
<tr class="separator:a457d28c782590107c21c9d1f20d33b1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31762aa4618c53bfd48740e663eee226"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_a_t_handler.html#a31762aa4618c53bfd48740e663eee226">sync</a> (int timeout_ms)</td></tr>
<tr class="memdesc:a31762aa4618c53bfd48740e663eee226"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronize AT command and response handling to modem.  <a href="classmbed_1_1_a_t_handler.html#a31762aa4618c53bfd48740e663eee226">More...</a><br /></td></tr>
<tr class="separator:a31762aa4618c53bfd48740e663eee226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a207ff5c4ee9e3d039a0b2e2a4412e92d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_a_t_handler.html#a207ff5c4ee9e3d039a0b2e2a4412e92d">sync</a> (std::chrono::duration&lt; int, std::milli &gt; timeout)</td></tr>
<tr class="memdesc:a207ff5c4ee9e3d039a0b2e2a4412e92d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronize AT command and response handling to modem.  <a href="classmbed_1_1_a_t_handler.html#a207ff5c4ee9e3d039a0b2e2a4412e92d">More...</a><br /></td></tr>
<tr class="separator:a207ff5c4ee9e3d039a0b2e2a4412e92d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7580bbb7064195821566bcc82d5ed780"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_a_t_handler.html#a7580bbb7064195821566bcc82d5ed780">set_send_delay</a> (uint16_t send_delay)</td></tr>
<tr class="memdesc:a7580bbb7064195821566bcc82d5ed780"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the delay to be applied before sending any AT command.  <a href="classmbed_1_1_a_t_handler.html#a7580bbb7064195821566bcc82d5ed780">More...</a><br /></td></tr>
<tr class="separator:a7580bbb7064195821566bcc82d5ed780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ba85104ed0d29e2a9b3084d55bfd3f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_a_t_handler.html#a3ba85104ed0d29e2a9b3084d55bfd3f8">set_baud</a> (int baud_rate)</td></tr>
<tr class="memdesc:a3ba85104ed0d29e2a9b3084d55bfd3f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <a class="el" href="classmbed_1_1_buffered_serial.html" title="Class providing buffered UART communication functionality using separate circular buffer for send and...">BufferedSerial</a> filehandle to given baud rate.  <a href="classmbed_1_1_a_t_handler.html#a3ba85104ed0d29e2a9b3084d55bfd3f8">More...</a><br /></td></tr>
<tr class="separator:a3ba85104ed0d29e2a9b3084d55bfd3f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a900219a8d5252cb7280db899af53d8d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_a_t_handler.html#a900219a8d5252cb7280db899af53d8d5">cmd_start</a> (const char *cmd)</td></tr>
<tr class="memdesc:a900219a8d5252cb7280db899af53d8d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts the command writing by clearing the last error and writing the given command.  <a href="classmbed_1_1_a_t_handler.html#a900219a8d5252cb7280db899af53d8d5">More...</a><br /></td></tr>
<tr class="separator:a900219a8d5252cb7280db899af53d8d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac17d518ca423dc60e4e85f36ed4bf207"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_a_t_handler.html#ac17d518ca423dc60e4e85f36ed4bf207">cmd_start_stop</a> (const char *cmd, const char *cmd_chr, const char *format=&quot;&quot;,...)</td></tr>
<tr class="memdesc:ac17d518ca423dc60e4e85f36ed4bf207"><td class="mdescLeft">&#160;</td><td class="mdescRight">cmd_start_stop Starts an AT command, writes given variadic arguments and stops the command.  <a href="classmbed_1_1_a_t_handler.html#ac17d518ca423dc60e4e85f36ed4bf207">More...</a><br /></td></tr>
<tr class="separator:ac17d518ca423dc60e4e85f36ed4bf207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30e05620bce15b5d5a931d13dcef4e6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_a_t_handler.html#a30e05620bce15b5d5a931d13dcef4e6c">at_cmd_str</a> (const char *cmd, const char *cmd_chr, char *resp_buf, size_t resp_buf_size, const char *format=&quot;&quot;,...)</td></tr>
<tr class="memdesc:a30e05620bce15b5d5a931d13dcef4e6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">at_cmd_str Send an AT command and read a single string response.  <a href="classmbed_1_1_a_t_handler.html#a30e05620bce15b5d5a931d13dcef4e6c">More...</a><br /></td></tr>
<tr class="separator:a30e05620bce15b5d5a931d13dcef4e6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a336639d035f497dd07a8a3ba11288329"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_a_t_handler.html#a336639d035f497dd07a8a3ba11288329">at_cmd_int</a> (const char *cmd, const char *cmd_chr, int &amp;resp, const char *format=&quot;&quot;,...)</td></tr>
<tr class="memdesc:a336639d035f497dd07a8a3ba11288329"><td class="mdescLeft">&#160;</td><td class="mdescRight">at_cmd_int Send an AT command and read a single integer response.  <a href="classmbed_1_1_a_t_handler.html#a336639d035f497dd07a8a3ba11288329">More...</a><br /></td></tr>
<tr class="separator:a336639d035f497dd07a8a3ba11288329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a393a528a7e78b47f2c90bc00c72d63f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_a_t_handler.html#a393a528a7e78b47f2c90bc00c72d63f1">at_cmd_discard</a> (const char *cmd, const char *cmd_chr, const char *format=&quot;&quot;,...)</td></tr>
<tr class="memdesc:a393a528a7e78b47f2c90bc00c72d63f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">at_cmd_discard Send an AT command and read and discard a response.  <a href="classmbed_1_1_a_t_handler.html#a393a528a7e78b47f2c90bc00c72d63f1">More...</a><br /></td></tr>
<tr class="separator:a393a528a7e78b47f2c90bc00c72d63f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ff234a6913ad346a4bfe0a8425cd588"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_a_t_handler.html#a5ff234a6913ad346a4bfe0a8425cd588">write_int</a> (int32_t param)</td></tr>
<tr class="memdesc:a5ff234a6913ad346a4bfe0a8425cd588"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes integer type AT command subparameter.  <a href="classmbed_1_1_a_t_handler.html#a5ff234a6913ad346a4bfe0a8425cd588">More...</a><br /></td></tr>
<tr class="separator:a5ff234a6913ad346a4bfe0a8425cd588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9d7c4559eb06163a0a9aaf0d877899f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_a_t_handler.html#ae9d7c4559eb06163a0a9aaf0d877899f">write_string</a> (const char *param, bool useQuotations=true)</td></tr>
<tr class="memdesc:ae9d7c4559eb06163a0a9aaf0d877899f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes string type AT command subparamater.  <a href="classmbed_1_1_a_t_handler.html#ae9d7c4559eb06163a0a9aaf0d877899f">More...</a><br /></td></tr>
<tr class="separator:ae9d7c4559eb06163a0a9aaf0d877899f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dd55f415913f04d817fb10a39d7ca84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_a_t_handler.html#a2dd55f415913f04d817fb10a39d7ca84">cmd_stop</a> ()</td></tr>
<tr class="memdesc:a2dd55f415913f04d817fb10a39d7ca84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops the AT command by writing command-line terminator CR to mark command as finished.  <a href="classmbed_1_1_a_t_handler.html#a2dd55f415913f04d817fb10a39d7ca84">More...</a><br /></td></tr>
<tr class="separator:a2dd55f415913f04d817fb10a39d7ca84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6dbe09c3fff913f92732c7d69819ef4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_a_t_handler.html#af6dbe09c3fff913f92732c7d69819ef4">cmd_stop_read_resp</a> ()</td></tr>
<tr class="memdesc:af6dbe09c3fff913f92732c7d69819ef4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops the AT command by writing command-line terminator CR to mark command as finished and reads the OK/ERROR response.  <a href="classmbed_1_1_a_t_handler.html#af6dbe09c3fff913f92732c7d69819ef4">More...</a><br /></td></tr>
<tr class="separator:af6dbe09c3fff913f92732c7d69819ef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5adaf3cca2e051d08a53a097a5221124"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_a_t_handler.html#a5adaf3cca2e051d08a53a097a5221124">write_bytes</a> (const uint8_t *data, size_t len)</td></tr>
<tr class="memdesc:a5adaf3cca2e051d08a53a097a5221124"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write bytes without any subparameter delimiters, such as comma.  <a href="classmbed_1_1_a_t_handler.html#a5adaf3cca2e051d08a53a097a5221124">More...</a><br /></td></tr>
<tr class="separator:a5adaf3cca2e051d08a53a097a5221124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f72756c558ab782f6d42101c252d204"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_a_t_handler.html#a2f72756c558ab782f6d42101c252d204">set_stop_tag</a> (const char *stop_tag_seq)</td></tr>
<tr class="memdesc:a2f72756c558ab782f6d42101c252d204"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the stop tag for the current scope (response/information response/element) Parameter's reading routines will stop the reading when such tag is found and will set the found flag.  <a href="classmbed_1_1_a_t_handler.html#a2f72756c558ab782f6d42101c252d204">More...</a><br /></td></tr>
<tr class="separator:a2f72756c558ab782f6d42101c252d204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae894311930cee46c248fbea56e464947"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_a_t_handler.html#ae894311930cee46c248fbea56e464947">set_delimiter</a> (char delimiter)</td></tr>
<tr class="memdesc:ae894311930cee46c248fbea56e464947"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the delimiter between parameters or between elements of the information response.  <a href="classmbed_1_1_a_t_handler.html#ae894311930cee46c248fbea56e464947">More...</a><br /></td></tr>
<tr class="separator:ae894311930cee46c248fbea56e464947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a029dc63406814f507b45dc44d9ca1e85"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_a_t_handler.html#a029dc63406814f507b45dc44d9ca1e85">set_default_delimiter</a> ()</td></tr>
<tr class="memdesc:a029dc63406814f507b45dc44d9ca1e85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the delimiter to default value defined by DEFAULT_DELIMITER.  <a href="classmbed_1_1_a_t_handler.html#a029dc63406814f507b45dc44d9ca1e85">More...</a><br /></td></tr>
<tr class="separator:a029dc63406814f507b45dc44d9ca1e85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1de88c96f89f3c688af8741ab5ac9f4f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_a_t_handler.html#a1de88c96f89f3c688af8741ab5ac9f4f">use_delimiter</a> (bool use_delimiter)</td></tr>
<tr class="memdesc:a1de88c96f89f3c688af8741ab5ac9f4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines behaviour for using or ignoring the delimiter within an AT command.  <a href="classmbed_1_1_a_t_handler.html#a1de88c96f89f3c688af8741ab5ac9f4f">More...</a><br /></td></tr>
<tr class="separator:a1de88c96f89f3c688af8741ab5ac9f4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2382b87d41b065a6e60865f1b65eede"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_a_t_handler.html#ad2382b87d41b065a6e60865f1b65eede">skip_param</a> (uint32_t count=1)</td></tr>
<tr class="memdesc:ad2382b87d41b065a6e60865f1b65eede"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consumes the reading buffer up to the delimiter or stop_tag.  <a href="classmbed_1_1_a_t_handler.html#ad2382b87d41b065a6e60865f1b65eede">More...</a><br /></td></tr>
<tr class="separator:ad2382b87d41b065a6e60865f1b65eede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4edf5a7828ef0f808626aabd1b73d655"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_a_t_handler.html#a4edf5a7828ef0f808626aabd1b73d655">skip_param</a> (ssize_t len, uint32_t count)</td></tr>
<tr class="memdesc:a4edf5a7828ef0f808626aabd1b73d655"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consumes the given length from the reading buffer.  <a href="classmbed_1_1_a_t_handler.html#a4edf5a7828ef0f808626aabd1b73d655">More...</a><br /></td></tr>
<tr class="separator:a4edf5a7828ef0f808626aabd1b73d655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fb1dcfb751cd1c82ded46e77f9a0b97"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_a_t_handler.html#a0fb1dcfb751cd1c82ded46e77f9a0b97">read_bytes</a> (uint8_t *buf, size_t len)</td></tr>
<tr class="memdesc:a0fb1dcfb751cd1c82ded46e77f9a0b97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads given number of bytes from receiving buffer without checking any subparameter delimiters, such as comma.  <a href="classmbed_1_1_a_t_handler.html#a0fb1dcfb751cd1c82ded46e77f9a0b97">More...</a><br /></td></tr>
<tr class="separator:a0fb1dcfb751cd1c82ded46e77f9a0b97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a120a6e8827564d213d6187789f7d806d"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_a_t_handler.html#a120a6e8827564d213d6187789f7d806d">read_string</a> (char *str, size_t size, bool read_even_stop_tag=false)</td></tr>
<tr class="memdesc:a120a6e8827564d213d6187789f7d806d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads chars from reading buffer.  <a href="classmbed_1_1_a_t_handler.html#a120a6e8827564d213d6187789f7d806d">More...</a><br /></td></tr>
<tr class="separator:a120a6e8827564d213d6187789f7d806d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2381971ab84015d5402fb9434ad3bb96"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_a_t_handler.html#a2381971ab84015d5402fb9434ad3bb96">read_hex_string</a> (char *str, size_t size)</td></tr>
<tr class="memdesc:a2381971ab84015d5402fb9434ad3bb96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads chars representing hex ascii values and converts them to the corresponding chars.  <a href="classmbed_1_1_a_t_handler.html#a2381971ab84015d5402fb9434ad3bb96">More...</a><br /></td></tr>
<tr class="separator:a2381971ab84015d5402fb9434ad3bb96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6223165d7cb55a498c199dbba827009a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_a_t_handler.html#a6223165d7cb55a498c199dbba827009a">write_hex_string</a> (const char *str, size_t size, bool quote_string=true)</td></tr>
<tr class="memdesc:a6223165d7cb55a498c199dbba827009a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts contained chars to their hex ascii value and writes the resulting string to the file handle For example: "AV" to "4156".  <a href="classmbed_1_1_a_t_handler.html#a6223165d7cb55a498c199dbba827009a">More...</a><br /></td></tr>
<tr class="separator:a6223165d7cb55a498c199dbba827009a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11b484214cd9eceb5f0dd60a9736c00a"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_a_t_handler.html#a11b484214cd9eceb5f0dd60a9736c00a">read_int</a> ()</td></tr>
<tr class="memdesc:a11b484214cd9eceb5f0dd60a9736c00a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads as string and converts result to integer.  <a href="classmbed_1_1_a_t_handler.html#a11b484214cd9eceb5f0dd60a9736c00a">More...</a><br /></td></tr>
<tr class="separator:a11b484214cd9eceb5f0dd60a9736c00a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7ac839cc3d1caeffd607c5d50595199"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_a_t_handler.html#af7ac839cc3d1caeffd607c5d50595199">resp_start</a> (const char *prefix=NULL, bool stop=false)</td></tr>
<tr class="memdesc:af7ac839cc3d1caeffd607c5d50595199"><td class="mdescLeft">&#160;</td><td class="mdescRight">This looks for necessary matches: prefix, OK, ERROR, URCs and sets the correct scope.  <a href="classmbed_1_1_a_t_handler.html#af7ac839cc3d1caeffd607c5d50595199">More...</a><br /></td></tr>
<tr class="separator:af7ac839cc3d1caeffd607c5d50595199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa925296e303a73aefb7c655891cd8536"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_a_t_handler.html#aa925296e303a73aefb7c655891cd8536">resp_stop</a> ()</td></tr>
<tr class="memdesc:aa925296e303a73aefb7c655891cd8536"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ends all scopes starting from current scope.  <a href="classmbed_1_1_a_t_handler.html#aa925296e303a73aefb7c655891cd8536">More...</a><br /></td></tr>
<tr class="separator:aa925296e303a73aefb7c655891cd8536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b74bd98550cea394d6167b7e932d755"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_a_t_handler.html#a5b74bd98550cea394d6167b7e932d755">info_resp</a> ()</td></tr>
<tr class="memdesc:a5b74bd98550cea394d6167b7e932d755"><td class="mdescLeft">&#160;</td><td class="mdescRight">Looks for matching the prefix given to <a class="el" href="classmbed_1_1_a_t_handler.html#af7ac839cc3d1caeffd607c5d50595199" title="This looks for necessary matches: prefix, OK, ERROR, URCs and sets the correct scope.">resp_start()</a> call.  <a href="classmbed_1_1_a_t_handler.html#a5b74bd98550cea394d6167b7e932d755">More...</a><br /></td></tr>
<tr class="separator:a5b74bd98550cea394d6167b7e932d755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae87c8ed27b84ae7e11989532bfe3b2bc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_a_t_handler.html#ae87c8ed27b84ae7e11989532bfe3b2bc">info_elem</a> (char start_tag)</td></tr>
<tr class="memdesc:ae87c8ed27b84ae7e11989532bfe3b2bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Looks for matching the start tag.  <a href="classmbed_1_1_a_t_handler.html#ae87c8ed27b84ae7e11989532bfe3b2bc">More...</a><br /></td></tr>
<tr class="separator:ae87c8ed27b84ae7e11989532bfe3b2bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06ea6d4622ad75a9e34f0bf0fa5c6a1e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_a_t_handler.html#a06ea6d4622ad75a9e34f0bf0fa5c6a1e">consume_to_stop_tag</a> ()</td></tr>
<tr class="memdesc:a06ea6d4622ad75a9e34f0bf0fa5c6a1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consumes the received content until current stop tag is found.  <a href="classmbed_1_1_a_t_handler.html#a06ea6d4622ad75a9e34f0bf0fa5c6a1e">More...</a><br /></td></tr>
<tr class="separator:a06ea6d4622ad75a9e34f0bf0fa5c6a1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d7cb6728c39e60ed0d77e1dcef8bc3e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_a_t_handler.html#a8d7cb6728c39e60ed0d77e1dcef8bc3e">get_3gpp_error</a> ()</td></tr>
<tr class="memdesc:a8d7cb6728c39e60ed0d77e1dcef8bc3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the last 3GPP error code.  <a href="classmbed_1_1_a_t_handler.html#a8d7cb6728c39e60ed0d77e1dcef8bc3e">More...</a><br /></td></tr>
<tr class="separator:a8d7cb6728c39e60ed0d77e1dcef8bc3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a4b964705563b60a19700a9cda7aa2d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_a_t_handler.html#a5a4b964705563b60a19700a9cda7aa2d">set_debug</a> (bool debug_on)</td></tr>
<tr class="memdesc:a5a4b964705563b60a19700a9cda7aa2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">AT debugging, when enabled will print all data read and written, non-printable chars are printed as "[%d]".  <a href="classmbed_1_1_a_t_handler.html#a5a4b964705563b60a19700a9cda7aa2d">More...</a><br /></td></tr>
<tr class="separator:a5a4b964705563b60a19700a9cda7aa2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a503daa9969b885c2f38623c0ce6d01a1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_a_t_handler.html#a503daa9969b885c2f38623c0ce6d01a1">get_debug</a> () const</td></tr>
<tr class="memdesc:a503daa9969b885c2f38623c0ce6d01a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get degug state set by <a class="el" href="classmbed_1_1_a_t_handler.html#a5a4b964705563b60a19700a9cda7aa2d">set_debug</a>.  <a href="classmbed_1_1_a_t_handler.html#a503daa9969b885c2f38623c0ce6d01a1">More...</a><br /></td></tr>
<tr class="separator:a503daa9969b885c2f38623c0ce6d01a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Class for sending AT commands and parsing AT responses. </p>

<p class="definition">Definition at line <a class="el" href="_a_t_handler_8h_source.html#l00068">68</a> of file <a class="el" href="_a_t_handler_8h_source.html">ATHandler.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a505519cd954e4ae87fe28826093abe0d" name="a505519cd954e4ae87fe28826093abe0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a505519cd954e4ae87fe28826093abe0d">&#9670;&#160;</a></span>ATHandler() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_a_t_handler.html">ATHandler</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmbed_1_1_file_handle.html">FileHandle</a> *&#160;</td>
          <td class="paramname"><em>fh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classevents_1_1_event_queue.html">events::EventQueue</a> &amp;&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>output_delimiter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>send_delay</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fh</td><td>file handle used for reading AT responses and writing AT commands </td></tr>
    <tr><td class="paramname">queue</td><td>Event queue used to transfer sigio events to this thread </td></tr>
    <tr><td class="paramname">timeout</td><td><a class="el" href="classmbed_1_1_timeout.html">Timeout</a> when reading for AT response </td></tr>
    <tr><td class="paramname">output_delimiter</td><td>delimiter used when parsing at responses, "\r" should be used as output_delimiter </td></tr>
    <tr><td class="paramname">send_delay</td><td>the minimum delay in ms between the end of last response and the beginning of a new command </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afdbab906b80cbe6206a3ca08a7ecb4d9" name="afdbab906b80cbe6206a3ca08a7ecb4d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdbab906b80cbe6206a3ca08a7ecb4d9">&#9670;&#160;</a></span>ATHandler() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_a_t_handler.html">ATHandler</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmbed_1_1_file_handle.html">FileHandle</a> *&#160;</td>
          <td class="paramname"><em>fh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classevents_1_1_event_queue.html">events::EventQueue</a> &amp;&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mbed::chrono::milliseconds_u32&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>output_delimiter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::duration&lt; uint16_t, std::milli &gt;&#160;</td>
          <td class="paramname"><em>send_delay</em> = <code>std::chrono::milliseconds(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fh</td><td>file handle used for reading AT responses and writing AT commands </td></tr>
    <tr><td class="paramname">queue</td><td>Event queue used to transfer sigio events to this thread </td></tr>
    <tr><td class="paramname">timeout</td><td><a class="el" href="classmbed_1_1_timeout.html">Timeout</a> when reading for AT response </td></tr>
    <tr><td class="paramname">output_delimiter</td><td>delimiter used when parsing at responses, "\r" should be used as output_delimiter </td></tr>
    <tr><td class="paramname">send_delay</td><td>the minimum delay in ms between the end of last response and the beginning of a new command </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7e6fdd5f4f2d389d1dd5002f0d44016a" name="a7e6fdd5f4f2d389d1dd5002f0d44016a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e6fdd5f4f2d389d1dd5002f0d44016a">&#9670;&#160;</a></span>get_file_handle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_file_handle.html">FileHandle</a> * get_file_handle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return used file handle. </p>
<dl class="section return"><dt>Returns</dt><dd>used file handle </dd></dl>

</div>
</div>
<a id="aa81aed607133209dade63a226818224d" name="aa81aed607133209dade63a226818224d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa81aed607133209dade63a226818224d">&#9670;&#160;</a></span>lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Locks the mutex for file handle if AT_HANDLER_MUTEX is defined. </p>

</div>
</div>
<a id="a9278be8203e1c42e2619179882ae4403" name="a9278be8203e1c42e2619179882ae4403"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9278be8203e1c42e2619179882ae4403">&#9670;&#160;</a></span>unlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void unlock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlocks the mutex for file handle if AT_HANDLER_MUTEX is defined. </p>

</div>
</div>
<a id="a30a107a0b46c626d38b509d45522740b" name="a30a107a0b46c626d38b509d45522740b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30a107a0b46c626d38b509d45522740b">&#9670;&#160;</a></span>unlock_return_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> unlock_return_error </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Locks the mutex for file handle if AT_HANDLER_MUTEX is defined and returns the last error. </p>
<dl class="section return"><dt>Returns</dt><dd>last error that happened when parsing AT responses </dd></dl>

</div>
</div>
<a id="aafade422b098e9d5f32d7db472a49295" name="aafade422b098e9d5f32d7db472a49295"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafade422b098e9d5f32d7db472a49295">&#9670;&#160;</a></span>set_urc_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_urc_handler </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; void()&gt;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set callback function for URC. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prefix</td><td>URC text to look for, e.g. "+CMTI:". Maximum length is MBED_CONF_CELLULAR_AT_HANDLER_BUFFER_SIZE. </td></tr>
    <tr><td class="paramname">callback</td><td>function to call on prefix, or 0 to remove callback </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaae8bda42cb333fdf44f52f13980cf51" name="aaae8bda42cb333fdf44f52f13980cf51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaae8bda42cb333fdf44f52f13980cf51">&#9670;&#160;</a></span>get_last_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> get_last_error </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the last error while parsing AT responses. </p>
<dl class="section return"><dt>Returns</dt><dd>last error </dd></dl>

</div>
</div>
<a id="a5447ca70389b51d097d5b434941e07e9" name="a5447ca70389b51d097d5b434941e07e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5447ca70389b51d097d5b434941e07e9">&#9670;&#160;</a></span>get_last_device_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmbed_1_1device__err__t.html">device_err_t</a> get_last_device_error </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the last device error while parsing AT responses. </p>
<p >Actually AT error (CME/CMS).</p>
<dl class="section return"><dt>Returns</dt><dd>last error struct <a class="el" href="structmbed_1_1device__err__t.html" title="AT response error with error code and type.">device_err_t</a> </dd></dl>

</div>
</div>
<a id="a077d7ca5be9dd42253ed7d375e8f2511" name="a077d7ca5be9dd42253ed7d375e8f2511"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a077d7ca5be9dd42253ed7d375e8f2511">&#9670;&#160;</a></span>set_at_timeout() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_at_timeout </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout_milliseconds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>default_timeout</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set timeout in milliseconds for AT commands. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout_milliseconds</td><td><a class="el" href="classmbed_1_1_timeout.html">Timeout</a> in milliseconds </td></tr>
    <tr><td class="paramname">default_timeout</td><td>Store as default timeout </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a51e773bb652428f9cd091db48ab0ea00" name="a51e773bb652428f9cd091db48ab0ea00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51e773bb652428f9cd091db48ab0ea00">&#9670;&#160;</a></span>set_at_timeout() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_at_timeout </td>
          <td>(</td>
          <td class="paramtype">mbed::chrono::milliseconds_u32&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>default_timeout</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set timeout in milliseconds for AT commands. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td><a class="el" href="classmbed_1_1_timeout.html">Timeout</a> in milliseconds </td></tr>
    <tr><td class="paramname">default_timeout</td><td>Store as default timeout </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaba238ba396aff9525ade172d0078c9c" name="aaba238ba396aff9525ade172d0078c9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaba238ba396aff9525ade172d0078c9c">&#9670;&#160;</a></span>restore_at_timeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void restore_at_timeout </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restore timeout to previous timeout. </p>
<p >Handy if there is a need to change timeout temporarily. </p>

</div>
</div>
<a id="afc021e1f6d5e6619942e33f9d6d63cda" name="afc021e1f6d5e6619942e33f9d6d63cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc021e1f6d5e6619942e33f9d6d63cda">&#9670;&#160;</a></span>clear_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clear_error </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear pending error flag. </p>
<p >By default, error is cleared only in <a class="el" href="classmbed_1_1_a_t_handler.html#aa81aed607133209dade63a226818224d" title="Locks the mutex for file handle if AT_HANDLER_MUTEX is defined.">lock()</a>. </p>

</div>
</div>
<a id="adac116554b543b7c4228c018a85882f5" name="adac116554b543b7c4228c018a85882f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adac116554b543b7c4228c018a85882f5">&#9670;&#160;</a></span>flush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void flush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flushes the underlying stream. </p>

</div>
</div>
<a id="ab94148c9e6284e96c9a59f338043468c" name="ab94148c9e6284e96c9a59f338043468c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab94148c9e6284e96c9a59f338043468c">&#9670;&#160;</a></span>process_oob()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void process_oob </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tries to find oob's from the AT response. </p>
<p >Call the urc callback if one is found. </p>

</div>
</div>
<a id="a457d28c782590107c21c9d1f20d33b1a" name="a457d28c782590107c21c9d1f20d33b1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a457d28c782590107c21c9d1f20d33b1a">&#9670;&#160;</a></span>set_is_filehandle_usable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_is_filehandle_usable </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>usable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set is file handle usable. </p>
<p >Some situations like after going to data mode, file handle is not usable anymore. Any items in queue are not to be processed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">usable</td><td>true for usable filehandle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a31762aa4618c53bfd48740e663eee226" name="a31762aa4618c53bfd48740e663eee226"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31762aa4618c53bfd48740e663eee226">&#9670;&#160;</a></span>sync() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sync </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout_ms</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronize AT command and response handling to modem. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout_ms</td><td><a class="el" href="classmbed_1_1_a_t_handler.html" title="Class for sending AT commands and parsing AT responses.">ATHandler</a> timeout when trying to sync. Will be restored when function returns. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true is synchronization was successful, false in case of failure </dd></dl>

</div>
</div>
<a id="a207ff5c4ee9e3d039a0b2e2a4412e92d" name="a207ff5c4ee9e3d039a0b2e2a4412e92d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a207ff5c4ee9e3d039a0b2e2a4412e92d">&#9670;&#160;</a></span>sync() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sync </td>
          <td>(</td>
          <td class="paramtype">std::chrono::duration&lt; int, std::milli &gt;&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronize AT command and response handling to modem. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td><a class="el" href="classmbed_1_1_a_t_handler.html" title="Class for sending AT commands and parsing AT responses.">ATHandler</a> timeout when trying to sync. Will be restored when function returns. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true is synchronization was successful, false in case of failure </dd></dl>

</div>
</div>
<a id="a7580bbb7064195821566bcc82d5ed780" name="a7580bbb7064195821566bcc82d5ed780"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7580bbb7064195821566bcc82d5ed780">&#9670;&#160;</a></span>set_send_delay()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_send_delay </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>send_delay</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the delay to be applied before sending any AT command. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">send_delay</td><td>the minimum delay in ms between the end of last response and the beginning of a new command </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3ba85104ed0d29e2a9b3084d55bfd3f8" name="a3ba85104ed0d29e2a9b3084d55bfd3f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ba85104ed0d29e2a9b3084d55bfd3f8">&#9670;&#160;</a></span>set_baud()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_baud </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>baud_rate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets <a class="el" href="classmbed_1_1_buffered_serial.html" title="Class providing buffered UART communication functionality using separate circular buffer for send and...">BufferedSerial</a> filehandle to given baud rate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baud_rate</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a900219a8d5252cb7280db899af53d8d5" name="a900219a8d5252cb7280db899af53d8d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a900219a8d5252cb7280db899af53d8d5">&#9670;&#160;</a></span>cmd_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cmd_start </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cmd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts the command writing by clearing the last error and writing the given command. </p>
<p >In case of failure when writing, the last error is set to NSAPI_ERROR_DEVICE_ERROR.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmd</td><td>AT command to be written to modem </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac17d518ca423dc60e4e85f36ed4bf207" name="ac17d518ca423dc60e4e85f36ed4bf207"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac17d518ca423dc60e4e85f36ed4bf207">&#9670;&#160;</a></span>cmd_start_stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cmd_start_stop </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cmd_chr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>cmd_start_stop Starts an AT command, writes given variadic arguments and stops the command. </p>
<p >Use this command when you need multiple response parameters to be handled. NOTE: Does not lock <a class="el" href="classmbed_1_1_a_t_handler.html" title="Class for sending AT commands and parsing AT responses.">ATHandler</a> for process!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmd</td><td>AT command in form +&lt;CMD&lt; (will be used also in response reading, no extra chars allowed) </td></tr>
    <tr><td class="paramname">cmd_chr</td><td>Char to be added to specific AT command: '?', '=' or ''. Will be used as such so '=1' is valid as well. </td></tr>
    <tr><td class="paramname">format</td><td>Format string for variadic arguments to be added to AT command; No separator needed. Use d for integer, s for string and b for byte string (requires 2 arguments: string and length) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a30e05620bce15b5d5a931d13dcef4e6c" name="a30e05620bce15b5d5a931d13dcef4e6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30e05620bce15b5d5a931d13dcef4e6c">&#9670;&#160;</a></span>at_cmd_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> at_cmd_str </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cmd_chr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>resp_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>resp_buf_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>at_cmd_str Send an AT command and read a single string response. </p>
<p >Locks and unlocks <a class="el" href="classmbed_1_1_a_t_handler.html" title="Class for sending AT commands and parsing AT responses.">ATHandler</a> for operation </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmd</td><td>AT command in form +&lt;CMD&lt; (will be used also in response reading, no extra chars allowed) </td></tr>
    <tr><td class="paramname">cmd_chr</td><td>Char to be added to specific AT command: '?', '=' or ''. Will be used as such so '=1' is valid as well. </td></tr>
    <tr><td class="paramname">resp_buf</td><td>Response buffer </td></tr>
    <tr><td class="paramname">resp_buf_size</td><td>Response buffer size </td></tr>
    <tr><td class="paramname">format</td><td>Format string for variadic arguments to be added to AT command; No separator needed. Use d for integer, s for string and b for byte string (requires 2 arguments: string and length) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>last error that happened when parsing AT responses </dd></dl>

</div>
</div>
<a id="a336639d035f497dd07a8a3ba11288329" name="a336639d035f497dd07a8a3ba11288329"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a336639d035f497dd07a8a3ba11288329">&#9670;&#160;</a></span>at_cmd_int()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> at_cmd_int </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cmd_chr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>resp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>at_cmd_int Send an AT command and read a single integer response. </p>
<p >Locks and unlocks <a class="el" href="classmbed_1_1_a_t_handler.html" title="Class for sending AT commands and parsing AT responses.">ATHandler</a> for operation </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmd</td><td>AT command in form +&lt;CMD&lt; (will be used also in response reading, no extra chars allowed) </td></tr>
    <tr><td class="paramname">cmd_chr</td><td>Char to be added to specific AT command: '?', '=' or ''. Will be used as such so '=1' is valid as well. </td></tr>
    <tr><td class="paramname">resp</td><td>Integer to hold response </td></tr>
    <tr><td class="paramname">format</td><td>Format string for variadic arguments to be added to AT command; No separator needed. Use d for integer, s for string and b for byte string (requires 2 arguments: string and length) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>last error that happened when parsing AT responses </dd></dl>

</div>
</div>
<a id="a393a528a7e78b47f2c90bc00c72d63f1" name="a393a528a7e78b47f2c90bc00c72d63f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a393a528a7e78b47f2c90bc00c72d63f1">&#9670;&#160;</a></span>at_cmd_discard()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> at_cmd_discard </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cmd_chr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>at_cmd_discard Send an AT command and read and discard a response. </p>
<p >Locks and unlocks <a class="el" href="classmbed_1_1_a_t_handler.html" title="Class for sending AT commands and parsing AT responses.">ATHandler</a> for operation </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmd</td><td>AT command in form +&lt;CMD&lt; (will be used also in response reading, no extra chars allowed) </td></tr>
    <tr><td class="paramname">cmd_chr</td><td>Char to be added to specific AT command: '?', '=' or ''. Will be used as such so '=1' is valid as well. </td></tr>
    <tr><td class="paramname">format</td><td>Format string for variadic arguments to be added to AT command; No separator needed. Use d for integer, s for string and b for byte string (requires 2 arguments: string and length) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>last error that happened when parsing AT responses </dd></dl>

</div>
</div>
<a id="a5ff234a6913ad346a4bfe0a8425cd588" name="a5ff234a6913ad346a4bfe0a8425cd588"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ff234a6913ad346a4bfe0a8425cd588">&#9670;&#160;</a></span>write_int()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void write_int </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>param</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes integer type AT command subparameter. </p>
<p >Starts with the delimiter if not the first param after cmd_start. In case of failure when writing, the last error is set to NSAPI_ERROR_DEVICE_ERROR.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">param</td><td>int to be written to modem as AT command subparameter </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae9d7c4559eb06163a0a9aaf0d877899f" name="ae9d7c4559eb06163a0a9aaf0d877899f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9d7c4559eb06163a0a9aaf0d877899f">&#9670;&#160;</a></span>write_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void write_string </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useQuotations</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes string type AT command subparamater. </p>
<p >Quotes are added to surround the given string. Starts with the delimiter if not the first param after cmd_start. In case of failure when writing, the last error is set to NSAPI_ERROR_DEVICE_ERROR.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">param</td><td>string to be written to modem as AT command subparameter </td></tr>
    <tr><td class="paramname">useQuotations</td><td>flag indicating whether the string should be included in quotation marks </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2dd55f415913f04d817fb10a39d7ca84" name="a2dd55f415913f04d817fb10a39d7ca84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dd55f415913f04d817fb10a39d7ca84">&#9670;&#160;</a></span>cmd_stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cmd_stop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stops the AT command by writing command-line terminator CR to mark command as finished. </p>

</div>
</div>
<a id="af6dbe09c3fff913f92732c7d69819ef4" name="af6dbe09c3fff913f92732c7d69819ef4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6dbe09c3fff913f92732c7d69819ef4">&#9670;&#160;</a></span>cmd_stop_read_resp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cmd_stop_read_resp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stops the AT command by writing command-line terminator CR to mark command as finished and reads the OK/ERROR response. </p>

</div>
</div>
<a id="a5adaf3cca2e051d08a53a097a5221124" name="a5adaf3cca2e051d08a53a097a5221124"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5adaf3cca2e051d08a53a097a5221124">&#9670;&#160;</a></span>write_bytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t write_bytes </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write bytes without any subparameter delimiters, such as comma. </p>
<p >In case of failure when writing, the last error is set to NSAPI_ERROR_DEVICE_ERROR.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>bytes to be written to modem </td></tr>
    <tr><td class="paramname">len</td><td>length of data string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of characters successfully written </dd></dl>

</div>
</div>
<a id="a2f72756c558ab782f6d42101c252d204" name="a2f72756c558ab782f6d42101c252d204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f72756c558ab782f6d42101c252d204">&#9670;&#160;</a></span>set_stop_tag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_stop_tag </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>stop_tag_seq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the stop tag for the current scope (response/information response/element) Parameter's reading routines will stop the reading when such tag is found and will set the found flag. </p>
<p >Consume routines will read everything until such tag is found.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stop_tag_seq</td><td>string to be set as stop tag </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae894311930cee46c248fbea56e464947" name="ae894311930cee46c248fbea56e464947"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae894311930cee46c248fbea56e464947">&#9670;&#160;</a></span>set_delimiter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_delimiter </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delimiter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the delimiter between parameters or between elements of the information response. </p>
<p >Parameter's reading routines will stop when such char is read.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">delimiter</td><td>char to be set as _delimiter </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a029dc63406814f507b45dc44d9ca1e85" name="a029dc63406814f507b45dc44d9ca1e85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a029dc63406814f507b45dc44d9ca1e85">&#9670;&#160;</a></span>set_default_delimiter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_default_delimiter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the delimiter to default value defined by DEFAULT_DELIMITER. </p>

</div>
</div>
<a id="a1de88c96f89f3c688af8741ab5ac9f4f" name="a1de88c96f89f3c688af8741ab5ac9f4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1de88c96f89f3c688af8741ab5ac9f4f">&#9670;&#160;</a></span>use_delimiter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void use_delimiter </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_delimiter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines behaviour for using or ignoring the delimiter within an AT command. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">use_delimiter</td><td>indicating if delimiter should be used or not </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad2382b87d41b065a6e60865f1b65eede" name="ad2382b87d41b065a6e60865f1b65eede"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2382b87d41b065a6e60865f1b65eede">&#9670;&#160;</a></span>skip_param() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void skip_param </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Consumes the reading buffer up to the delimiter or stop_tag. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>number of parameters to be skipped </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4edf5a7828ef0f808626aabd1b73d655" name="a4edf5a7828ef0f808626aabd1b73d655"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4edf5a7828ef0f808626aabd1b73d655">&#9670;&#160;</a></span>skip_param() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void skip_param </td>
          <td>(</td>
          <td class="paramtype">ssize_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Consumes the given length from the reading buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">len</td><td>length to be consumed from reading buffer </td></tr>
    <tr><td class="paramname">count</td><td>number of parameters to be skipped </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0fb1dcfb751cd1c82ded46e77f9a0b97" name="a0fb1dcfb751cd1c82ded46e77f9a0b97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fb1dcfb751cd1c82ded46e77f9a0b97">&#9670;&#160;</a></span>read_bytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t read_bytes </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads given number of bytes from receiving buffer without checking any subparameter delimiters, such as comma. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>output buffer for the read </td></tr>
    <tr><td class="paramname">len</td><td>maximum number of bytes to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of successfully read bytes or -1 in case of error </dd></dl>

</div>
</div>
<a id="a120a6e8827564d213d6187789f7d806d" name="a120a6e8827564d213d6187789f7d806d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a120a6e8827564d213d6187789f7d806d">&#9670;&#160;</a></span>read_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t read_string </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>read_even_stop_tag</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads chars from reading buffer. </p>
<p >Terminates with null. Skips the quotation marks. Stops on delimiter or stop tag.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>output buffer for the read </td></tr>
    <tr><td class="paramname">size</td><td>maximum number of chars to output including NULL </td></tr>
    <tr><td class="paramname">read_even_stop_tag</td><td>if true then try to read even if the stop tag was found previously </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>length of output string or -1 in case of read timeout before delimiter or stop tag is found </dd></dl>

</div>
</div>
<a id="a2381971ab84015d5402fb9434ad3bb96" name="a2381971ab84015d5402fb9434ad3bb96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2381971ab84015d5402fb9434ad3bb96">&#9670;&#160;</a></span>read_hex_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t read_hex_string </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads chars representing hex ascii values and converts them to the corresponding chars. </p>
<p >For example: "4156" to "AV". Terminates with null. Skips the quotation marks. Stops on delimiter or stop tag.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>output buffer for the read </td></tr>
    <tr><td class="paramname">size</td><td>maximum number of chars to output </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>length of output string or -1 in case of read timeout before delimiter or stop tag is found </dd></dl>

</div>
</div>
<a id="a6223165d7cb55a498c199dbba827009a" name="a6223165d7cb55a498c199dbba827009a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6223165d7cb55a498c199dbba827009a">&#9670;&#160;</a></span>write_hex_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void write_hex_string </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>quote_string</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts contained chars to their hex ascii value and writes the resulting string to the file handle For example: "AV" to "4156". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>input buffer to be converted to hex ascii </td></tr>
    <tr><td class="paramname">size</td><td>of the input param str </td></tr>
    <tr><td class="paramname">quote_string</td><td>if true it will add the double-quote character at beginning and end of string </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a11b484214cd9eceb5f0dd60a9736c00a" name="a11b484214cd9eceb5f0dd60a9736c00a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11b484214cd9eceb5f0dd60a9736c00a">&#9670;&#160;</a></span>read_int()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t read_int </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads as string and converts result to integer. </p>
<p >Supports only non-negative integers.</p>
<dl class="section return"><dt>Returns</dt><dd>the non-negative integer or -1 in case of error. </dd></dl>

</div>
</div>
<a id="af7ac839cc3d1caeffd607c5d50595199" name="af7ac839cc3d1caeffd607c5d50595199"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7ac839cc3d1caeffd607c5d50595199">&#9670;&#160;</a></span>resp_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void resp_start </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>prefix</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>stop</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This looks for necessary matches: prefix, OK, ERROR, URCs and sets the correct scope. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prefix</td><td>string to be matched from receiving buffer. If not NULL and match succeeds, then scope will be set as information response(info_type) </td></tr>
    <tr><td class="paramname">stop</td><td>flag to indicate if we go to information response scope or not. (needed when nothing is expected to be received anymore after the prefix match: sms case: "&gt; ", bc95 reboot case) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa925296e303a73aefb7c655891cd8536" name="aa925296e303a73aefb7c655891cd8536"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa925296e303a73aefb7c655891cd8536">&#9670;&#160;</a></span>resp_stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void resp_stop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ends all scopes starting from current scope. </p>
<p >Consumes everything until the scope's stop tag is found, then goes to next scope until response scope is ending. URC match is checked during response scope ending, for every new line / CRLF.</p>
<p >Possible sequence: element scope -&gt; information response scope -&gt; response scope </p>

</div>
</div>
<a id="a5b74bd98550cea394d6167b7e932d755" name="a5b74bd98550cea394d6167b7e932d755"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b74bd98550cea394d6167b7e932d755">&#9670;&#160;</a></span>info_resp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool info_resp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Looks for matching the prefix given to <a class="el" href="classmbed_1_1_a_t_handler.html#af7ac839cc3d1caeffd607c5d50595199" title="This looks for necessary matches: prefix, OK, ERROR, URCs and sets the correct scope.">resp_start()</a> call. </p>
<p >If needed, it ends the scope of a previous information response. Sets the information response scope if new prefix is found and response scope if prefix is not found.</p>
<dl class="section return"><dt>Returns</dt><dd>true if prefix defined for information response is not empty string and is found, false otherwise. </dd></dl>

</div>
</div>
<a id="ae87c8ed27b84ae7e11989532bfe3b2bc" name="ae87c8ed27b84ae7e11989532bfe3b2bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae87c8ed27b84ae7e11989532bfe3b2bc">&#9670;&#160;</a></span>info_elem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool info_elem </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>start_tag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Looks for matching the start tag. </p>
<p >If needed, it ends the scope of a previous element. Sets the element scope if start tag is found and information response scope if start tag is not found.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_tag</td><td>tag to be matched to begin parsing an element of an information response </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if new element is found, false otherwise </dd></dl>

</div>
</div>
<a id="a06ea6d4622ad75a9e34f0bf0fa5c6a1e" name="a06ea6d4622ad75a9e34f0bf0fa5c6a1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06ea6d4622ad75a9e34f0bf0fa5c6a1e">&#9670;&#160;</a></span>consume_to_stop_tag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool consume_to_stop_tag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Consumes the received content until current stop tag is found. </p>
<dl class="section return"><dt>Returns</dt><dd>true if stop tag is found, false otherwise </dd></dl>

</div>
</div>
<a id="a8d7cb6728c39e60ed0d77e1dcef8bc3e" name="a8d7cb6728c39e60ed0d77e1dcef8bc3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d7cb6728c39e60ed0d77e1dcef8bc3e">&#9670;&#160;</a></span>get_3gpp_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int get_3gpp_error </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the last 3GPP error code. </p>
<dl class="section return"><dt>Returns</dt><dd>last 3GPP error code </dd></dl>

</div>
</div>
<a id="a5a4b964705563b60a19700a9cda7aa2d" name="a5a4b964705563b60a19700a9cda7aa2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a4b964705563b60a19700a9cda7aa2d">&#9670;&#160;</a></span>set_debug()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_debug </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug_on</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>AT debugging, when enabled will print all data read and written, non-printable chars are printed as "[%d]". </p>
<p >AT debug can be enabled at compile time using MBED_CONF_CELLULAR_DEBUG_AT flag or at runtime calling <a class="el" href="classmbed_1_1_a_t_handler.html#a5a4b964705563b60a19700a9cda7aa2d" title="AT debugging, when enabled will print all data read and written, non-printable chars are printed as &quot;...">set_debug()</a>. Note that MBED_CONF_MBED_TRACE_ENABLE must also be enabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">debug_on</td><td>Enable/disable debugging </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a503daa9969b885c2f38623c0ce6d01a1" name="a503daa9969b885c2f38623c0ce6d01a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a503daa9969b885c2f38623c0ce6d01a1">&#9670;&#160;</a></span>get_debug()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool get_debug </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get degug state set by <a class="el" href="classmbed_1_1_a_t_handler.html#a5a4b964705563b60a19700a9cda7aa2d">set_debug</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>current state of debug </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>mbed</b></li><li class="navelem"><a class="el" href="classmbed_1_1_a_t_handler.html">ATHandler</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>

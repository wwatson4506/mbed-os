<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Mbed OS Reference: atomic functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="mbed-ce_55x55.png"/></td>
  <td id="projectalign">
   <div id="projectname">Mbed OS Reference
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__platform__atomic.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">atomic functions<div class="ingroups"><a class="el" href="group__mbed-os-public.html">Public API</a> &raquo; <a class="el" href="group__platform-public-api.html">Platform</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Atomic functions function analogously to C11 and C++11 - loads have acquire semantics, stores have release semantics, and atomic operations are sequentially consistent.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcore__util__atomic__flag.html">core_util_atomic_flag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A lock-free, primitive atomic flag.  <a href="structcore__util__atomic__flag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gaa8f56a572a9d71e864311c431ee1131a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gaa8f56a572a9d71e864311c431ee1131a">CORE_UTIL_ATOMIC_FLAG_INIT</a>&#160;&#160;&#160;{ 0 }</td></tr>
<tr class="memdesc:gaa8f56a572a9d71e864311c431ee1131a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializer for a <a class="el" href="structcore__util__atomic__flag.html" title="A lock-free, primitive atomic flag.">core_util_atomic_flag</a>.  <a href="group__platform__atomic.html#gaa8f56a572a9d71e864311c431ee1131a">More...</a><br /></td></tr>
<tr class="separator:gaa8f56a572a9d71e864311c431ee1131a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaf76273ffa0f2b491126baf28ba1af025"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gaf76273ffa0f2b491126baf28ba1af025">mbed_memory_order</a></td></tr>
<tr class="memdesc:gaf76273ffa0f2b491126baf28ba1af025"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory order constraints for atomic operations.  <a href="group__platform__atomic.html#gaf76273ffa0f2b491126baf28ba1af025">More...</a><br /></td></tr>
<tr class="separator:gaf76273ffa0f2b491126baf28ba1af025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab09a83ac4701fab4cec225b2dd08b7a8"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structcore__util__atomic__flag.html">core_util_atomic_flag</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gab09a83ac4701fab4cec225b2dd08b7a8">core_util_atomic_flag</a></td></tr>
<tr class="memdesc:gab09a83ac4701fab4cec225b2dd08b7a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">A lock-free, primitive atomic flag.  <a href="group__platform__atomic.html#gab09a83ac4701fab4cec225b2dd08b7a8">More...</a><br /></td></tr>
<tr class="separator:gab09a83ac4701fab4cec225b2dd08b7a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gaa770b34054b2e54c6bcbd0e9423ecd88"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> </td></tr>
<tr class="memdesc:gaa770b34054b2e54c6bcbd0e9423ecd88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory order constraints for atomic operations.  <a href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">More...</a><br /></td></tr>
<tr class="separator:gaa770b34054b2e54c6bcbd0e9423ecd88"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga38d0898d94b33af23bbbb56e358cdbdf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga38d0898d94b33af23bbbb56e358cdbdf">core_util_atomic_flag_test_and_set</a> (volatile <a class="el" href="structcore__util__atomic__flag.html">core_util_atomic_flag</a> *flagPtr)</td></tr>
<tr class="memdesc:ga38d0898d94b33af23bbbb56e358cdbdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic test and set.  <a href="group__platform__atomic.html#ga38d0898d94b33af23bbbb56e358cdbdf">More...</a><br /></td></tr>
<tr class="separator:ga38d0898d94b33af23bbbb56e358cdbdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1ec7ff4c7bd1126328ccfaff769adcb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gac1ec7ff4c7bd1126328ccfaff769adcb">core_util_atomic_flag_test_and_set_explicit</a> (volatile <a class="el" href="structcore__util__atomic__flag.html">core_util_atomic_flag</a> *flagPtr, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="memdesc:gac1ec7ff4c7bd1126328ccfaff769adcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic test and set.   <a href="group__platform__atomic.html#gac1ec7ff4c7bd1126328ccfaff769adcb">More...</a><br /></td></tr>
<tr class="separator:gac1ec7ff4c7bd1126328ccfaff769adcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe5e3f9d2bd9cf92276dacdc3928f4f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gafe5e3f9d2bd9cf92276dacdc3928f4f0">core_util_atomic_flag_clear</a> (volatile <a class="el" href="structcore__util__atomic__flag.html">core_util_atomic_flag</a> *flagPtr)</td></tr>
<tr class="memdesc:gafe5e3f9d2bd9cf92276dacdc3928f4f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic clear.  <a href="group__platform__atomic.html#gafe5e3f9d2bd9cf92276dacdc3928f4f0">More...</a><br /></td></tr>
<tr class="separator:gafe5e3f9d2bd9cf92276dacdc3928f4f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1918431bfda711a76ff391ae95f7cdd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gaa1918431bfda711a76ff391ae95f7cdd">core_util_atomic_flag_clear_explicit</a> (volatile <a class="el" href="structcore__util__atomic__flag.html">core_util_atomic_flag</a> *flagPtr, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="memdesc:gaa1918431bfda711a76ff391ae95f7cdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic clear.   <a href="group__platform__atomic.html#gaa1918431bfda711a76ff391ae95f7cdd">More...</a><br /></td></tr>
<tr class="separator:gaa1918431bfda711a76ff391ae95f7cdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c9ab0fa7ce3b902356e10951e622198"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga3c9ab0fa7ce3b902356e10951e622198">core_util_atomic_cas_u8</a> (volatile uint8_t *ptr, uint8_t *expectedCurrentValue, uint8_t desiredValue)</td></tr>
<tr class="memdesc:ga3c9ab0fa7ce3b902356e10951e622198"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic compare and set.  <a href="group__platform__atomic.html#ga3c9ab0fa7ce3b902356e10951e622198">More...</a><br /></td></tr>
<tr class="separator:ga3c9ab0fa7ce3b902356e10951e622198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93c9313f1a6be27bed9a3becfde0bee7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga93c9313f1a6be27bed9a3becfde0bee7">core_util_atomic_cas_explicit_u8</a> (volatile uint8_t *ptr, uint8_t *expectedCurrentValue, uint8_t desiredValue, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> success, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> failure)</td></tr>
<tr class="memdesc:ga93c9313f1a6be27bed9a3becfde0bee7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic compare and set.   <a href="group__platform__atomic.html#ga93c9313f1a6be27bed9a3becfde0bee7">More...</a><br /></td></tr>
<tr class="separator:ga93c9313f1a6be27bed9a3becfde0bee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95a29dd5791c91987be0fed54796f08e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga95a29dd5791c91987be0fed54796f08e">core_util_atomic_cas_u16</a> (volatile uint16_t *ptr, uint16_t *expectedCurrentValue, uint16_t desiredValue)</td></tr>
<tr class="memdesc:ga95a29dd5791c91987be0fed54796f08e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic compare and set.   <a href="group__platform__atomic.html#ga95a29dd5791c91987be0fed54796f08e">More...</a><br /></td></tr>
<tr class="separator:ga95a29dd5791c91987be0fed54796f08e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae923f73dccaad3e5bca9ce02ce47fbe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gaae923f73dccaad3e5bca9ce02ce47fbe">core_util_atomic_cas_explicit_u16</a> (volatile uint16_t *ptr, uint16_t *expectedCurrentValue, uint16_t desiredValue, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> success, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> failure)</td></tr>
<tr class="separator:gaae923f73dccaad3e5bca9ce02ce47fbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f1b5edfdabd05b7b2fc400a56e1f9b2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga8f1b5edfdabd05b7b2fc400a56e1f9b2">core_util_atomic_cas_u32</a> (volatile uint32_t *ptr, uint32_t *expectedCurrentValue, uint32_t desiredValue)</td></tr>
<tr class="memdesc:ga8f1b5edfdabd05b7b2fc400a56e1f9b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic compare and set.   <a href="group__platform__atomic.html#ga8f1b5edfdabd05b7b2fc400a56e1f9b2">More...</a><br /></td></tr>
<tr class="separator:ga8f1b5edfdabd05b7b2fc400a56e1f9b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87b4b2754592e31420d1f2b38593b8d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga87b4b2754592e31420d1f2b38593b8d7">core_util_atomic_cas_explicit_u32</a> (volatile uint32_t *ptr, uint32_t *expectedCurrentValue, uint32_t desiredValue, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> success, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> failure)</td></tr>
<tr class="separator:ga87b4b2754592e31420d1f2b38593b8d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85dd9c14f13cf180e6ecdaea8da6fe11"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga85dd9c14f13cf180e6ecdaea8da6fe11">core_util_atomic_cas_u64</a> (volatile uint64_t *ptr, uint64_t *expectedCurrentValue, uint64_t desiredValue)</td></tr>
<tr class="memdesc:ga85dd9c14f13cf180e6ecdaea8da6fe11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic compare and set.   <a href="group__platform__atomic.html#ga85dd9c14f13cf180e6ecdaea8da6fe11">More...</a><br /></td></tr>
<tr class="separator:ga85dd9c14f13cf180e6ecdaea8da6fe11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83dc3029317f487bfef8c984ee92cb06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga83dc3029317f487bfef8c984ee92cb06">core_util_atomic_cas_explicit_u64</a> (volatile uint64_t *ptr, uint64_t *expectedCurrentValue, uint64_t desiredValue, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> success, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> failure)</td></tr>
<tr class="separator:ga83dc3029317f487bfef8c984ee92cb06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45910fe69f1d67e6f85654e6b137ad3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga45910fe69f1d67e6f85654e6b137ad3c">core_util_atomic_cas_s8</a> (volatile int8_t *ptr, int8_t *expectedCurrentValue, int8_t desiredValue)</td></tr>
<tr class="memdesc:ga45910fe69f1d67e6f85654e6b137ad3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic compare and set.   <a href="group__platform__atomic.html#ga45910fe69f1d67e6f85654e6b137ad3c">More...</a><br /></td></tr>
<tr class="separator:ga45910fe69f1d67e6f85654e6b137ad3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad741471e0981d7dd88e15b7e285d3eb0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gad741471e0981d7dd88e15b7e285d3eb0">core_util_atomic_cas_explicit_s8</a> (volatile int8_t *ptr, int8_t *expectedCurrentValue, int8_t desiredValue, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> success, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> failure)</td></tr>
<tr class="separator:gad741471e0981d7dd88e15b7e285d3eb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05d84165af1254189e8c61166ce6b1ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga05d84165af1254189e8c61166ce6b1ff">core_util_atomic_cas_s16</a> (volatile int16_t *ptr, int16_t *expectedCurrentValue, int16_t desiredValue)</td></tr>
<tr class="memdesc:ga05d84165af1254189e8c61166ce6b1ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic compare and set.   <a href="group__platform__atomic.html#ga05d84165af1254189e8c61166ce6b1ff">More...</a><br /></td></tr>
<tr class="separator:ga05d84165af1254189e8c61166ce6b1ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf63939b06da44cb49a313698053aeb5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gacf63939b06da44cb49a313698053aeb5">core_util_atomic_cas_explicit_s16</a> (volatile int16_t *ptr, int16_t *expectedCurrentValue, int16_t desiredValue, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> success, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> failure)</td></tr>
<tr class="separator:gacf63939b06da44cb49a313698053aeb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga205688ff94fc52b0652c9399d38ed875"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga205688ff94fc52b0652c9399d38ed875">core_util_atomic_cas_s32</a> (volatile int32_t *ptr, int32_t *expectedCurrentValue, int32_t desiredValue)</td></tr>
<tr class="memdesc:ga205688ff94fc52b0652c9399d38ed875"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic compare and set.   <a href="group__platform__atomic.html#ga205688ff94fc52b0652c9399d38ed875">More...</a><br /></td></tr>
<tr class="separator:ga205688ff94fc52b0652c9399d38ed875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab572aa9bd7e1ded44f7e6adafb7fe13a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gab572aa9bd7e1ded44f7e6adafb7fe13a">core_util_atomic_cas_explicit_s32</a> (volatile int32_t *ptr, int32_t *expectedCurrentValue, int32_t desiredValue, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> success, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> failure)</td></tr>
<tr class="separator:gab572aa9bd7e1ded44f7e6adafb7fe13a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6eaa833099480b1cd7f87bb06d93da2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga6eaa833099480b1cd7f87bb06d93da2d">core_util_atomic_cas_s64</a> (volatile int64_t *ptr, int64_t *expectedCurrentValue, int64_t desiredValue)</td></tr>
<tr class="memdesc:ga6eaa833099480b1cd7f87bb06d93da2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic compare and set.   <a href="group__platform__atomic.html#ga6eaa833099480b1cd7f87bb06d93da2d">More...</a><br /></td></tr>
<tr class="separator:ga6eaa833099480b1cd7f87bb06d93da2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad69a97a89c2881c8a9584602e087729e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gad69a97a89c2881c8a9584602e087729e">core_util_atomic_cas_explicit_s64</a> (volatile int64_t *ptr, int64_t *expectedCurrentValue, int64_t desiredValue, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> success, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> failure)</td></tr>
<tr class="separator:gad69a97a89c2881c8a9584602e087729e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbf62e56b6923b86006b8f04c57b62e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gacbf62e56b6923b86006b8f04c57b62e2">core_util_atomic_cas_bool</a> (volatile bool *ptr, bool *expectedCurrentValue, bool desiredValue)</td></tr>
<tr class="memdesc:gacbf62e56b6923b86006b8f04c57b62e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic compare and set.   <a href="group__platform__atomic.html#gacbf62e56b6923b86006b8f04c57b62e2">More...</a><br /></td></tr>
<tr class="separator:gacbf62e56b6923b86006b8f04c57b62e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e8c63fcd66c95d8bf4b29d3bc3745bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga5e8c63fcd66c95d8bf4b29d3bc3745bb">core_util_atomic_cas_explicit_bool</a> (volatile bool *ptr, bool *expectedCurrentValue, bool desiredValue, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> success, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> failure)</td></tr>
<tr class="separator:ga5e8c63fcd66c95d8bf4b29d3bc3745bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9e9cbb15b6cae6154a5f85b483e9358"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gaf9e9cbb15b6cae6154a5f85b483e9358">core_util_atomic_cas_ptr</a> (void *volatile *ptr, void **expectedCurrentValue, void *desiredValue)</td></tr>
<tr class="memdesc:gaf9e9cbb15b6cae6154a5f85b483e9358"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic compare and set.   <a href="group__platform__atomic.html#gaf9e9cbb15b6cae6154a5f85b483e9358">More...</a><br /></td></tr>
<tr class="separator:gaf9e9cbb15b6cae6154a5f85b483e9358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c3370fd30e8d1721807aad74a7a4f44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga1c3370fd30e8d1721807aad74a7a4f44">core_util_atomic_cas_explicit_ptr</a> (void *volatile *ptr, void **expectedCurrentValue, void *desiredValue, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> success, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> failure)</td></tr>
<tr class="separator:ga1c3370fd30e8d1721807aad74a7a4f44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80da913bf93f3269a4e35af955f1c660"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga80da913bf93f3269a4e35af955f1c660">core_util_atomic_compare_exchange_weak_u8</a> (volatile uint8_t *ptr, uint8_t *expectedCurrentValue, uint8_t desiredValue)</td></tr>
<tr class="memdesc:ga80da913bf93f3269a4e35af955f1c660"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic compare and set.  <a href="group__platform__atomic.html#ga80da913bf93f3269a4e35af955f1c660">More...</a><br /></td></tr>
<tr class="separator:ga80da913bf93f3269a4e35af955f1c660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ea57a2b4c9d2958d6d4b9d981db3f63"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga8ea57a2b4c9d2958d6d4b9d981db3f63">core_util_atomic_compare_exchange_weak_explicit_u8</a> (volatile uint8_t *ptr, uint8_t *expectedCurrentValue, uint8_t desiredValue, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> success, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> failure)</td></tr>
<tr class="memdesc:ga8ea57a2b4c9d2958d6d4b9d981db3f63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic compare and set.   <a href="group__platform__atomic.html#ga8ea57a2b4c9d2958d6d4b9d981db3f63">More...</a><br /></td></tr>
<tr class="separator:ga8ea57a2b4c9d2958d6d4b9d981db3f63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c40ebfb654b853c353ecf67729b3b02"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga5c40ebfb654b853c353ecf67729b3b02">core_util_atomic_compare_exchange_weak_u16</a> (volatile uint16_t *ptr, uint16_t *expectedCurrentValue, uint16_t desiredValue)</td></tr>
<tr class="memdesc:ga5c40ebfb654b853c353ecf67729b3b02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic compare and set.   <a href="group__platform__atomic.html#ga5c40ebfb654b853c353ecf67729b3b02">More...</a><br /></td></tr>
<tr class="separator:ga5c40ebfb654b853c353ecf67729b3b02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5739219816da159aeaae5096ac4f074d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga5739219816da159aeaae5096ac4f074d">core_util_atomic_compare_exchange_weak_explicit_u16</a> (volatile uint16_t *ptr, uint16_t *expectedCurrentValue, uint16_t desiredValue, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> success, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> failure)</td></tr>
<tr class="separator:ga5739219816da159aeaae5096ac4f074d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga140f6e8e10012816365a8812a53cf072"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga140f6e8e10012816365a8812a53cf072">core_util_atomic_compare_exchange_weak_u32</a> (volatile uint32_t *ptr, uint32_t *expectedCurrentValue, uint32_t desiredValue)</td></tr>
<tr class="memdesc:ga140f6e8e10012816365a8812a53cf072"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic compare and set.   <a href="group__platform__atomic.html#ga140f6e8e10012816365a8812a53cf072">More...</a><br /></td></tr>
<tr class="separator:ga140f6e8e10012816365a8812a53cf072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafcc40dbc99cecfa5bac04ebd65c9c0a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gafcc40dbc99cecfa5bac04ebd65c9c0a5">core_util_atomic_compare_exchange_weak_explicit_u32</a> (volatile uint32_t *ptr, uint32_t *expectedCurrentValue, uint32_t desiredValue, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> success, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> failure)</td></tr>
<tr class="separator:gafcc40dbc99cecfa5bac04ebd65c9c0a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadaa71b8ed5127cb9591fed2cd524b1e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gaadaa71b8ed5127cb9591fed2cd524b1e">core_util_atomic_compare_exchange_weak_u64</a> (volatile uint64_t *ptr, uint64_t *expectedCurrentValue, uint64_t desiredValue)</td></tr>
<tr class="memdesc:gaadaa71b8ed5127cb9591fed2cd524b1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic compare and set.   <a href="group__platform__atomic.html#gaadaa71b8ed5127cb9591fed2cd524b1e">More...</a><br /></td></tr>
<tr class="separator:gaadaa71b8ed5127cb9591fed2cd524b1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb1873cce70f0814a2e65d2bcee84d74"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gabb1873cce70f0814a2e65d2bcee84d74">core_util_atomic_compare_exchange_weak_explicit_u64</a> (volatile uint64_t *ptr, uint64_t *expectedCurrentValue, uint64_t desiredValue, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> success, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> failure)</td></tr>
<tr class="separator:gabb1873cce70f0814a2e65d2bcee84d74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad18413a098f190ede59e9a7dd817480f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gad18413a098f190ede59e9a7dd817480f">core_util_atomic_compare_exchange_weak_s8</a> (volatile int8_t *ptr, int8_t *expectedCurrentValue, int8_t desiredValue)</td></tr>
<tr class="memdesc:gad18413a098f190ede59e9a7dd817480f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic compare and set.   <a href="group__platform__atomic.html#gad18413a098f190ede59e9a7dd817480f">More...</a><br /></td></tr>
<tr class="separator:gad18413a098f190ede59e9a7dd817480f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cdb3fd8dfde2fc0b1da38000982bda5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga6cdb3fd8dfde2fc0b1da38000982bda5">core_util_atomic_compare_exchange_weak_explicit_s8</a> (volatile int8_t *ptr, int8_t *expectedCurrentValue, int8_t desiredValue, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> success, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> failure)</td></tr>
<tr class="separator:ga6cdb3fd8dfde2fc0b1da38000982bda5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03b36d178f7b14331ac054ee7de7826e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga03b36d178f7b14331ac054ee7de7826e">core_util_atomic_compare_exchange_weak_s16</a> (volatile int16_t *ptr, int16_t *expectedCurrentValue, int16_t desiredValue)</td></tr>
<tr class="memdesc:ga03b36d178f7b14331ac054ee7de7826e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic compare and set.   <a href="group__platform__atomic.html#ga03b36d178f7b14331ac054ee7de7826e">More...</a><br /></td></tr>
<tr class="separator:ga03b36d178f7b14331ac054ee7de7826e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22e345fb761331b2883c063bc6505892"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga22e345fb761331b2883c063bc6505892">core_util_atomic_compare_exchange_weak_explicit_s16</a> (volatile int16_t *ptr, int16_t *expectedCurrentValue, int16_t desiredValue, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> success, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> failure)</td></tr>
<tr class="separator:ga22e345fb761331b2883c063bc6505892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeaf10dda44c9c989072495022edae918"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gaeaf10dda44c9c989072495022edae918">core_util_atomic_compare_exchange_weak_s32</a> (volatile int32_t *ptr, int32_t *expectedCurrentValue, int32_t desiredValue)</td></tr>
<tr class="memdesc:gaeaf10dda44c9c989072495022edae918"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic compare and set.   <a href="group__platform__atomic.html#gaeaf10dda44c9c989072495022edae918">More...</a><br /></td></tr>
<tr class="separator:gaeaf10dda44c9c989072495022edae918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7686b4293e7ea7bf4950dd5db438c3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gad7686b4293e7ea7bf4950dd5db438c3d">core_util_atomic_compare_exchange_weak_explicit_s32</a> (volatile int32_t *ptr, int32_t *expectedCurrentValue, int32_t desiredValue, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> success, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> failure)</td></tr>
<tr class="separator:gad7686b4293e7ea7bf4950dd5db438c3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86d26060ebf45bc519c5e769b369977a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga86d26060ebf45bc519c5e769b369977a">core_util_atomic_compare_exchange_weak_s64</a> (volatile int64_t *ptr, int64_t *expectedCurrentValue, int64_t desiredValue)</td></tr>
<tr class="memdesc:ga86d26060ebf45bc519c5e769b369977a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic compare and set.   <a href="group__platform__atomic.html#ga86d26060ebf45bc519c5e769b369977a">More...</a><br /></td></tr>
<tr class="separator:ga86d26060ebf45bc519c5e769b369977a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae818c803e9b789a9155f2582957284cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gae818c803e9b789a9155f2582957284cc">core_util_atomic_compare_exchange_weak_explicit_s64</a> (volatile int64_t *ptr, int64_t *expectedCurrentValue, int64_t desiredValue, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> success, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> failure)</td></tr>
<tr class="separator:gae818c803e9b789a9155f2582957284cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1d769b78dbd7f22cbb904d7b768ca45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gab1d769b78dbd7f22cbb904d7b768ca45">core_util_atomic_compare_exchange_weak_bool</a> (volatile bool *ptr, bool *expectedCurrentValue, bool desiredValue)</td></tr>
<tr class="memdesc:gab1d769b78dbd7f22cbb904d7b768ca45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic compare and set.   <a href="group__platform__atomic.html#gab1d769b78dbd7f22cbb904d7b768ca45">More...</a><br /></td></tr>
<tr class="separator:gab1d769b78dbd7f22cbb904d7b768ca45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadeec7abf1f4deb39287ae36d53e543b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gadeec7abf1f4deb39287ae36d53e543b4">core_util_atomic_compare_exchange_weak_explicit_bool</a> (volatile bool *ptr, bool *expectedCurrentValue, bool desiredValue, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> success, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> failure)</td></tr>
<tr class="separator:gadeec7abf1f4deb39287ae36d53e543b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1778c0381b19ace75e5228c4be8448d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gaf1778c0381b19ace75e5228c4be8448d">core_util_atomic_compare_exchange_weak_ptr</a> (void *volatile *ptr, void **expectedCurrentValue, void *desiredValue)</td></tr>
<tr class="memdesc:gaf1778c0381b19ace75e5228c4be8448d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic compare and set.   <a href="group__platform__atomic.html#gaf1778c0381b19ace75e5228c4be8448d">More...</a><br /></td></tr>
<tr class="separator:gaf1778c0381b19ace75e5228c4be8448d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ad9cc64f6c880a1608a120f41c8ffbb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga0ad9cc64f6c880a1608a120f41c8ffbb">core_util_atomic_compare_exchange_weak_explicit_ptr</a> (void *volatile *ptr, void **expectedCurrentValue, void *desiredValue, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> success, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> failure)</td></tr>
<tr class="separator:ga0ad9cc64f6c880a1608a120f41c8ffbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2840954e59468ea85b91e17ca50ad009"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga2840954e59468ea85b91e17ca50ad009">core_util_atomic_load_u8</a> (const volatile uint8_t *valuePtr)</td></tr>
<tr class="memdesc:ga2840954e59468ea85b91e17ca50ad009"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic load.  <a href="group__platform__atomic.html#ga2840954e59468ea85b91e17ca50ad009">More...</a><br /></td></tr>
<tr class="separator:ga2840954e59468ea85b91e17ca50ad009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b5b21126d2a22858faaf8018b5e66f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga4b5b21126d2a22858faaf8018b5e66f9">core_util_atomic_load_explicit_u8</a> (const volatile uint8_t *valuePtr, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="memdesc:ga4b5b21126d2a22858faaf8018b5e66f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic load with explicit ordering.  <a href="group__platform__atomic.html#ga4b5b21126d2a22858faaf8018b5e66f9">More...</a><br /></td></tr>
<tr class="separator:ga4b5b21126d2a22858faaf8018b5e66f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b13b1196ed2a63802d7acf2ea08aaf4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga6b13b1196ed2a63802d7acf2ea08aaf4">core_util_atomic_load_u16</a> (const volatile uint16_t *valuePtr)</td></tr>
<tr class="separator:ga6b13b1196ed2a63802d7acf2ea08aaf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a81771e47a93b508d6ec3f4666b506e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga2a81771e47a93b508d6ec3f4666b506e">core_util_atomic_load_explicit_u16</a> (const volatile uint16_t *valuePtr, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:ga2a81771e47a93b508d6ec3f4666b506e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade580faac99dbf59aeda5da1e4c213ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gade580faac99dbf59aeda5da1e4c213ad">core_util_atomic_load_u32</a> (const volatile uint32_t *valuePtr)</td></tr>
<tr class="separator:gade580faac99dbf59aeda5da1e4c213ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa85935b1f85886bd69c028aad61d16ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gaa85935b1f85886bd69c028aad61d16ce">core_util_atomic_load_explicit_u32</a> (const volatile uint32_t *valuePtr, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:gaa85935b1f85886bd69c028aad61d16ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae79f750b7b18b9b6c54b9f67c235195f"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gae79f750b7b18b9b6c54b9f67c235195f">core_util_atomic_load_u64</a> (const volatile uint64_t *valuePtr)</td></tr>
<tr class="separator:gae79f750b7b18b9b6c54b9f67c235195f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf24e043d3f39b59e5c4e53f7d39558d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gaf24e043d3f39b59e5c4e53f7d39558d0">core_util_atomic_load_explicit_u64</a> (const volatile uint64_t *valuePtr, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:gaf24e043d3f39b59e5c4e53f7d39558d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeecfddc99e71a90287f0220e8fd3e206"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gaeecfddc99e71a90287f0220e8fd3e206">core_util_atomic_load_s8</a> (const volatile int8_t *valuePtr)</td></tr>
<tr class="separator:gaeecfddc99e71a90287f0220e8fd3e206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga765734c8f47168fbf2e1d3583466df96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga765734c8f47168fbf2e1d3583466df96">core_util_atomic_load_explicit_s8</a> (const volatile int8_t *valuePtr, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:ga765734c8f47168fbf2e1d3583466df96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga663356b18705a1c4ae4d87643ae239f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga663356b18705a1c4ae4d87643ae239f6">core_util_atomic_load_s16</a> (const volatile int16_t *valuePtr)</td></tr>
<tr class="separator:ga663356b18705a1c4ae4d87643ae239f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99004d90211c9e8b31d40a5a86312a8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga99004d90211c9e8b31d40a5a86312a8f">core_util_atomic_load_explicit_s16</a> (const volatile int16_t *valuePtr, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:ga99004d90211c9e8b31d40a5a86312a8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1994aaeae2efb36b58051da401a95b36"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga1994aaeae2efb36b58051da401a95b36">core_util_atomic_load_s32</a> (const volatile int32_t *valuePtr)</td></tr>
<tr class="separator:ga1994aaeae2efb36b58051da401a95b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a70e0153206702a003de75ffe9b86aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga5a70e0153206702a003de75ffe9b86aa">core_util_atomic_load_explicit_s32</a> (const volatile int32_t *valuePtr, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:ga5a70e0153206702a003de75ffe9b86aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga100297ebd80cd21846398c6ad7d81f43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga100297ebd80cd21846398c6ad7d81f43">core_util_atomic_load_s64</a> (const volatile int64_t *valuePtr)</td></tr>
<tr class="separator:ga100297ebd80cd21846398c6ad7d81f43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga426c13fee706b73968b19273be5544fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga426c13fee706b73968b19273be5544fd">core_util_atomic_load_explicit_s64</a> (const volatile int64_t *valuePtr, <a class="el" href="group__platform__toolchain.html#ga3e0b3dc191a8e64de80be44bbc8d5193">MBED_UNUSED</a> <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="memdesc:ga426c13fee706b73968b19273be5544fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic load with explicit ordering.  <a href="group__platform__atomic.html#ga426c13fee706b73968b19273be5544fd">More...</a><br /></td></tr>
<tr class="separator:ga426c13fee706b73968b19273be5544fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba968e929680be76321b4c639287f968"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gaba968e929680be76321b4c639287f968">core_util_atomic_load_bool</a> (const volatile bool *valuePtr)</td></tr>
<tr class="separator:gaba968e929680be76321b4c639287f968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b4b4c68346a582ed810f5a42f9083e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga2b4b4c68346a582ed810f5a42f9083e6">core_util_atomic_load_explicit_bool</a> (const volatile bool *valuePtr, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:ga2b4b4c68346a582ed810f5a42f9083e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87170ad015a30beac00a7764b456c7ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga87170ad015a30beac00a7764b456c7ea">core_util_atomic_load_ptr</a> (void *const volatile *valuePtr)</td></tr>
<tr class="separator:ga87170ad015a30beac00a7764b456c7ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ce10c2fe84037a9ffc96d99090f154a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga9ce10c2fe84037a9ffc96d99090f154a">core_util_atomic_load_explicit_ptr</a> (void *const volatile *valuePtr, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:ga9ce10c2fe84037a9ffc96d99090f154a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5c3fa6d415e012c34c7c82056817f29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gaf5c3fa6d415e012c34c7c82056817f29">core_util_atomic_store_u8</a> (volatile uint8_t *valuePtr, uint8_t desiredValue)</td></tr>
<tr class="memdesc:gaf5c3fa6d415e012c34c7c82056817f29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic store.  <a href="group__platform__atomic.html#gaf5c3fa6d415e012c34c7c82056817f29">More...</a><br /></td></tr>
<tr class="separator:gaf5c3fa6d415e012c34c7c82056817f29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca1cdaf85b894b8bccb88e870577f324"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gaca1cdaf85b894b8bccb88e870577f324">core_util_atomic_store_explicit_u8</a> (volatile uint8_t *valuePtr, uint8_t desiredValue, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="memdesc:gaca1cdaf85b894b8bccb88e870577f324"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic store with explicit ordering.  <a href="group__platform__atomic.html#gaca1cdaf85b894b8bccb88e870577f324">More...</a><br /></td></tr>
<tr class="separator:gaca1cdaf85b894b8bccb88e870577f324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f38862b163d1a943b28dabfd39fc8ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga2f38862b163d1a943b28dabfd39fc8ef">core_util_atomic_store_u16</a> (volatile uint16_t *valuePtr, uint16_t desiredValue)</td></tr>
<tr class="separator:ga2f38862b163d1a943b28dabfd39fc8ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad81d69ed6094e7cd6cfb1f3b729955fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gad81d69ed6094e7cd6cfb1f3b729955fc">core_util_atomic_store_explicit_u16</a> (volatile uint16_t *valuePtr, uint16_t desiredValue, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:gad81d69ed6094e7cd6cfb1f3b729955fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga981dd31a80f495369723280424a3999e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga981dd31a80f495369723280424a3999e">core_util_atomic_store_u32</a> (volatile uint32_t *valuePtr, uint32_t desiredValue)</td></tr>
<tr class="separator:ga981dd31a80f495369723280424a3999e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2960e2d63e4c37c93f202cbb597189a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga2960e2d63e4c37c93f202cbb597189a9">core_util_atomic_store_explicit_u32</a> (volatile uint32_t *valuePtr, uint32_t desiredValue, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:ga2960e2d63e4c37c93f202cbb597189a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaffb39f69f9e80d787404bcdc627bd39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gaaffb39f69f9e80d787404bcdc627bd39">core_util_atomic_store_u64</a> (volatile uint64_t *valuePtr, uint64_t desiredValue)</td></tr>
<tr class="separator:gaaffb39f69f9e80d787404bcdc627bd39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad54a248229f8606e148c9708c7237334"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gad54a248229f8606e148c9708c7237334">core_util_atomic_store_explicit_u64</a> (volatile uint64_t *valuePtr, uint64_t desiredValue, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:gad54a248229f8606e148c9708c7237334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2024d6b1bd77f35d0bd27b9abeaca252"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga2024d6b1bd77f35d0bd27b9abeaca252">core_util_atomic_store_s8</a> (volatile int8_t *valuePtr, int8_t desiredValue)</td></tr>
<tr class="separator:ga2024d6b1bd77f35d0bd27b9abeaca252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga361bc02b02df102a3f3ddf0ae84a9df0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga361bc02b02df102a3f3ddf0ae84a9df0">core_util_atomic_store_explicit_s8</a> (volatile int8_t *valuePtr, int8_t desiredValue, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:ga361bc02b02df102a3f3ddf0ae84a9df0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae67ef75f813610e1bd3804b4cfa22565"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gae67ef75f813610e1bd3804b4cfa22565">core_util_atomic_store_s16</a> (volatile int16_t *valuePtr, int16_t desiredValue)</td></tr>
<tr class="separator:gae67ef75f813610e1bd3804b4cfa22565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedd333e4cab3877d64f041e538cff66b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gaedd333e4cab3877d64f041e538cff66b">core_util_atomic_store_explicit_s16</a> (volatile int16_t *valuePtr, int16_t desiredValue, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:gaedd333e4cab3877d64f041e538cff66b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63d826b01dc7aae7c3a473c349f0ee32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga63d826b01dc7aae7c3a473c349f0ee32">core_util_atomic_store_s32</a> (volatile int32_t *valuePtr, int32_t desiredValue)</td></tr>
<tr class="separator:ga63d826b01dc7aae7c3a473c349f0ee32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b27494dba292ef9caa12d164b7a1b9d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga3b27494dba292ef9caa12d164b7a1b9d">core_util_atomic_store_explicit_s32</a> (volatile int32_t *valuePtr, int32_t desiredValue, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:ga3b27494dba292ef9caa12d164b7a1b9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15431b3da92b29949c1d597f425c7a07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga15431b3da92b29949c1d597f425c7a07">core_util_atomic_store_s64</a> (volatile int64_t *valuePtr, int64_t desiredValue)</td></tr>
<tr class="separator:ga15431b3da92b29949c1d597f425c7a07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade28bd9fce9c1c0f448eab73cb00e460"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gade28bd9fce9c1c0f448eab73cb00e460">core_util_atomic_store_explicit_s64</a> (volatile int64_t *valuePtr, int64_t desiredValue, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:gade28bd9fce9c1c0f448eab73cb00e460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4692889cc8d1bd170af962728be04dc3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga4692889cc8d1bd170af962728be04dc3">core_util_atomic_store_bool</a> (volatile bool *valuePtr, bool desiredValue)</td></tr>
<tr class="separator:ga4692889cc8d1bd170af962728be04dc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9ca948b9322559e941dd359400ae4fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gab9ca948b9322559e941dd359400ae4fe">core_util_atomic_store_explicit_bool</a> (volatile bool *valuePtr, bool desiredValue, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:gab9ca948b9322559e941dd359400ae4fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa112a4db89b94efa5f785035415f0d5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gaa112a4db89b94efa5f785035415f0d5a">core_util_atomic_store_ptr</a> (void *volatile *valuePtr, void *desiredValue)</td></tr>
<tr class="separator:gaa112a4db89b94efa5f785035415f0d5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca4ebe09fe2de1ddc6ce8151baefc991"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gaca4ebe09fe2de1ddc6ce8151baefc991">core_util_atomic_store_explicit_ptr</a> (void *volatile *valuePtr, void *desiredValue, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:gaca4ebe09fe2de1ddc6ce8151baefc991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59e7a27bc6ea2f39a9ebaad40859bfe5"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga59e7a27bc6ea2f39a9ebaad40859bfe5">core_util_atomic_exchange_u8</a> (volatile uint8_t *valuePtr, uint8_t desiredValue)</td></tr>
<tr class="memdesc:ga59e7a27bc6ea2f39a9ebaad40859bfe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic exchange.  <a href="group__platform__atomic.html#ga59e7a27bc6ea2f39a9ebaad40859bfe5">More...</a><br /></td></tr>
<tr class="separator:ga59e7a27bc6ea2f39a9ebaad40859bfe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7780847ac95064b466ea04bad2a61a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gac7780847ac95064b466ea04bad2a61a2">core_util_atomic_exchange_explicit_u8</a> (volatile uint8_t *valuePtr, uint8_t desiredValue, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="memdesc:gac7780847ac95064b466ea04bad2a61a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic exchange.   <a href="group__platform__atomic.html#gac7780847ac95064b466ea04bad2a61a2">More...</a><br /></td></tr>
<tr class="separator:gac7780847ac95064b466ea04bad2a61a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8bff86f0c961096d11b9e4f1b7069ae"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gae8bff86f0c961096d11b9e4f1b7069ae">core_util_atomic_exchange_u16</a> (volatile uint16_t *valuePtr, uint16_t desiredValue)</td></tr>
<tr class="memdesc:gae8bff86f0c961096d11b9e4f1b7069ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic exchange.   <a href="group__platform__atomic.html#gae8bff86f0c961096d11b9e4f1b7069ae">More...</a><br /></td></tr>
<tr class="separator:gae8bff86f0c961096d11b9e4f1b7069ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09407fb1c3ba1c8518e09b75bc12c6e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga09407fb1c3ba1c8518e09b75bc12c6e0">core_util_atomic_exchange_explicit_u16</a> (volatile uint16_t *valuePtr, uint16_t desiredValue, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:ga09407fb1c3ba1c8518e09b75bc12c6e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22e6020a2efeda8cce823c38b8d223d0"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga22e6020a2efeda8cce823c38b8d223d0">core_util_atomic_exchange_u32</a> (volatile uint32_t *valuePtr, uint32_t desiredValue)</td></tr>
<tr class="memdesc:ga22e6020a2efeda8cce823c38b8d223d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic exchange.   <a href="group__platform__atomic.html#ga22e6020a2efeda8cce823c38b8d223d0">More...</a><br /></td></tr>
<tr class="separator:ga22e6020a2efeda8cce823c38b8d223d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cd0876d934c04cf3d097d6048d5b94c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga3cd0876d934c04cf3d097d6048d5b94c">core_util_atomic_exchange_explicit_u32</a> (volatile uint32_t *valuePtr, uint32_t desiredValue, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:ga3cd0876d934c04cf3d097d6048d5b94c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a53ffc716df9594b56a94fca8ce5cf7"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga7a53ffc716df9594b56a94fca8ce5cf7">core_util_atomic_exchange_u64</a> (volatile uint64_t *valuePtr, uint64_t desiredValue)</td></tr>
<tr class="memdesc:ga7a53ffc716df9594b56a94fca8ce5cf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic exchange.   <a href="group__platform__atomic.html#ga7a53ffc716df9594b56a94fca8ce5cf7">More...</a><br /></td></tr>
<tr class="separator:ga7a53ffc716df9594b56a94fca8ce5cf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab492757a2fc1fdaed58f56877126fc85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gab492757a2fc1fdaed58f56877126fc85">core_util_atomic_exchange_explicit_u64</a> (volatile uint64_t *valuePtr, uint64_t desiredValue, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:gab492757a2fc1fdaed58f56877126fc85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c915efbc7c77b3c72328783af87277d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga9c915efbc7c77b3c72328783af87277d">core_util_atomic_exchange_s8</a> (volatile int8_t *valuePtr, int8_t desiredValue)</td></tr>
<tr class="memdesc:ga9c915efbc7c77b3c72328783af87277d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic exchange.   <a href="group__platform__atomic.html#ga9c915efbc7c77b3c72328783af87277d">More...</a><br /></td></tr>
<tr class="separator:ga9c915efbc7c77b3c72328783af87277d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab32133579ae8ddda64548e209f85a282"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gab32133579ae8ddda64548e209f85a282">core_util_atomic_exchange_explicit_s8</a> (volatile int8_t *valuePtr, int8_t desiredValue, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:gab32133579ae8ddda64548e209f85a282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad02cc6c6d66a90be4b943dd02a682089"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gad02cc6c6d66a90be4b943dd02a682089">core_util_atomic_exchange_s16</a> (volatile int16_t *valuePtr, int16_t desiredValue)</td></tr>
<tr class="memdesc:gad02cc6c6d66a90be4b943dd02a682089"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic exchange.   <a href="group__platform__atomic.html#gad02cc6c6d66a90be4b943dd02a682089">More...</a><br /></td></tr>
<tr class="separator:gad02cc6c6d66a90be4b943dd02a682089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ff86a2b74166999e50784676e624a9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga3ff86a2b74166999e50784676e624a9c">core_util_atomic_exchange_explicit_s16</a> (volatile int16_t *valuePtr, int16_t desiredValue, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:ga3ff86a2b74166999e50784676e624a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5592ae0738feab92516d27d14c0921b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gaa5592ae0738feab92516d27d14c0921b">core_util_atomic_exchange_s32</a> (volatile int32_t *valuePtr, int32_t desiredValue)</td></tr>
<tr class="memdesc:gaa5592ae0738feab92516d27d14c0921b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic exchange.   <a href="group__platform__atomic.html#gaa5592ae0738feab92516d27d14c0921b">More...</a><br /></td></tr>
<tr class="separator:gaa5592ae0738feab92516d27d14c0921b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf601f85ee6eff49b498bd02d5355b986"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gaf601f85ee6eff49b498bd02d5355b986">core_util_atomic_exchange_explicit_s32</a> (volatile int32_t *valuePtr, int32_t desiredValue, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:gaf601f85ee6eff49b498bd02d5355b986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac09a70a91d5b50e5e4d18af85f8224de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gac09a70a91d5b50e5e4d18af85f8224de">core_util_atomic_exchange_s64</a> (volatile int64_t *valuePtr, int64_t desiredValue)</td></tr>
<tr class="memdesc:gac09a70a91d5b50e5e4d18af85f8224de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic exchange.   <a href="group__platform__atomic.html#gac09a70a91d5b50e5e4d18af85f8224de">More...</a><br /></td></tr>
<tr class="separator:gac09a70a91d5b50e5e4d18af85f8224de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44a1020edbe4b1cfc98cb2470b228c07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga44a1020edbe4b1cfc98cb2470b228c07">core_util_atomic_exchange_explicit_s64</a> (volatile int64_t *valuePtr, int64_t desiredValue, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:ga44a1020edbe4b1cfc98cb2470b228c07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga085fd843aab08f03815e6925b7b56e35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga085fd843aab08f03815e6925b7b56e35">core_util_atomic_exchange_bool</a> (volatile bool *valuePtr, bool desiredValue)</td></tr>
<tr class="memdesc:ga085fd843aab08f03815e6925b7b56e35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic exchange.   <a href="group__platform__atomic.html#ga085fd843aab08f03815e6925b7b56e35">More...</a><br /></td></tr>
<tr class="separator:ga085fd843aab08f03815e6925b7b56e35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11616204b0007487d3607cfd0036e966"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga11616204b0007487d3607cfd0036e966">core_util_atomic_exchange_explicit_bool</a> (volatile bool *valuePtr, bool desiredValue, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:ga11616204b0007487d3607cfd0036e966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd245e89bb0303090ea1f880823ccde3"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gadd245e89bb0303090ea1f880823ccde3">core_util_atomic_exchange_ptr</a> (void *volatile *valuePtr, void *desiredValue)</td></tr>
<tr class="memdesc:gadd245e89bb0303090ea1f880823ccde3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic exchange.   <a href="group__platform__atomic.html#gadd245e89bb0303090ea1f880823ccde3">More...</a><br /></td></tr>
<tr class="separator:gadd245e89bb0303090ea1f880823ccde3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga373b2f859a298cb11ef3186816033c33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga373b2f859a298cb11ef3186816033c33">core_util_atomic_exchange_explicit_ptr</a> (void *volatile *valuePtr, void *desiredValue, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:ga373b2f859a298cb11ef3186816033c33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b2738cdb036dd4bf42c8a496107b3c9"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga7b2738cdb036dd4bf42c8a496107b3c9">core_util_atomic_incr_u8</a> (volatile uint8_t *valuePtr, uint8_t delta)</td></tr>
<tr class="memdesc:ga7b2738cdb036dd4bf42c8a496107b3c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic increment.  <a href="group__platform__atomic.html#ga7b2738cdb036dd4bf42c8a496107b3c9">More...</a><br /></td></tr>
<tr class="separator:ga7b2738cdb036dd4bf42c8a496107b3c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf11cb4e3404afe3549a26c852934c8df"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gaf11cb4e3404afe3549a26c852934c8df">core_util_atomic_incr_u16</a> (volatile uint16_t *valuePtr, uint16_t delta)</td></tr>
<tr class="memdesc:gaf11cb4e3404afe3549a26c852934c8df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic increment.   <a href="group__platform__atomic.html#gaf11cb4e3404afe3549a26c852934c8df">More...</a><br /></td></tr>
<tr class="separator:gaf11cb4e3404afe3549a26c852934c8df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a9fd9661ae1db338cd776ba45f3ad33"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga4a9fd9661ae1db338cd776ba45f3ad33">core_util_atomic_incr_u32</a> (volatile uint32_t *valuePtr, uint32_t delta)</td></tr>
<tr class="memdesc:ga4a9fd9661ae1db338cd776ba45f3ad33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic increment.   <a href="group__platform__atomic.html#ga4a9fd9661ae1db338cd776ba45f3ad33">More...</a><br /></td></tr>
<tr class="separator:ga4a9fd9661ae1db338cd776ba45f3ad33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1da475be0bf8e7d9e7cd16177e3d13a5"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga1da475be0bf8e7d9e7cd16177e3d13a5">core_util_atomic_incr_u64</a> (volatile uint64_t *valuePtr, uint64_t delta)</td></tr>
<tr class="memdesc:ga1da475be0bf8e7d9e7cd16177e3d13a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic increment.   <a href="group__platform__atomic.html#ga1da475be0bf8e7d9e7cd16177e3d13a5">More...</a><br /></td></tr>
<tr class="separator:ga1da475be0bf8e7d9e7cd16177e3d13a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad991d615f9643f15f883e6c4638fe31e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gad991d615f9643f15f883e6c4638fe31e">core_util_atomic_incr_s8</a> (volatile int8_t *valuePtr, int8_t delta)</td></tr>
<tr class="memdesc:gad991d615f9643f15f883e6c4638fe31e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic increment.   <a href="group__platform__atomic.html#gad991d615f9643f15f883e6c4638fe31e">More...</a><br /></td></tr>
<tr class="separator:gad991d615f9643f15f883e6c4638fe31e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf71073f46116c910e80c0c4c7409b995"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gaf71073f46116c910e80c0c4c7409b995">core_util_atomic_incr_s16</a> (volatile int16_t *valuePtr, int16_t delta)</td></tr>
<tr class="memdesc:gaf71073f46116c910e80c0c4c7409b995"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic increment.   <a href="group__platform__atomic.html#gaf71073f46116c910e80c0c4c7409b995">More...</a><br /></td></tr>
<tr class="separator:gaf71073f46116c910e80c0c4c7409b995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad1b7864af7323246bd38768aff11cf8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gaad1b7864af7323246bd38768aff11cf8">core_util_atomic_incr_s32</a> (volatile int32_t *valuePtr, int32_t delta)</td></tr>
<tr class="memdesc:gaad1b7864af7323246bd38768aff11cf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic increment.   <a href="group__platform__atomic.html#gaad1b7864af7323246bd38768aff11cf8">More...</a><br /></td></tr>
<tr class="separator:gaad1b7864af7323246bd38768aff11cf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8058a48a1ddde0bfd1900f9fc789eca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gad8058a48a1ddde0bfd1900f9fc789eca">core_util_atomic_incr_s64</a> (volatile int64_t *valuePtr, int64_t delta)</td></tr>
<tr class="memdesc:gad8058a48a1ddde0bfd1900f9fc789eca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic increment.   <a href="group__platform__atomic.html#gad8058a48a1ddde0bfd1900f9fc789eca">More...</a><br /></td></tr>
<tr class="separator:gad8058a48a1ddde0bfd1900f9fc789eca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga552c51b9a90675e7f5c70d3769e2c5e8"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga552c51b9a90675e7f5c70d3769e2c5e8">core_util_atomic_incr_ptr</a> (void *volatile *valuePtr, ptrdiff_t delta)</td></tr>
<tr class="memdesc:ga552c51b9a90675e7f5c70d3769e2c5e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic increment.   <a href="group__platform__atomic.html#ga552c51b9a90675e7f5c70d3769e2c5e8">More...</a><br /></td></tr>
<tr class="separator:ga552c51b9a90675e7f5c70d3769e2c5e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22c32f3db5d87ca5ba9661f9efbaa205"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga22c32f3db5d87ca5ba9661f9efbaa205">core_util_atomic_decr_u8</a> (volatile uint8_t *valuePtr, uint8_t delta)</td></tr>
<tr class="memdesc:ga22c32f3db5d87ca5ba9661f9efbaa205"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic decrement.  <a href="group__platform__atomic.html#ga22c32f3db5d87ca5ba9661f9efbaa205">More...</a><br /></td></tr>
<tr class="separator:ga22c32f3db5d87ca5ba9661f9efbaa205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga732744dc1479c273c7f096117a92ff83"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga732744dc1479c273c7f096117a92ff83">core_util_atomic_decr_u16</a> (volatile uint16_t *valuePtr, uint16_t delta)</td></tr>
<tr class="memdesc:ga732744dc1479c273c7f096117a92ff83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic decrement.   <a href="group__platform__atomic.html#ga732744dc1479c273c7f096117a92ff83">More...</a><br /></td></tr>
<tr class="separator:ga732744dc1479c273c7f096117a92ff83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5cff540da859622ef0fce52f2c25bc6"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gaa5cff540da859622ef0fce52f2c25bc6">core_util_atomic_decr_u32</a> (volatile uint32_t *valuePtr, uint32_t delta)</td></tr>
<tr class="memdesc:gaa5cff540da859622ef0fce52f2c25bc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic decrement.   <a href="group__platform__atomic.html#gaa5cff540da859622ef0fce52f2c25bc6">More...</a><br /></td></tr>
<tr class="separator:gaa5cff540da859622ef0fce52f2c25bc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad40c29bee47dc525faefb7544cce2ac0"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gad40c29bee47dc525faefb7544cce2ac0">core_util_atomic_decr_u64</a> (volatile uint64_t *valuePtr, uint64_t delta)</td></tr>
<tr class="memdesc:gad40c29bee47dc525faefb7544cce2ac0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic decrement.   <a href="group__platform__atomic.html#gad40c29bee47dc525faefb7544cce2ac0">More...</a><br /></td></tr>
<tr class="separator:gad40c29bee47dc525faefb7544cce2ac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadeb322baa1bd668947e5f0bfd3134283"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gadeb322baa1bd668947e5f0bfd3134283">core_util_atomic_decr_s8</a> (volatile int8_t *valuePtr, int8_t delta)</td></tr>
<tr class="memdesc:gadeb322baa1bd668947e5f0bfd3134283"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic decrement.   <a href="group__platform__atomic.html#gadeb322baa1bd668947e5f0bfd3134283">More...</a><br /></td></tr>
<tr class="separator:gadeb322baa1bd668947e5f0bfd3134283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga752f3c2b1a007fb57340d827087c7acf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga752f3c2b1a007fb57340d827087c7acf">core_util_atomic_decr_s16</a> (volatile int16_t *valuePtr, int16_t delta)</td></tr>
<tr class="memdesc:ga752f3c2b1a007fb57340d827087c7acf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic decrement.   <a href="group__platform__atomic.html#ga752f3c2b1a007fb57340d827087c7acf">More...</a><br /></td></tr>
<tr class="separator:ga752f3c2b1a007fb57340d827087c7acf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89ffa4563fded0662921120ec752c4e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga89ffa4563fded0662921120ec752c4e9">core_util_atomic_decr_s32</a> (volatile int32_t *valuePtr, int32_t delta)</td></tr>
<tr class="memdesc:ga89ffa4563fded0662921120ec752c4e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic decrement.   <a href="group__platform__atomic.html#ga89ffa4563fded0662921120ec752c4e9">More...</a><br /></td></tr>
<tr class="separator:ga89ffa4563fded0662921120ec752c4e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1aded12e7bbd8250c0f9392617141829"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga1aded12e7bbd8250c0f9392617141829">core_util_atomic_decr_s64</a> (volatile int64_t *valuePtr, int64_t delta)</td></tr>
<tr class="memdesc:ga1aded12e7bbd8250c0f9392617141829"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic decrement.   <a href="group__platform__atomic.html#ga1aded12e7bbd8250c0f9392617141829">More...</a><br /></td></tr>
<tr class="separator:ga1aded12e7bbd8250c0f9392617141829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43270010ce23b14d180cac14b0070137"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga43270010ce23b14d180cac14b0070137">core_util_atomic_decr_ptr</a> (void *volatile *valuePtr, ptrdiff_t delta)</td></tr>
<tr class="memdesc:ga43270010ce23b14d180cac14b0070137"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic decrement.   <a href="group__platform__atomic.html#ga43270010ce23b14d180cac14b0070137">More...</a><br /></td></tr>
<tr class="separator:ga43270010ce23b14d180cac14b0070137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc7672b3ff5038e7e408a79b2d367d85"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gafc7672b3ff5038e7e408a79b2d367d85">core_util_atomic_fetch_add_u8</a> (volatile uint8_t *valuePtr, uint8_t arg)</td></tr>
<tr class="memdesc:gafc7672b3ff5038e7e408a79b2d367d85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic add.  <a href="group__platform__atomic.html#gafc7672b3ff5038e7e408a79b2d367d85">More...</a><br /></td></tr>
<tr class="separator:gafc7672b3ff5038e7e408a79b2d367d85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga651ae50190ea63b037e38c1e3d058f62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga651ae50190ea63b037e38c1e3d058f62">core_util_atomic_fetch_add_explicit_u8</a> (volatile uint8_t *valuePtr, uint8_t arg, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="memdesc:ga651ae50190ea63b037e38c1e3d058f62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic add.   <a href="group__platform__atomic.html#ga651ae50190ea63b037e38c1e3d058f62">More...</a><br /></td></tr>
<tr class="separator:ga651ae50190ea63b037e38c1e3d058f62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2891e6f81e0f7753001610fcf27d1a14"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga2891e6f81e0f7753001610fcf27d1a14">core_util_atomic_fetch_add_u16</a> (volatile uint16_t *valuePtr, uint16_t arg)</td></tr>
<tr class="memdesc:ga2891e6f81e0f7753001610fcf27d1a14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic add.   <a href="group__platform__atomic.html#ga2891e6f81e0f7753001610fcf27d1a14">More...</a><br /></td></tr>
<tr class="separator:ga2891e6f81e0f7753001610fcf27d1a14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b1fe9a8547ec4ba9be99695c2d10688"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga9b1fe9a8547ec4ba9be99695c2d10688">core_util_atomic_fetch_add_explicit_u16</a> (volatile uint16_t *valuePtr, uint16_t arg, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:ga9b1fe9a8547ec4ba9be99695c2d10688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8433a277473c8be2ecf2636b215482a4"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga8433a277473c8be2ecf2636b215482a4">core_util_atomic_fetch_add_u32</a> (volatile uint32_t *valuePtr, uint32_t arg)</td></tr>
<tr class="memdesc:ga8433a277473c8be2ecf2636b215482a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic add.   <a href="group__platform__atomic.html#ga8433a277473c8be2ecf2636b215482a4">More...</a><br /></td></tr>
<tr class="separator:ga8433a277473c8be2ecf2636b215482a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e2cf84841529895574591de06da0a81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga6e2cf84841529895574591de06da0a81">core_util_atomic_fetch_add_explicit_u32</a> (volatile uint32_t *valuePtr, uint32_t arg, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:ga6e2cf84841529895574591de06da0a81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccdbfedfdbdad88c8f18caf0a3212f9b"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gaccdbfedfdbdad88c8f18caf0a3212f9b">core_util_atomic_fetch_add_u64</a> (volatile uint64_t *valuePtr, uint64_t arg)</td></tr>
<tr class="memdesc:gaccdbfedfdbdad88c8f18caf0a3212f9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic add.   <a href="group__platform__atomic.html#gaccdbfedfdbdad88c8f18caf0a3212f9b">More...</a><br /></td></tr>
<tr class="separator:gaccdbfedfdbdad88c8f18caf0a3212f9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52a5a54967b6603caad8a7013b5603d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga52a5a54967b6603caad8a7013b5603d4">core_util_atomic_fetch_add_explicit_u64</a> (volatile uint64_t *valuePtr, uint64_t arg, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:ga52a5a54967b6603caad8a7013b5603d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab749485f59e3e2d83e62ee565aeca6f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gab749485f59e3e2d83e62ee565aeca6f5">core_util_atomic_fetch_add_s8</a> (volatile int8_t *valuePtr, int8_t arg)</td></tr>
<tr class="memdesc:gab749485f59e3e2d83e62ee565aeca6f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic add.   <a href="group__platform__atomic.html#gab749485f59e3e2d83e62ee565aeca6f5">More...</a><br /></td></tr>
<tr class="separator:gab749485f59e3e2d83e62ee565aeca6f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4d95c74bb5c805196eb6f001704474e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gad4d95c74bb5c805196eb6f001704474e">core_util_atomic_fetch_add_explicit_s8</a> (volatile int8_t *valuePtr, int8_t arg, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:gad4d95c74bb5c805196eb6f001704474e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadacb556c12ab10eb1bac2ce28d837415"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gadacb556c12ab10eb1bac2ce28d837415">core_util_atomic_fetch_add_s16</a> (volatile int16_t *valuePtr, int16_t arg)</td></tr>
<tr class="memdesc:gadacb556c12ab10eb1bac2ce28d837415"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic add.   <a href="group__platform__atomic.html#gadacb556c12ab10eb1bac2ce28d837415">More...</a><br /></td></tr>
<tr class="separator:gadacb556c12ab10eb1bac2ce28d837415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeec6975ddf7e77d74ade6d5157b89224"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gaeec6975ddf7e77d74ade6d5157b89224">core_util_atomic_fetch_add_explicit_s16</a> (volatile int16_t *valuePtr, int16_t arg, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:gaeec6975ddf7e77d74ade6d5157b89224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ce4cf4be0c038e724bc5be4d03d9026"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga5ce4cf4be0c038e724bc5be4d03d9026">core_util_atomic_fetch_add_s32</a> (volatile int32_t *valuePtr, int32_t arg)</td></tr>
<tr class="memdesc:ga5ce4cf4be0c038e724bc5be4d03d9026"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic add.   <a href="group__platform__atomic.html#ga5ce4cf4be0c038e724bc5be4d03d9026">More...</a><br /></td></tr>
<tr class="separator:ga5ce4cf4be0c038e724bc5be4d03d9026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e312ade8a7e075e99b146628909800c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga7e312ade8a7e075e99b146628909800c">core_util_atomic_fetch_add_explicit_s32</a> (volatile int32_t *valuePtr, int32_t arg, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:ga7e312ade8a7e075e99b146628909800c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71166f17a0453072cb2a53c9b2c70b50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga71166f17a0453072cb2a53c9b2c70b50">core_util_atomic_fetch_add_s64</a> (volatile int64_t *valuePtr, int64_t arg)</td></tr>
<tr class="memdesc:ga71166f17a0453072cb2a53c9b2c70b50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic add.   <a href="group__platform__atomic.html#ga71166f17a0453072cb2a53c9b2c70b50">More...</a><br /></td></tr>
<tr class="separator:ga71166f17a0453072cb2a53c9b2c70b50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga529c15151f84f8d992f0b7b73b89114c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga529c15151f84f8d992f0b7b73b89114c">core_util_atomic_fetch_add_explicit_s64</a> (volatile int64_t *valuePtr, int64_t arg, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:ga529c15151f84f8d992f0b7b73b89114c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b970ad6426c9488eacff7a8b60f7c9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga1b970ad6426c9488eacff7a8b60f7c9a">core_util_atomic_fetch_add_ptr</a> (void *volatile *valuePtr, ptrdiff_t arg)</td></tr>
<tr class="memdesc:ga1b970ad6426c9488eacff7a8b60f7c9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic add.   <a href="group__platform__atomic.html#ga1b970ad6426c9488eacff7a8b60f7c9a">More...</a><br /></td></tr>
<tr class="separator:ga1b970ad6426c9488eacff7a8b60f7c9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga612c1b23f221aaeb1ea9eec37c9e0924"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga612c1b23f221aaeb1ea9eec37c9e0924">core_util_atomic_fetch_add_explicit_ptr</a> (void *volatile *valuePtr, ptrdiff_t arg, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:ga612c1b23f221aaeb1ea9eec37c9e0924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacdd384cefb5b5c96e336c280af3d9334"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gacdd384cefb5b5c96e336c280af3d9334">core_util_atomic_fetch_sub_u8</a> (volatile uint8_t *valuePtr, uint8_t arg)</td></tr>
<tr class="memdesc:gacdd384cefb5b5c96e336c280af3d9334"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic subtract.  <a href="group__platform__atomic.html#gacdd384cefb5b5c96e336c280af3d9334">More...</a><br /></td></tr>
<tr class="separator:gacdd384cefb5b5c96e336c280af3d9334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0cdf17854e749a41ffb1ef1c9391ccb1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga0cdf17854e749a41ffb1ef1c9391ccb1">core_util_atomic_fetch_sub_explicit_u8</a> (volatile uint8_t *valuePtr, uint8_t arg, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="memdesc:ga0cdf17854e749a41ffb1ef1c9391ccb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic subtract.   <a href="group__platform__atomic.html#ga0cdf17854e749a41ffb1ef1c9391ccb1">More...</a><br /></td></tr>
<tr class="separator:ga0cdf17854e749a41ffb1ef1c9391ccb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a8cab6163f0c3971217a0a4b6eedc3f"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga3a8cab6163f0c3971217a0a4b6eedc3f">core_util_atomic_fetch_sub_u16</a> (volatile uint16_t *valuePtr, uint16_t arg)</td></tr>
<tr class="memdesc:ga3a8cab6163f0c3971217a0a4b6eedc3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic subtract.   <a href="group__platform__atomic.html#ga3a8cab6163f0c3971217a0a4b6eedc3f">More...</a><br /></td></tr>
<tr class="separator:ga3a8cab6163f0c3971217a0a4b6eedc3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef713cf9e4b240fc9333ae986a64f3ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gaef713cf9e4b240fc9333ae986a64f3ad">core_util_atomic_fetch_sub_explicit_u16</a> (volatile uint16_t *valuePtr, uint16_t arg, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:gaef713cf9e4b240fc9333ae986a64f3ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a439187827f741048fc07f4cc6fd0f5"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga6a439187827f741048fc07f4cc6fd0f5">core_util_atomic_fetch_sub_u32</a> (volatile uint32_t *valuePtr, uint32_t arg)</td></tr>
<tr class="memdesc:ga6a439187827f741048fc07f4cc6fd0f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic subtract.   <a href="group__platform__atomic.html#ga6a439187827f741048fc07f4cc6fd0f5">More...</a><br /></td></tr>
<tr class="separator:ga6a439187827f741048fc07f4cc6fd0f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a744e93eda19b361077c2d283f69c11"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga6a744e93eda19b361077c2d283f69c11">core_util_atomic_fetch_sub_explicit_u32</a> (volatile uint32_t *valuePtr, uint32_t arg, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:ga6a744e93eda19b361077c2d283f69c11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63f7d9554d99b226c04021bf058809e9"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga63f7d9554d99b226c04021bf058809e9">core_util_atomic_fetch_sub_u64</a> (volatile uint64_t *valuePtr, uint64_t arg)</td></tr>
<tr class="memdesc:ga63f7d9554d99b226c04021bf058809e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic subtract.   <a href="group__platform__atomic.html#ga63f7d9554d99b226c04021bf058809e9">More...</a><br /></td></tr>
<tr class="separator:ga63f7d9554d99b226c04021bf058809e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf71e00325c1ca7d78bfec53182c972a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gaf71e00325c1ca7d78bfec53182c972a1">core_util_atomic_fetch_sub_explicit_u64</a> (volatile uint64_t *valuePtr, uint64_t arg, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:gaf71e00325c1ca7d78bfec53182c972a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b868ca82165d3e1e86ff8cb3cc45878"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga9b868ca82165d3e1e86ff8cb3cc45878">core_util_atomic_fetch_sub_s8</a> (volatile int8_t *valuePtr, int8_t arg)</td></tr>
<tr class="memdesc:ga9b868ca82165d3e1e86ff8cb3cc45878"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic subtract.   <a href="group__platform__atomic.html#ga9b868ca82165d3e1e86ff8cb3cc45878">More...</a><br /></td></tr>
<tr class="separator:ga9b868ca82165d3e1e86ff8cb3cc45878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc7d33c43f941840f436513972cffdf1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gafc7d33c43f941840f436513972cffdf1">core_util_atomic_fetch_sub_explicit_s8</a> (volatile int8_t *valuePtr, int8_t arg, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:gafc7d33c43f941840f436513972cffdf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b1f99cad729bd49aa63c570a968a489"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga1b1f99cad729bd49aa63c570a968a489">core_util_atomic_fetch_sub_s16</a> (volatile int16_t *valuePtr, int16_t arg)</td></tr>
<tr class="memdesc:ga1b1f99cad729bd49aa63c570a968a489"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic subtract.   <a href="group__platform__atomic.html#ga1b1f99cad729bd49aa63c570a968a489">More...</a><br /></td></tr>
<tr class="separator:ga1b1f99cad729bd49aa63c570a968a489"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3198e21d50306edeca33e63eb6121613"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga3198e21d50306edeca33e63eb6121613">core_util_atomic_fetch_sub_explicit_s16</a> (volatile int16_t *valuePtr, int16_t arg, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:ga3198e21d50306edeca33e63eb6121613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8dce75d68ca82cb52baeb761d6abee3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gaf8dce75d68ca82cb52baeb761d6abee3">core_util_atomic_fetch_sub_s32</a> (volatile int32_t *valuePtr, int32_t arg)</td></tr>
<tr class="memdesc:gaf8dce75d68ca82cb52baeb761d6abee3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic subtract.   <a href="group__platform__atomic.html#gaf8dce75d68ca82cb52baeb761d6abee3">More...</a><br /></td></tr>
<tr class="separator:gaf8dce75d68ca82cb52baeb761d6abee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga038e3bea482bb48b4d2cec13a568c382"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga038e3bea482bb48b4d2cec13a568c382">core_util_atomic_fetch_sub_explicit_s32</a> (volatile int32_t *valuePtr, int32_t arg, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:ga038e3bea482bb48b4d2cec13a568c382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17bf4f676b1bf6a95e8fd98fd02fe63d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga17bf4f676b1bf6a95e8fd98fd02fe63d">core_util_atomic_fetch_sub_s64</a> (volatile int64_t *valuePtr, int64_t arg)</td></tr>
<tr class="memdesc:ga17bf4f676b1bf6a95e8fd98fd02fe63d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic subtract.   <a href="group__platform__atomic.html#ga17bf4f676b1bf6a95e8fd98fd02fe63d">More...</a><br /></td></tr>
<tr class="separator:ga17bf4f676b1bf6a95e8fd98fd02fe63d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga644d915b39e49bf2d83f44d3b5762927"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga644d915b39e49bf2d83f44d3b5762927">core_util_atomic_fetch_sub_explicit_s64</a> (volatile int64_t *valuePtr, int64_t arg, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:ga644d915b39e49bf2d83f44d3b5762927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga693d6b9a52e7334f01b6893d132cecb1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga693d6b9a52e7334f01b6893d132cecb1">core_util_atomic_fetch_sub_ptr</a> (void *volatile *valuePtr, ptrdiff_t arg)</td></tr>
<tr class="memdesc:ga693d6b9a52e7334f01b6893d132cecb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic subtract.   <a href="group__platform__atomic.html#ga693d6b9a52e7334f01b6893d132cecb1">More...</a><br /></td></tr>
<tr class="separator:ga693d6b9a52e7334f01b6893d132cecb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga096af7149a60b608b9c528530d61a232"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga096af7149a60b608b9c528530d61a232">core_util_atomic_fetch_sub_explicit_ptr</a> (void *volatile *valuePtr, ptrdiff_t arg, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:ga096af7149a60b608b9c528530d61a232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac71103feba0ddbe9bee54759e3d1ef50"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gac71103feba0ddbe9bee54759e3d1ef50">core_util_atomic_fetch_and_u8</a> (volatile uint8_t *valuePtr, uint8_t arg)</td></tr>
<tr class="memdesc:gac71103feba0ddbe9bee54759e3d1ef50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic bitwise and.  <a href="group__platform__atomic.html#gac71103feba0ddbe9bee54759e3d1ef50">More...</a><br /></td></tr>
<tr class="separator:gac71103feba0ddbe9bee54759e3d1ef50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga118df0bb30ca68d2be8c084be472289b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga118df0bb30ca68d2be8c084be472289b">core_util_atomic_fetch_and_explicit_u8</a> (volatile uint8_t *valuePtr, uint8_t arg, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="memdesc:ga118df0bb30ca68d2be8c084be472289b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic bitwise and.   <a href="group__platform__atomic.html#ga118df0bb30ca68d2be8c084be472289b">More...</a><br /></td></tr>
<tr class="separator:ga118df0bb30ca68d2be8c084be472289b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0503c7ae8ed7e9105c9827bf564b2af6"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga0503c7ae8ed7e9105c9827bf564b2af6">core_util_atomic_fetch_and_u16</a> (volatile uint16_t *valuePtr, uint16_t arg)</td></tr>
<tr class="memdesc:ga0503c7ae8ed7e9105c9827bf564b2af6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic bitwise and.   <a href="group__platform__atomic.html#ga0503c7ae8ed7e9105c9827bf564b2af6">More...</a><br /></td></tr>
<tr class="separator:ga0503c7ae8ed7e9105c9827bf564b2af6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb2f48d1bb656d61c0dc92f255c6f21a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gaeb2f48d1bb656d61c0dc92f255c6f21a">core_util_atomic_fetch_and_explicit_u16</a> (volatile uint16_t *valuePtr, uint16_t arg, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:gaeb2f48d1bb656d61c0dc92f255c6f21a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa578cdd3776051931ada26258029733e"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gaa578cdd3776051931ada26258029733e">core_util_atomic_fetch_and_u32</a> (volatile uint32_t *valuePtr, uint32_t arg)</td></tr>
<tr class="memdesc:gaa578cdd3776051931ada26258029733e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic bitwise and.   <a href="group__platform__atomic.html#gaa578cdd3776051931ada26258029733e">More...</a><br /></td></tr>
<tr class="separator:gaa578cdd3776051931ada26258029733e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6169b1a76622a0260d8ce24f2a27a071"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga6169b1a76622a0260d8ce24f2a27a071">core_util_atomic_fetch_and_explicit_u32</a> (volatile uint32_t *valuePtr, uint32_t arg, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:ga6169b1a76622a0260d8ce24f2a27a071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf9ca48255c2fb18551881f37b86f004"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gacf9ca48255c2fb18551881f37b86f004">core_util_atomic_fetch_and_u64</a> (volatile uint64_t *valuePtr, uint64_t arg)</td></tr>
<tr class="memdesc:gacf9ca48255c2fb18551881f37b86f004"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic bitwise and.   <a href="group__platform__atomic.html#gacf9ca48255c2fb18551881f37b86f004">More...</a><br /></td></tr>
<tr class="separator:gacf9ca48255c2fb18551881f37b86f004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2969415714af3a77fbb565e78328a4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gac2969415714af3a77fbb565e78328a4f">core_util_atomic_fetch_and_explicit_u64</a> (volatile uint64_t *valuePtr, uint64_t arg, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:gac2969415714af3a77fbb565e78328a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9a6253c2c2c213f10a8238ac68f834f"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gad9a6253c2c2c213f10a8238ac68f834f">core_util_atomic_fetch_or_u8</a> (volatile uint8_t *valuePtr, uint8_t arg)</td></tr>
<tr class="memdesc:gad9a6253c2c2c213f10a8238ac68f834f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic bitwise inclusive or.  <a href="group__platform__atomic.html#gad9a6253c2c2c213f10a8238ac68f834f">More...</a><br /></td></tr>
<tr class="separator:gad9a6253c2c2c213f10a8238ac68f834f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19a483c3c606c7a95e539c269937b3fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga19a483c3c606c7a95e539c269937b3fa">core_util_atomic_fetch_or_explicit_u8</a> (volatile uint8_t *valuePtr, uint8_t arg, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="memdesc:ga19a483c3c606c7a95e539c269937b3fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic bitwise inclusive or.   <a href="group__platform__atomic.html#ga19a483c3c606c7a95e539c269937b3fa">More...</a><br /></td></tr>
<tr class="separator:ga19a483c3c606c7a95e539c269937b3fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5171ff450449f9ec9e0cb58b5586aa43"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga5171ff450449f9ec9e0cb58b5586aa43">core_util_atomic_fetch_or_u16</a> (volatile uint16_t *valuePtr, uint16_t arg)</td></tr>
<tr class="memdesc:ga5171ff450449f9ec9e0cb58b5586aa43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic bitwise inclusive or.   <a href="group__platform__atomic.html#ga5171ff450449f9ec9e0cb58b5586aa43">More...</a><br /></td></tr>
<tr class="separator:ga5171ff450449f9ec9e0cb58b5586aa43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffa1ebeb601da04d37d5e7170e52505d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gaffa1ebeb601da04d37d5e7170e52505d">core_util_atomic_fetch_or_explicit_u16</a> (volatile uint16_t *valuePtr, uint16_t arg, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:gaffa1ebeb601da04d37d5e7170e52505d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad20c7d38345c87afbbc1de568c4a2ea0"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gad20c7d38345c87afbbc1de568c4a2ea0">core_util_atomic_fetch_or_u32</a> (volatile uint32_t *valuePtr, uint32_t arg)</td></tr>
<tr class="memdesc:gad20c7d38345c87afbbc1de568c4a2ea0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic bitwise inclusive or.   <a href="group__platform__atomic.html#gad20c7d38345c87afbbc1de568c4a2ea0">More...</a><br /></td></tr>
<tr class="separator:gad20c7d38345c87afbbc1de568c4a2ea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga987adeb2ae9c2db2551a61aa4b426df2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga987adeb2ae9c2db2551a61aa4b426df2">core_util_atomic_fetch_or_explicit_u32</a> (volatile uint32_t *valuePtr, uint32_t arg, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:ga987adeb2ae9c2db2551a61aa4b426df2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8c5f724d821fa01783eeb9f9b6654bc"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gaa8c5f724d821fa01783eeb9f9b6654bc">core_util_atomic_fetch_or_u64</a> (volatile uint64_t *valuePtr, uint64_t arg)</td></tr>
<tr class="memdesc:gaa8c5f724d821fa01783eeb9f9b6654bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic bitwise inclusive or.   <a href="group__platform__atomic.html#gaa8c5f724d821fa01783eeb9f9b6654bc">More...</a><br /></td></tr>
<tr class="separator:gaa8c5f724d821fa01783eeb9f9b6654bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7733cc83af1260afd5484d9f8ab64a52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga7733cc83af1260afd5484d9f8ab64a52">core_util_atomic_fetch_or_explicit_u64</a> (volatile uint64_t *valuePtr, uint64_t arg, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:ga7733cc83af1260afd5484d9f8ab64a52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf176a784cfb5373edfc0c729cf3f528"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gacf176a784cfb5373edfc0c729cf3f528">core_util_atomic_fetch_xor_u8</a> (volatile uint8_t *valuePtr, uint8_t arg)</td></tr>
<tr class="memdesc:gacf176a784cfb5373edfc0c729cf3f528"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic bitwise exclusive or.  <a href="group__platform__atomic.html#gacf176a784cfb5373edfc0c729cf3f528">More...</a><br /></td></tr>
<tr class="separator:gacf176a784cfb5373edfc0c729cf3f528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f687c46f29f48b760123770f9cf30f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga7f687c46f29f48b760123770f9cf30f8">core_util_atomic_fetch_xor_explicit_u8</a> (volatile uint8_t *valuePtr, uint8_t arg, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="memdesc:ga7f687c46f29f48b760123770f9cf30f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic bitwise exclusive or.   <a href="group__platform__atomic.html#ga7f687c46f29f48b760123770f9cf30f8">More...</a><br /></td></tr>
<tr class="separator:ga7f687c46f29f48b760123770f9cf30f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e10fc29b3da441a87484046a9d3e41f"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga6e10fc29b3da441a87484046a9d3e41f">core_util_atomic_fetch_xor_u16</a> (volatile uint16_t *valuePtr, uint16_t arg)</td></tr>
<tr class="memdesc:ga6e10fc29b3da441a87484046a9d3e41f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic bitwise exclusive or.   <a href="group__platform__atomic.html#ga6e10fc29b3da441a87484046a9d3e41f">More...</a><br /></td></tr>
<tr class="separator:ga6e10fc29b3da441a87484046a9d3e41f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0cac1f70d86145102d3bf1ceaaed4b54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga0cac1f70d86145102d3bf1ceaaed4b54">core_util_atomic_fetch_xor_explicit_u16</a> (volatile uint16_t *valuePtr, uint16_t arg, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:ga0cac1f70d86145102d3bf1ceaaed4b54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19cbc4d57409b5eb0ebfc8eee9cd829b"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga19cbc4d57409b5eb0ebfc8eee9cd829b">core_util_atomic_fetch_xor_u32</a> (volatile uint32_t *valuePtr, uint32_t arg)</td></tr>
<tr class="memdesc:ga19cbc4d57409b5eb0ebfc8eee9cd829b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic bitwise exclusive or.   <a href="group__platform__atomic.html#ga19cbc4d57409b5eb0ebfc8eee9cd829b">More...</a><br /></td></tr>
<tr class="separator:ga19cbc4d57409b5eb0ebfc8eee9cd829b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cf9e78a72b5ed55edcb09240af4e187"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga7cf9e78a72b5ed55edcb09240af4e187">core_util_atomic_fetch_xor_explicit_u32</a> (volatile uint32_t *valuePtr, uint32_t arg, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:ga7cf9e78a72b5ed55edcb09240af4e187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b70c15733c776dbcae1a7ee5c056201"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga6b70c15733c776dbcae1a7ee5c056201">core_util_atomic_fetch_xor_u64</a> (volatile uint64_t *valuePtr, uint64_t arg)</td></tr>
<tr class="memdesc:ga6b70c15733c776dbcae1a7ee5c056201"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic bitwise exclusive or.   <a href="group__platform__atomic.html#ga6b70c15733c776dbcae1a7ee5c056201">More...</a><br /></td></tr>
<tr class="separator:ga6b70c15733c776dbcae1a7ee5c056201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cda9f9445bbace6d20e5ae02bc4a6e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga3cda9f9445bbace6d20e5ae02bc4a6e8">core_util_atomic_fetch_xor_explicit_u64</a> (volatile uint64_t *valuePtr, uint64_t arg, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order)</td></tr>
<tr class="separator:ga3cda9f9445bbace6d20e5ae02bc4a6e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab4e48feaf31dd4fd5907a2b3a3c1aeb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaab4e48feaf31dd4fd5907a2b3a3c1aeb"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gaab4e48feaf31dd4fd5907a2b3a3c1aeb">core_util_atomic_load</a> (const volatile T *valuePtr) noexcept</td></tr>
<tr class="separator:gaab4e48feaf31dd4fd5907a2b3a3c1aeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf006841d45fa1b4c91177e7004d4b306"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaf006841d45fa1b4c91177e7004d4b306"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gaf006841d45fa1b4c91177e7004d4b306">core_util_atomic_load</a> (const T *valuePtr) noexcept</td></tr>
<tr class="separator:gaf006841d45fa1b4c91177e7004d4b306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga306f116d8f794c82ba15c443295ca6a1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga306f116d8f794c82ba15c443295ca6a1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga306f116d8f794c82ba15c443295ca6a1">core_util_atomic_store</a> (volatile T *valuePtr, mstd::type_identity_t&lt; T &gt; desiredValue) noexcept</td></tr>
<tr class="separator:ga306f116d8f794c82ba15c443295ca6a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada6132d54ca4aec79c65c19c7088ca3c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gada6132d54ca4aec79c65c19c7088ca3c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gada6132d54ca4aec79c65c19c7088ca3c">core_util_atomic_store</a> (T *valuePtr, mstd::type_identity_t&lt; T &gt; desiredValue) noexcept</td></tr>
<tr class="separator:gada6132d54ca4aec79c65c19c7088ca3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6006fb07b7f607cfb37151e4b4b56acb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga6006fb07b7f607cfb37151e4b4b56acb"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga6006fb07b7f607cfb37151e4b4b56acb">core_util_atomic_exchange</a> (volatile T *valuePtr, mstd::type_identity_t&lt; T &gt; desiredValue) noexcept</td></tr>
<tr class="memdesc:ga6006fb07b7f607cfb37151e4b4b56acb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic exchange.   <a href="group__platform__atomic.html#ga6006fb07b7f607cfb37151e4b4b56acb">More...</a><br /></td></tr>
<tr class="separator:ga6006fb07b7f607cfb37151e4b4b56acb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13e01d7aae5e46ac2a329eb64a2a3359"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga13e01d7aae5e46ac2a329eb64a2a3359"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga13e01d7aae5e46ac2a329eb64a2a3359">core_util_atomic_compare_exchange_strong</a> (volatile T *ptr, mstd::type_identity_t&lt; T &gt; *expectedCurrentValue, mstd::type_identity_t&lt; T &gt; desiredValue) noexcept</td></tr>
<tr class="memdesc:ga13e01d7aae5e46ac2a329eb64a2a3359"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic compare and set.   <a href="group__platform__atomic.html#ga13e01d7aae5e46ac2a329eb64a2a3359">More...</a><br /></td></tr>
<tr class="separator:ga13e01d7aae5e46ac2a329eb64a2a3359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1045786030aaf939a0becfbc0c698d14"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga1045786030aaf939a0becfbc0c698d14"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga1045786030aaf939a0becfbc0c698d14">core_util_atomic_compare_exchange_weak</a> (volatile T *ptr, mstd::type_identity_t&lt; T &gt; *expectedCurrentValue, mstd::type_identity_t&lt; T &gt; desiredValue) noexcept</td></tr>
<tr class="memdesc:ga1045786030aaf939a0becfbc0c698d14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic compare and set.   <a href="group__platform__atomic.html#ga1045786030aaf939a0becfbc0c698d14">More...</a><br /></td></tr>
<tr class="separator:ga1045786030aaf939a0becfbc0c698d14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68e506e93fabb79d88e8d187a7ac62ff"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga68e506e93fabb79d88e8d187a7ac62ff"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga68e506e93fabb79d88e8d187a7ac62ff">core_util_atomic_fetch_add</a> (volatile T *valuePtr, mstd::type_identity_t&lt; T &gt; arg) noexcept</td></tr>
<tr class="memdesc:ga68e506e93fabb79d88e8d187a7ac62ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic add.   <a href="group__platform__atomic.html#ga68e506e93fabb79d88e8d187a7ac62ff">More...</a><br /></td></tr>
<tr class="separator:ga68e506e93fabb79d88e8d187a7ac62ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad69d7ef911a6a98e49193bda39af720a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gad69d7ef911a6a98e49193bda39af720a"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gad69d7ef911a6a98e49193bda39af720a">core_util_atomic_fetch_sub</a> (volatile T *valuePtr, mstd::type_identity_t&lt; T &gt; arg) noexcept</td></tr>
<tr class="memdesc:gad69d7ef911a6a98e49193bda39af720a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic subtract.   <a href="group__platform__atomic.html#gad69d7ef911a6a98e49193bda39af720a">More...</a><br /></td></tr>
<tr class="separator:gad69d7ef911a6a98e49193bda39af720a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0396fbe5d7c594033d4a02a6c09617b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gad0396fbe5d7c594033d4a02a6c09617b"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gad0396fbe5d7c594033d4a02a6c09617b">core_util_atomic_fetch_and</a> (volatile T *valuePtr, mstd::type_identity_t&lt; T &gt; arg) noexcept</td></tr>
<tr class="memdesc:gad0396fbe5d7c594033d4a02a6c09617b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic bitwise and.   <a href="group__platform__atomic.html#gad0396fbe5d7c594033d4a02a6c09617b">More...</a><br /></td></tr>
<tr class="separator:gad0396fbe5d7c594033d4a02a6c09617b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6c08979b782ee2e7970a57d77ab9247"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gab6c08979b782ee2e7970a57d77ab9247"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gab6c08979b782ee2e7970a57d77ab9247">core_util_atomic_fetch_or</a> (volatile T *valuePtr, mstd::type_identity_t&lt; T &gt; arg) noexcept</td></tr>
<tr class="memdesc:gab6c08979b782ee2e7970a57d77ab9247"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic bitwise inclusive or.   <a href="group__platform__atomic.html#gab6c08979b782ee2e7970a57d77ab9247">More...</a><br /></td></tr>
<tr class="separator:gab6c08979b782ee2e7970a57d77ab9247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga662a921cf2a19b168ddd5451f19ea25e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga662a921cf2a19b168ddd5451f19ea25e"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga662a921cf2a19b168ddd5451f19ea25e">core_util_atomic_fetch_xor</a> (volatile T *valuePtr, mstd::type_identity_t&lt; T &gt; arg) noexcept</td></tr>
<tr class="memdesc:ga662a921cf2a19b168ddd5451f19ea25e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic bitwise exclusive or.   <a href="group__platform__atomic.html#ga662a921cf2a19b168ddd5451f19ea25e">More...</a><br /></td></tr>
<tr class="separator:ga662a921cf2a19b168ddd5451f19ea25e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58aba5c200df94e819ecb0caac03d7b0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga58aba5c200df94e819ecb0caac03d7b0"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga58aba5c200df94e819ecb0caac03d7b0">core_util_atomic_load_explicit</a> (const volatile T *valuePtr, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order) noexcept</td></tr>
<tr class="separator:ga58aba5c200df94e819ecb0caac03d7b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e4b392e7dbc3f101c7f1c11dedd0099"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga3e4b392e7dbc3f101c7f1c11dedd0099"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga3e4b392e7dbc3f101c7f1c11dedd0099">core_util_atomic_load_explicit</a> (const T *valuePtr, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order) noexcept</td></tr>
<tr class="separator:ga3e4b392e7dbc3f101c7f1c11dedd0099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadef7d72ccdaf35745d619aebbd8af2db"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gadef7d72ccdaf35745d619aebbd8af2db"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gadef7d72ccdaf35745d619aebbd8af2db">core_util_atomic_store_explicit</a> (volatile T *valuePtr, mstd::type_identity_t&lt; T &gt; desiredValue, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order) noexcept</td></tr>
<tr class="separator:gadef7d72ccdaf35745d619aebbd8af2db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ea8c38ac4b519d90d5056ff2266558d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga6ea8c38ac4b519d90d5056ff2266558d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga6ea8c38ac4b519d90d5056ff2266558d">core_util_atomic_store_explicit</a> (T *valuePtr, mstd::type_identity_t&lt; T &gt; desiredValue, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order) noexcept</td></tr>
<tr class="separator:ga6ea8c38ac4b519d90d5056ff2266558d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad440e6b45a3f1d4d6f7241b2e1e9decd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gad440e6b45a3f1d4d6f7241b2e1e9decd"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gad440e6b45a3f1d4d6f7241b2e1e9decd">core_util_atomic_exchange_explicit</a> (volatile T *valuePtr, mstd::type_identity_t&lt; T &gt; desiredValue, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order) noexcept</td></tr>
<tr class="separator:gad440e6b45a3f1d4d6f7241b2e1e9decd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfd30eaf5f8bff0c904836c301e5e9b5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gabfd30eaf5f8bff0c904836c301e5e9b5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gabfd30eaf5f8bff0c904836c301e5e9b5">core_util_atomic_compare_exchange_strong_explicit</a> (volatile T *ptr, mstd::type_identity_t&lt; T &gt; *expectedCurrentValue, mstd::type_identity_t&lt; T &gt; desiredValue, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> success, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> failure) noexcept</td></tr>
<tr class="separator:gabfd30eaf5f8bff0c904836c301e5e9b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c77005ef582df2a62ef1edd5bb79afa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga0c77005ef582df2a62ef1edd5bb79afa"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga0c77005ef582df2a62ef1edd5bb79afa">core_util_atomic_compare_exchange_weak_explicit</a> (volatile T *ptr, mstd::type_identity_t&lt; T &gt; *expectedCurrentValue, mstd::type_identity_t&lt; T &gt; desiredValue, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> success, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> failure) noexcept</td></tr>
<tr class="separator:ga0c77005ef582df2a62ef1edd5bb79afa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa776fa21be98743bd57098890aea2417"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaa776fa21be98743bd57098890aea2417"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gaa776fa21be98743bd57098890aea2417">core_util_atomic_fetch_add_explicit</a> (volatile T *valuePtr, mstd::type_identity_t&lt; T &gt; arg, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order) noexcept</td></tr>
<tr class="separator:gaa776fa21be98743bd57098890aea2417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3fbf566237e0f010f72ca2885ea742d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gae3fbf566237e0f010f72ca2885ea742d"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gae3fbf566237e0f010f72ca2885ea742d">core_util_atomic_fetch_sub_explicit</a> (volatile T *valuePtr, mstd::type_identity_t&lt; T &gt; arg, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order) noexcept</td></tr>
<tr class="separator:gae3fbf566237e0f010f72ca2885ea742d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada1610934486f89ba3f75a7d9e5be83f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gada1610934486f89ba3f75a7d9e5be83f"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gada1610934486f89ba3f75a7d9e5be83f">core_util_atomic_fetch_and_explicit</a> (volatile T *valuePtr, mstd::type_identity_t&lt; T &gt; arg, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order) noexcept</td></tr>
<tr class="separator:gada1610934486f89ba3f75a7d9e5be83f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10260701769b84170105c499807aeb8e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga10260701769b84170105c499807aeb8e"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga10260701769b84170105c499807aeb8e">core_util_atomic_fetch_or_explicit</a> (volatile T *valuePtr, mstd::type_identity_t&lt; T &gt; arg, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order) noexcept</td></tr>
<tr class="separator:ga10260701769b84170105c499807aeb8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab175114f6b2881ce253b5e34c0d6b146"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gab175114f6b2881ce253b5e34c0d6b146"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gab175114f6b2881ce253b5e34c0d6b146">core_util_atomic_fetch_xor_explicit</a> (volatile T *valuePtr, mstd::type_identity_t&lt; T &gt; arg, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order) noexcept</td></tr>
<tr class="separator:gab175114f6b2881ce253b5e34c0d6b146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2e2578cdfa076b590e6d15d4ad5b5a6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gad2e2578cdfa076b590e6d15d4ad5b5a6"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gad2e2578cdfa076b590e6d15d4ad5b5a6">core_util_atomic_load</a> (T *const volatile *valuePtr) noexcept</td></tr>
<tr class="separator:gad2e2578cdfa076b590e6d15d4ad5b5a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5251d6b71eef2a7964bfb646ef0031c7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga5251d6b71eef2a7964bfb646ef0031c7"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga5251d6b71eef2a7964bfb646ef0031c7">core_util_atomic_load</a> (T *const *valuePtr) noexcept</td></tr>
<tr class="separator:ga5251d6b71eef2a7964bfb646ef0031c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga971305d465d358274ec12bcc76b28bf8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga971305d465d358274ec12bcc76b28bf8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga971305d465d358274ec12bcc76b28bf8">core_util_atomic_store</a> (T *volatile *valuePtr, mstd::type_identity_t&lt; T &gt; *desiredValue) noexcept</td></tr>
<tr class="separator:ga971305d465d358274ec12bcc76b28bf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85c51f93131d885b17df222e7817cef2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga85c51f93131d885b17df222e7817cef2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga85c51f93131d885b17df222e7817cef2">core_util_atomic_store</a> (T **valuePtr, mstd::type_identity_t&lt; T &gt; *desiredValue) noexcept</td></tr>
<tr class="separator:ga85c51f93131d885b17df222e7817cef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c9399ec5c42db51fe779f3ad0bbfb5b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga6c9399ec5c42db51fe779f3ad0bbfb5b"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga6c9399ec5c42db51fe779f3ad0bbfb5b">core_util_atomic_exchange</a> (T *volatile *valuePtr, mstd::type_identity_t&lt; T &gt; *desiredValue) noexcept</td></tr>
<tr class="memdesc:ga6c9399ec5c42db51fe779f3ad0bbfb5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic exchange.   <a href="group__platform__atomic.html#ga6c9399ec5c42db51fe779f3ad0bbfb5b">More...</a><br /></td></tr>
<tr class="separator:ga6c9399ec5c42db51fe779f3ad0bbfb5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42505988ea9e1ecb5de1e5c95a710a80"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga42505988ea9e1ecb5de1e5c95a710a80"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga42505988ea9e1ecb5de1e5c95a710a80">core_util_atomic_compare_exchange_strong</a> (T *volatile *ptr, mstd::type_identity_t&lt; T &gt; **expectedCurrentValue, mstd::type_identity_t&lt; T &gt; *desiredValue) noexcept</td></tr>
<tr class="memdesc:ga42505988ea9e1ecb5de1e5c95a710a80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic compare and set.   <a href="group__platform__atomic.html#ga42505988ea9e1ecb5de1e5c95a710a80">More...</a><br /></td></tr>
<tr class="separator:ga42505988ea9e1ecb5de1e5c95a710a80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cb27ab094ba8acab17b47d5356c7579"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga5cb27ab094ba8acab17b47d5356c7579"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga5cb27ab094ba8acab17b47d5356c7579">core_util_atomic_compare_exchange_weak</a> (T *volatile *ptr, mstd::type_identity_t&lt; T &gt; **expectedCurrentValue, mstd::type_identity_t&lt; T &gt; *desiredValue) noexcept</td></tr>
<tr class="memdesc:ga5cb27ab094ba8acab17b47d5356c7579"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic compare and set.   <a href="group__platform__atomic.html#ga5cb27ab094ba8acab17b47d5356c7579">More...</a><br /></td></tr>
<tr class="separator:ga5cb27ab094ba8acab17b47d5356c7579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf66cad08576bf9ce1be62417123d992e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaf66cad08576bf9ce1be62417123d992e"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gaf66cad08576bf9ce1be62417123d992e">core_util_atomic_fetch_add</a> (T *volatile *valuePtr, ptrdiff_t arg) noexcept</td></tr>
<tr class="memdesc:gaf66cad08576bf9ce1be62417123d992e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic add.   <a href="group__platform__atomic.html#gaf66cad08576bf9ce1be62417123d992e">More...</a><br /></td></tr>
<tr class="separator:gaf66cad08576bf9ce1be62417123d992e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54e97ec3e7f6dd8eb2437c28e4da9ccb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga54e97ec3e7f6dd8eb2437c28e4da9ccb"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga54e97ec3e7f6dd8eb2437c28e4da9ccb">core_util_atomic_fetch_sub</a> (T *volatile *valuePtr, ptrdiff_t arg) noexcept</td></tr>
<tr class="memdesc:ga54e97ec3e7f6dd8eb2437c28e4da9ccb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic subtract.   <a href="group__platform__atomic.html#ga54e97ec3e7f6dd8eb2437c28e4da9ccb">More...</a><br /></td></tr>
<tr class="separator:ga54e97ec3e7f6dd8eb2437c28e4da9ccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e8bc70dbb6527656dc13c1527e12617"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga1e8bc70dbb6527656dc13c1527e12617"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga1e8bc70dbb6527656dc13c1527e12617">core_util_atomic_load_explicit</a> (T *const volatile *valuePtr, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order) noexcept</td></tr>
<tr class="separator:ga1e8bc70dbb6527656dc13c1527e12617"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1242e76508f4dff0698d67dc95e71f21"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga1242e76508f4dff0698d67dc95e71f21"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga1242e76508f4dff0698d67dc95e71f21">core_util_atomic_load_explicit</a> (T *const *valuePtr, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order) noexcept</td></tr>
<tr class="separator:ga1242e76508f4dff0698d67dc95e71f21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae85fe2c55665a5b1b46e285116a36b78"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gae85fe2c55665a5b1b46e285116a36b78"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gae85fe2c55665a5b1b46e285116a36b78">core_util_atomic_store_explicit</a> (T *volatile *valuePtr, mstd::type_identity_t&lt; T &gt; *desiredValue, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order) noexcept</td></tr>
<tr class="separator:gae85fe2c55665a5b1b46e285116a36b78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fe2a700dffcc55fe43509c237319deb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga4fe2a700dffcc55fe43509c237319deb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga4fe2a700dffcc55fe43509c237319deb">core_util_atomic_store_explicit</a> (T **valuePtr, mstd::type_identity_t&lt; T &gt; *desiredValue, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order) noexcept</td></tr>
<tr class="separator:ga4fe2a700dffcc55fe43509c237319deb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52c2df411d69485bd9168b50543e942b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga52c2df411d69485bd9168b50543e942b"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga52c2df411d69485bd9168b50543e942b">core_util_atomic_exchange_explicit</a> (T *volatile *valuePtr, mstd::type_identity_t&lt; T &gt; *desiredValue, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order) noexcept</td></tr>
<tr class="separator:ga52c2df411d69485bd9168b50543e942b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16e2df8237b3c8e054ac581f0e367815"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga16e2df8237b3c8e054ac581f0e367815"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga16e2df8237b3c8e054ac581f0e367815">core_util_atomic_compare_exchange_strong_explicit</a> (T *volatile *ptr, mstd::type_identity_t&lt; T &gt; **expectedCurrentValue, mstd::type_identity_t&lt; T &gt; *desiredValue, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> success, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> failure) noexcept</td></tr>
<tr class="separator:ga16e2df8237b3c8e054ac581f0e367815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5c1182e5bb8f704ec8f747fdf6811a6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gad5c1182e5bb8f704ec8f747fdf6811a6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#gad5c1182e5bb8f704ec8f747fdf6811a6">core_util_atomic_compare_exchange_weak_explicit</a> (T *volatile *ptr, mstd::type_identity_t&lt; T &gt; **expectedCurrentValue, mstd::type_identity_t&lt; T &gt; *desiredValue, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> success, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> failure) noexcept</td></tr>
<tr class="separator:gad5c1182e5bb8f704ec8f747fdf6811a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a77ed3c60e37bb68a768e88da648456"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga2a77ed3c60e37bb68a768e88da648456"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga2a77ed3c60e37bb68a768e88da648456">core_util_atomic_fetch_add_explicit</a> (T *volatile *valuePtr, ptrdiff_t arg, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order) noexcept</td></tr>
<tr class="separator:ga2a77ed3c60e37bb68a768e88da648456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga769fd6289b36b9baf9006a52adfc503b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga769fd6289b36b9baf9006a52adfc503b"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform__atomic.html#ga769fd6289b36b9baf9006a52adfc503b">core_util_atomic_fetch_sub_explicit</a> (T *volatile *valuePtr, ptrdiff_t arg, <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> order) noexcept</td></tr>
<tr class="separator:ga769fd6289b36b9baf9006a52adfc503b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p >Atomic functions function analogously to C11 and C++11 - loads have acquire semantics, stores have release semantics, and atomic operations are sequentially consistent. </p>
<p >Atomicity is enforced both between threads and interrupt handlers. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gaa8f56a572a9d71e864311c431ee1131a" name="gaa8f56a572a9d71e864311c431ee1131a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8f56a572a9d71e864311c431ee1131a">&#9670;&#160;</a></span>CORE_UTIL_ATOMIC_FLAG_INIT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CORE_UTIL_ATOMIC_FLAG_INIT&#160;&#160;&#160;{ 0 }</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializer for a <a class="el" href="structcore__util__atomic__flag.html" title="A lock-free, primitive atomic flag.">core_util_atomic_flag</a>. </p>
<p >Example: </p><div class="fragment"><div class="line"><a class="code hl_struct" href="structcore__util__atomic__flag.html">core_util_atomic_flag</a> in_progress = <a class="code hl_define" href="group__platform__atomic.html#gaa8f56a572a9d71e864311c431ee1131a">CORE_UTIL_ATOMIC_FLAG_INIT</a>;</div>
<div class="ttc" id="agroup__platform__atomic_html_gaa8f56a572a9d71e864311c431ee1131a"><div class="ttname"><a href="group__platform__atomic.html#gaa8f56a572a9d71e864311c431ee1131a">CORE_UTIL_ATOMIC_FLAG_INIT</a></div><div class="ttdeci">#define CORE_UTIL_ATOMIC_FLAG_INIT</div><div class="ttdoc">Initializer for a core_util_atomic_flag.</div><div class="ttdef"><b>Definition:</b> <a href="mbed__atomic_8h_source.html#l00130">mbed_atomic.h:130</a></div></div>
<div class="ttc" id="astructcore__util__atomic__flag_html"><div class="ttname"><a href="structcore__util__atomic__flag.html">core_util_atomic_flag</a></div><div class="ttdoc">A lock-free, primitive atomic flag.</div><div class="ttdef"><b>Definition:</b> <a href="mbed__atomic_8h_source.html#l00118">mbed_atomic.h:118</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="mbed__atomic_8h_source.html#l00130">130</a> of file <a class="el" href="mbed__atomic_8h_source.html">mbed_atomic.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gaf76273ffa0f2b491126baf28ba1af025" name="gaf76273ffa0f2b491126baf28ba1af025"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf76273ffa0f2b491126baf28ba1af025">&#9670;&#160;</a></span>mbed_memory_order</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a> <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Memory order constraints for atomic operations. </p>
<p >Intended semantics are as per C++11. </p>

</div>
</div>
<a id="gab09a83ac4701fab4cec225b2dd08b7a8" name="gab09a83ac4701fab4cec225b2dd08b7a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab09a83ac4701fab4cec225b2dd08b7a8">&#9670;&#160;</a></span>core_util_atomic_flag</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structcore__util__atomic__flag.html">core_util_atomic_flag</a> <a class="el" href="structcore__util__atomic__flag.html">core_util_atomic_flag</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A lock-free, primitive atomic flag. </p>
<p >Emulate C11's atomic_flag. The flag is initially in an indeterminate state unless explicitly initialized with CORE_UTIL_ATOMIC_FLAG_INIT. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gaa770b34054b2e54c6bcbd0e9423ecd88" name="gaa770b34054b2e54c6bcbd0e9423ecd88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa770b34054b2e54c6bcbd0e9423ecd88">&#9670;&#160;</a></span>mbed_memory_order</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Memory order constraints for atomic operations. </p>
<p >Intended semantics are as per C++11. </p>

<p class="definition">Definition at line <a class="el" href="mbed__atomic_8h_source.html#l00051">51</a> of file <a class="el" href="mbed__atomic_8h_source.html">mbed_atomic.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga38d0898d94b33af23bbbb56e358cdbdf" name="ga38d0898d94b33af23bbbb56e358cdbdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga38d0898d94b33af23bbbb56e358cdbdf">&#9670;&#160;</a></span>core_util_atomic_flag_test_and_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool core_util_atomic_flag_test_and_set </td>
          <td>(</td>
          <td class="paramtype">volatile <a class="el" href="structcore__util__atomic__flag.html">core_util_atomic_flag</a> *&#160;</td>
          <td class="paramname"><em>flagPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic test and set. </p>
<p >Atomically tests then sets the flag to true, returning the previous value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flagPtr</td><td>Target flag being tested and set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previous value. </dd></dl>

</div>
</div>
<a id="gac1ec7ff4c7bd1126328ccfaff769adcb" name="gac1ec7ff4c7bd1126328ccfaff769adcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac1ec7ff4c7bd1126328ccfaff769adcb">&#9670;&#160;</a></span>core_util_atomic_flag_test_and_set_explicit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_flag_test_and_set_explicit </td>
          <td>(</td>
          <td class="paramtype">volatile <a class="el" href="structcore__util__atomic__flag.html">core_util_atomic_flag</a> *&#160;</td>
          <td class="paramname"><em>flagPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic test and set.  </p>
<p >Atomically tests then sets the flag to true, returning the previous value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flagPtr</td><td>Target flag being tested and set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previous value.  </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>memory ordering constraint </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00634">634</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="gafe5e3f9d2bd9cf92276dacdc3928f4f0" name="gafe5e3f9d2bd9cf92276dacdc3928f4f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe5e3f9d2bd9cf92276dacdc3928f4f0">&#9670;&#160;</a></span>core_util_atomic_flag_clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void core_util_atomic_flag_clear </td>
          <td>(</td>
          <td class="paramtype">volatile <a class="el" href="structcore__util__atomic__flag.html">core_util_atomic_flag</a> *&#160;</td>
          <td class="paramname"><em>flagPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic clear. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flagPtr</td><td>Target flag being cleared. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00675">675</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="gaa1918431bfda711a76ff391ae95f7cdd" name="gaa1918431bfda711a76ff391ae95f7cdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1918431bfda711a76ff391ae95f7cdd">&#9670;&#160;</a></span>core_util_atomic_flag_clear_explicit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void core_util_atomic_flag_clear_explicit </td>
          <td>(</td>
          <td class="paramtype">volatile <a class="el" href="structcore__util__atomic__flag.html">core_util_atomic_flag</a> *&#160;</td>
          <td class="paramname"><em>flagPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic clear.  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flagPtr</td><td>Target flag being cleared.  </td></tr>
    <tr><td class="paramname">order</td><td>memory ordering constraint </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00682">682</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="ga3c9ab0fa7ce3b902356e10951e622198" name="ga3c9ab0fa7ce3b902356e10951e622198"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c9ab0fa7ce3b902356e10951e622198">&#9670;&#160;</a></span>core_util_atomic_cas_u8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool core_util_atomic_cas_u8 </td>
          <td>(</td>
          <td class="paramtype">volatile uint8_t *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>desiredValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic compare and set. </p>
<p >It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p >Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = atomic_load(p) while not done { done = atomic_cas(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<p >However, if the call is made in a loop like this, the atomic_compare_exchange_weak functions are to be preferred.</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_strong" - it always succeeds if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return does not retry. </dd></dl>

</div>
</div>
<a id="ga93c9313f1a6be27bed9a3becfde0bee7" name="ga93c9313f1a6be27bed9a3becfde0bee7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga93c9313f1a6be27bed9a3becfde0bee7">&#9670;&#160;</a></span>core_util_atomic_cas_explicit_u8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_cas_explicit_u8 </td>
          <td>(</td>
          <td class="paramtype">volatile uint8_t *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>desiredValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>success</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>failure</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic compare and set.  </p>
<p >It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p >Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = atomic_load(p) while not done { done = atomic_cas(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<p >However, if the call is made in a loop like this, the atomic_compare_exchange_weak functions are to be preferred.</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_strong" - it always succeeds if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return does not retry.  </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">success</td><td>memory ordering constraint for successful exchange </td></tr>
    <tr><td class="paramname">failure</td><td>memory ordering constraint for failure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga95a29dd5791c91987be0fed54796f08e" name="ga95a29dd5791c91987be0fed54796f08e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga95a29dd5791c91987be0fed54796f08e">&#9670;&#160;</a></span>core_util_atomic_cas_u16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool core_util_atomic_cas_u16 </td>
          <td>(</td>
          <td class="paramtype">volatile uint16_t *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>desiredValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic compare and set.  </p>
<p >It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p >Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = atomic_load(p) while not done { done = atomic_cas(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<p >However, if the call is made in a loop like this, the atomic_compare_exchange_weak functions are to be preferred.</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_strong" - it always succeeds if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return does not retry.  </dd></dl>

</div>
</div>
<a id="gaae923f73dccaad3e5bca9ce02ce47fbe" name="gaae923f73dccaad3e5bca9ce02ce47fbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae923f73dccaad3e5bca9ce02ce47fbe">&#9670;&#160;</a></span>core_util_atomic_cas_explicit_u16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_cas_explicit_u16 </td>
          <td>(</td>
          <td class="paramtype">volatile uint16_t *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>desiredValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>success</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>failure</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="ga8f1b5edfdabd05b7b2fc400a56e1f9b2" name="ga8f1b5edfdabd05b7b2fc400a56e1f9b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8f1b5edfdabd05b7b2fc400a56e1f9b2">&#9670;&#160;</a></span>core_util_atomic_cas_u32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool core_util_atomic_cas_u32 </td>
          <td>(</td>
          <td class="paramtype">volatile uint32_t *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>desiredValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic compare and set.  </p>
<p >It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p >Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = atomic_load(p) while not done { done = atomic_cas(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<p >However, if the call is made in a loop like this, the atomic_compare_exchange_weak functions are to be preferred.</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_strong" - it always succeeds if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return does not retry.  </dd></dl>

</div>
</div>
<a id="ga87b4b2754592e31420d1f2b38593b8d7" name="ga87b4b2754592e31420d1f2b38593b8d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87b4b2754592e31420d1f2b38593b8d7">&#9670;&#160;</a></span>core_util_atomic_cas_explicit_u32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_cas_explicit_u32 </td>
          <td>(</td>
          <td class="paramtype">volatile uint32_t *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>desiredValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>success</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>failure</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="ga85dd9c14f13cf180e6ecdaea8da6fe11" name="ga85dd9c14f13cf180e6ecdaea8da6fe11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85dd9c14f13cf180e6ecdaea8da6fe11">&#9670;&#160;</a></span>core_util_atomic_cas_u64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool core_util_atomic_cas_u64 </td>
          <td>(</td>
          <td class="paramtype">volatile uint64_t *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>desiredValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic compare and set.  </p>
<p >It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p >Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = atomic_load(p) while not done { done = atomic_cas(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<p >However, if the call is made in a loop like this, the atomic_compare_exchange_weak functions are to be preferred.</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_strong" - it always succeeds if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return does not retry.  </dd></dl>

</div>
</div>
<a id="ga83dc3029317f487bfef8c984ee92cb06" name="ga83dc3029317f487bfef8c984ee92cb06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83dc3029317f487bfef8c984ee92cb06">&#9670;&#160;</a></span>core_util_atomic_cas_explicit_u64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_cas_explicit_u64 </td>
          <td>(</td>
          <td class="paramtype">volatile uint64_t *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>desiredValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>success</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>failure</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="ga45910fe69f1d67e6f85654e6b137ad3c" name="ga45910fe69f1d67e6f85654e6b137ad3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45910fe69f1d67e6f85654e6b137ad3c">&#9670;&#160;</a></span>core_util_atomic_cas_s8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_cas_s8 </td>
          <td>(</td>
          <td class="paramtype">volatile int8_t *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t *&#160;</td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>desiredValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic compare and set.  </p>
<p >It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p >Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = atomic_load(p) while not done { done = atomic_cas(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<p >However, if the call is made in a loop like this, the atomic_compare_exchange_weak functions are to be preferred.</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_strong" - it always succeeds if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return does not retry.  </dd></dl>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00769">769</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="gad741471e0981d7dd88e15b7e285d3eb0" name="gad741471e0981d7dd88e15b7e285d3eb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad741471e0981d7dd88e15b7e285d3eb0">&#9670;&#160;</a></span>core_util_atomic_cas_explicit_s8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_cas_explicit_s8 </td>
          <td>(</td>
          <td class="paramtype">volatile int8_t *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t *&#160;</td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>desiredValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>success</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>failure</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00769">769</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="ga05d84165af1254189e8c61166ce6b1ff" name="ga05d84165af1254189e8c61166ce6b1ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga05d84165af1254189e8c61166ce6b1ff">&#9670;&#160;</a></span>core_util_atomic_cas_s16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_cas_s16 </td>
          <td>(</td>
          <td class="paramtype">volatile int16_t *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t *&#160;</td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>desiredValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic compare and set.  </p>
<p >It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p >Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = atomic_load(p) while not done { done = atomic_cas(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<p >However, if the call is made in a loop like this, the atomic_compare_exchange_weak functions are to be preferred.</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_strong" - it always succeeds if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return does not retry.  </dd></dl>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00769">769</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="gacf63939b06da44cb49a313698053aeb5" name="gacf63939b06da44cb49a313698053aeb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf63939b06da44cb49a313698053aeb5">&#9670;&#160;</a></span>core_util_atomic_cas_explicit_s16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_cas_explicit_s16 </td>
          <td>(</td>
          <td class="paramtype">volatile int16_t *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t *&#160;</td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>desiredValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>success</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>failure</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00769">769</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="ga205688ff94fc52b0652c9399d38ed875" name="ga205688ff94fc52b0652c9399d38ed875"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga205688ff94fc52b0652c9399d38ed875">&#9670;&#160;</a></span>core_util_atomic_cas_s32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_cas_s32 </td>
          <td>(</td>
          <td class="paramtype">volatile int32_t *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>desiredValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic compare and set.  </p>
<p >It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p >Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = atomic_load(p) while not done { done = atomic_cas(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<p >However, if the call is made in a loop like this, the atomic_compare_exchange_weak functions are to be preferred.</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_strong" - it always succeeds if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return does not retry.  </dd></dl>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00769">769</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="gab572aa9bd7e1ded44f7e6adafb7fe13a" name="gab572aa9bd7e1ded44f7e6adafb7fe13a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab572aa9bd7e1ded44f7e6adafb7fe13a">&#9670;&#160;</a></span>core_util_atomic_cas_explicit_s32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_cas_explicit_s32 </td>
          <td>(</td>
          <td class="paramtype">volatile int32_t *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>desiredValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>success</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>failure</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00769">769</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="ga6eaa833099480b1cd7f87bb06d93da2d" name="ga6eaa833099480b1cd7f87bb06d93da2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6eaa833099480b1cd7f87bb06d93da2d">&#9670;&#160;</a></span>core_util_atomic_cas_s64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_cas_s64 </td>
          <td>(</td>
          <td class="paramtype">volatile int64_t *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>desiredValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic compare and set.  </p>
<p >It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p >Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = atomic_load(p) while not done { done = atomic_cas(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<p >However, if the call is made in a loop like this, the atomic_compare_exchange_weak functions are to be preferred.</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_strong" - it always succeeds if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return does not retry.  </dd></dl>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00769">769</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="gad69a97a89c2881c8a9584602e087729e" name="gad69a97a89c2881c8a9584602e087729e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad69a97a89c2881c8a9584602e087729e">&#9670;&#160;</a></span>core_util_atomic_cas_explicit_s64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_cas_explicit_s64 </td>
          <td>(</td>
          <td class="paramtype">volatile int64_t *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>desiredValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>success</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>failure</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00769">769</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="gacbf62e56b6923b86006b8f04c57b62e2" name="gacbf62e56b6923b86006b8f04c57b62e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacbf62e56b6923b86006b8f04c57b62e2">&#9670;&#160;</a></span>core_util_atomic_cas_bool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_cas_bool </td>
          <td>(</td>
          <td class="paramtype">volatile bool *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>desiredValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic compare and set.  </p>
<p >It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p >Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = atomic_load(p) while not done { done = atomic_cas(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<p >However, if the call is made in a loop like this, the atomic_compare_exchange_weak functions are to be preferred.</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_strong" - it always succeeds if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return does not retry.  </dd></dl>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00772">772</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="ga5e8c63fcd66c95d8bf4b29d3bc3745bb" name="ga5e8c63fcd66c95d8bf4b29d3bc3745bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e8c63fcd66c95d8bf4b29d3bc3745bb">&#9670;&#160;</a></span>core_util_atomic_cas_explicit_bool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_cas_explicit_bool </td>
          <td>(</td>
          <td class="paramtype">volatile bool *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>desiredValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>success</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>failure</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00777">777</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="gaf9e9cbb15b6cae6154a5f85b483e9358" name="gaf9e9cbb15b6cae6154a5f85b483e9358"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf9e9cbb15b6cae6154a5f85b483e9358">&#9670;&#160;</a></span>core_util_atomic_cas_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool core_util_atomic_cas_ptr </td>
          <td>(</td>
          <td class="paramtype">void *volatile *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>desiredValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic compare and set.  </p>
<p >It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p >Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = atomic_load(p) while not done { done = atomic_cas(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<p >However, if the call is made in a loop like this, the atomic_compare_exchange_weak functions are to be preferred.</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_strong" - it always succeeds if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return does not retry.  </dd></dl>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00782">782</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="ga1c3370fd30e8d1721807aad74a7a4f44" name="ga1c3370fd30e8d1721807aad74a7a4f44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c3370fd30e8d1721807aad74a7a4f44">&#9670;&#160;</a></span>core_util_atomic_cas_explicit_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_cas_explicit_ptr </td>
          <td>(</td>
          <td class="paramtype">void *volatile *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>desiredValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>success</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>failure</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00797">797</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="ga80da913bf93f3269a4e35af955f1c660" name="ga80da913bf93f3269a4e35af955f1c660"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga80da913bf93f3269a4e35af955f1c660">&#9670;&#160;</a></span>core_util_atomic_compare_exchange_weak_u8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool core_util_atomic_compare_exchange_weak_u8 </td>
          <td>(</td>
          <td class="paramtype">volatile uint8_t *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>desiredValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic compare and set. </p>
<p >It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p >Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old or spurious failure { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = *p // This fetch operation need not be atomic. while not done { done = atomic_compare_exchange_weak(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_weak" - it may spuriously fail if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return will cause a retry anyway, saving the need for an extra loop inside the cas operation. </dd></dl>

</div>
</div>
<a id="ga8ea57a2b4c9d2958d6d4b9d981db3f63" name="ga8ea57a2b4c9d2958d6d4b9d981db3f63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ea57a2b4c9d2958d6d4b9d981db3f63">&#9670;&#160;</a></span>core_util_atomic_compare_exchange_weak_explicit_u8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_compare_exchange_weak_explicit_u8 </td>
          <td>(</td>
          <td class="paramtype">volatile uint8_t *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>desiredValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>success</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>failure</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic compare and set.  </p>
<p >It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p >Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old or spurious failure { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = *p // This fetch operation need not be atomic. while not done { done = atomic_compare_exchange_weak(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_weak" - it may spuriously fail if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return will cause a retry anyway, saving the need for an extra loop inside the cas operation.  </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">success</td><td>memory ordering constraint for successful exchange </td></tr>
    <tr><td class="paramname">failure</td><td>memory ordering constraint for failure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5c40ebfb654b853c353ecf67729b3b02" name="ga5c40ebfb654b853c353ecf67729b3b02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c40ebfb654b853c353ecf67729b3b02">&#9670;&#160;</a></span>core_util_atomic_compare_exchange_weak_u16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool core_util_atomic_compare_exchange_weak_u16 </td>
          <td>(</td>
          <td class="paramtype">volatile uint16_t *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>desiredValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic compare and set.  </p>
<p >It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p >Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old or spurious failure { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = *p // This fetch operation need not be atomic. while not done { done = atomic_compare_exchange_weak(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_weak" - it may spuriously fail if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return will cause a retry anyway, saving the need for an extra loop inside the cas operation.  </dd></dl>

</div>
</div>
<a id="ga5739219816da159aeaae5096ac4f074d" name="ga5739219816da159aeaae5096ac4f074d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5739219816da159aeaae5096ac4f074d">&#9670;&#160;</a></span>core_util_atomic_compare_exchange_weak_explicit_u16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_compare_exchange_weak_explicit_u16 </td>
          <td>(</td>
          <td class="paramtype">volatile uint16_t *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>desiredValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>success</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>failure</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="ga140f6e8e10012816365a8812a53cf072" name="ga140f6e8e10012816365a8812a53cf072"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga140f6e8e10012816365a8812a53cf072">&#9670;&#160;</a></span>core_util_atomic_compare_exchange_weak_u32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool core_util_atomic_compare_exchange_weak_u32 </td>
          <td>(</td>
          <td class="paramtype">volatile uint32_t *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>desiredValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic compare and set.  </p>
<p >It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p >Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old or spurious failure { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = *p // This fetch operation need not be atomic. while not done { done = atomic_compare_exchange_weak(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_weak" - it may spuriously fail if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return will cause a retry anyway, saving the need for an extra loop inside the cas operation.  </dd></dl>

</div>
</div>
<a id="gafcc40dbc99cecfa5bac04ebd65c9c0a5" name="gafcc40dbc99cecfa5bac04ebd65c9c0a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafcc40dbc99cecfa5bac04ebd65c9c0a5">&#9670;&#160;</a></span>core_util_atomic_compare_exchange_weak_explicit_u32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_compare_exchange_weak_explicit_u32 </td>
          <td>(</td>
          <td class="paramtype">volatile uint32_t *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>desiredValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>success</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>failure</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="gaadaa71b8ed5127cb9591fed2cd524b1e" name="gaadaa71b8ed5127cb9591fed2cd524b1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaadaa71b8ed5127cb9591fed2cd524b1e">&#9670;&#160;</a></span>core_util_atomic_compare_exchange_weak_u64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool core_util_atomic_compare_exchange_weak_u64 </td>
          <td>(</td>
          <td class="paramtype">volatile uint64_t *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>desiredValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic compare and set.  </p>
<p >It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p >Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old or spurious failure { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = *p // This fetch operation need not be atomic. while not done { done = atomic_compare_exchange_weak(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_weak" - it may spuriously fail if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return will cause a retry anyway, saving the need for an extra loop inside the cas operation.  </dd></dl>

</div>
</div>
<a id="gabb1873cce70f0814a2e65d2bcee84d74" name="gabb1873cce70f0814a2e65d2bcee84d74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb1873cce70f0814a2e65d2bcee84d74">&#9670;&#160;</a></span>core_util_atomic_compare_exchange_weak_explicit_u64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_compare_exchange_weak_explicit_u64 </td>
          <td>(</td>
          <td class="paramtype">volatile uint64_t *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>desiredValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>success</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>failure</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="gad18413a098f190ede59e9a7dd817480f" name="gad18413a098f190ede59e9a7dd817480f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad18413a098f190ede59e9a7dd817480f">&#9670;&#160;</a></span>core_util_atomic_compare_exchange_weak_s8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_compare_exchange_weak_s8 </td>
          <td>(</td>
          <td class="paramtype">volatile int8_t *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t *&#160;</td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>desiredValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic compare and set.  </p>
<p >It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p >Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old or spurious failure { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = *p // This fetch operation need not be atomic. while not done { done = atomic_compare_exchange_weak(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_weak" - it may spuriously fail if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return will cause a retry anyway, saving the need for an extra loop inside the cas operation.  </dd></dl>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00770">770</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="ga6cdb3fd8dfde2fc0b1da38000982bda5" name="ga6cdb3fd8dfde2fc0b1da38000982bda5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6cdb3fd8dfde2fc0b1da38000982bda5">&#9670;&#160;</a></span>core_util_atomic_compare_exchange_weak_explicit_s8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_compare_exchange_weak_explicit_s8 </td>
          <td>(</td>
          <td class="paramtype">volatile int8_t *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t *&#160;</td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>desiredValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>success</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>failure</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00770">770</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="ga03b36d178f7b14331ac054ee7de7826e" name="ga03b36d178f7b14331ac054ee7de7826e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga03b36d178f7b14331ac054ee7de7826e">&#9670;&#160;</a></span>core_util_atomic_compare_exchange_weak_s16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_compare_exchange_weak_s16 </td>
          <td>(</td>
          <td class="paramtype">volatile int16_t *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t *&#160;</td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>desiredValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic compare and set.  </p>
<p >It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p >Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old or spurious failure { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = *p // This fetch operation need not be atomic. while not done { done = atomic_compare_exchange_weak(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_weak" - it may spuriously fail if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return will cause a retry anyway, saving the need for an extra loop inside the cas operation.  </dd></dl>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00770">770</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="ga22e345fb761331b2883c063bc6505892" name="ga22e345fb761331b2883c063bc6505892"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga22e345fb761331b2883c063bc6505892">&#9670;&#160;</a></span>core_util_atomic_compare_exchange_weak_explicit_s16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_compare_exchange_weak_explicit_s16 </td>
          <td>(</td>
          <td class="paramtype">volatile int16_t *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t *&#160;</td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>desiredValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>success</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>failure</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00770">770</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="gaeaf10dda44c9c989072495022edae918" name="gaeaf10dda44c9c989072495022edae918"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeaf10dda44c9c989072495022edae918">&#9670;&#160;</a></span>core_util_atomic_compare_exchange_weak_s32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_compare_exchange_weak_s32 </td>
          <td>(</td>
          <td class="paramtype">volatile int32_t *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>desiredValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic compare and set.  </p>
<p >It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p >Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old or spurious failure { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = *p // This fetch operation need not be atomic. while not done { done = atomic_compare_exchange_weak(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_weak" - it may spuriously fail if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return will cause a retry anyway, saving the need for an extra loop inside the cas operation.  </dd></dl>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00770">770</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="gad7686b4293e7ea7bf4950dd5db438c3d" name="gad7686b4293e7ea7bf4950dd5db438c3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad7686b4293e7ea7bf4950dd5db438c3d">&#9670;&#160;</a></span>core_util_atomic_compare_exchange_weak_explicit_s32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_compare_exchange_weak_explicit_s32 </td>
          <td>(</td>
          <td class="paramtype">volatile int32_t *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>desiredValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>success</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>failure</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00770">770</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="ga86d26060ebf45bc519c5e769b369977a" name="ga86d26060ebf45bc519c5e769b369977a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86d26060ebf45bc519c5e769b369977a">&#9670;&#160;</a></span>core_util_atomic_compare_exchange_weak_s64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_compare_exchange_weak_s64 </td>
          <td>(</td>
          <td class="paramtype">volatile int64_t *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>desiredValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic compare and set.  </p>
<p >It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p >Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old or spurious failure { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = *p // This fetch operation need not be atomic. while not done { done = atomic_compare_exchange_weak(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_weak" - it may spuriously fail if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return will cause a retry anyway, saving the need for an extra loop inside the cas operation.  </dd></dl>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00770">770</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="gae818c803e9b789a9155f2582957284cc" name="gae818c803e9b789a9155f2582957284cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae818c803e9b789a9155f2582957284cc">&#9670;&#160;</a></span>core_util_atomic_compare_exchange_weak_explicit_s64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_compare_exchange_weak_explicit_s64 </td>
          <td>(</td>
          <td class="paramtype">volatile int64_t *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>desiredValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>success</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>failure</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00770">770</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="gab1d769b78dbd7f22cbb904d7b768ca45" name="gab1d769b78dbd7f22cbb904d7b768ca45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab1d769b78dbd7f22cbb904d7b768ca45">&#9670;&#160;</a></span>core_util_atomic_compare_exchange_weak_bool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_compare_exchange_weak_bool </td>
          <td>(</td>
          <td class="paramtype">volatile bool *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>desiredValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic compare and set.  </p>
<p >It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p >Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old or spurious failure { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = *p // This fetch operation need not be atomic. while not done { done = atomic_compare_exchange_weak(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_weak" - it may spuriously fail if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return will cause a retry anyway, saving the need for an extra loop inside the cas operation.  </dd></dl>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00814">814</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="gadeec7abf1f4deb39287ae36d53e543b4" name="gadeec7abf1f4deb39287ae36d53e543b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadeec7abf1f4deb39287ae36d53e543b4">&#9670;&#160;</a></span>core_util_atomic_compare_exchange_weak_explicit_bool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_compare_exchange_weak_explicit_bool </td>
          <td>(</td>
          <td class="paramtype">volatile bool *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>desiredValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>success</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>failure</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00819">819</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="gaf1778c0381b19ace75e5228c4be8448d" name="gaf1778c0381b19ace75e5228c4be8448d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1778c0381b19ace75e5228c4be8448d">&#9670;&#160;</a></span>core_util_atomic_compare_exchange_weak_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_compare_exchange_weak_ptr </td>
          <td>(</td>
          <td class="paramtype">void *volatile *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>desiredValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic compare and set.  </p>
<p >It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p >Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old or spurious failure { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = *p // This fetch operation need not be atomic. while not done { done = atomic_compare_exchange_weak(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_weak" - it may spuriously fail if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return will cause a retry anyway, saving the need for an extra loop inside the cas operation.  </dd></dl>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00824">824</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="ga0ad9cc64f6c880a1608a120f41c8ffbb" name="ga0ad9cc64f6c880a1608a120f41c8ffbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ad9cc64f6c880a1608a120f41c8ffbb">&#9670;&#160;</a></span>core_util_atomic_compare_exchange_weak_explicit_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_compare_exchange_weak_explicit_ptr </td>
          <td>(</td>
          <td class="paramtype">void *volatile *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>desiredValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>success</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>failure</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00839">839</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="ga2840954e59468ea85b91e17ca50ad009" name="ga2840954e59468ea85b91e17ca50ad009"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2840954e59468ea85b91e17ca50ad009">&#9670;&#160;</a></span>core_util_atomic_load_u8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint8_t core_util_atomic_load_u8 </td>
          <td>(</td>
          <td class="paramtype">const volatile uint8_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic load. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The loaded value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00722">722</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="ga4b5b21126d2a22858faaf8018b5e66f9" name="ga4b5b21126d2a22858faaf8018b5e66f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b5b21126d2a22858faaf8018b5e66f9">&#9670;&#160;</a></span>core_util_atomic_load_explicit_u8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint8_t core_util_atomic_load_explicit_u8 </td>
          <td>(</td>
          <td class="paramtype">const volatile uint8_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic load with explicit ordering. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">order</td><td>memory ordering constraint</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The loaded value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00722">722</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="ga6b13b1196ed2a63802d7acf2ea08aaf4" name="ga6b13b1196ed2a63802d7acf2ea08aaf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b13b1196ed2a63802d7acf2ea08aaf4">&#9670;&#160;</a></span>core_util_atomic_load_u16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint16_t core_util_atomic_load_u16 </td>
          <td>(</td>
          <td class="paramtype">const volatile uint16_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00723">723</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="ga2a81771e47a93b508d6ec3f4666b506e" name="ga2a81771e47a93b508d6ec3f4666b506e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2a81771e47a93b508d6ec3f4666b506e">&#9670;&#160;</a></span>core_util_atomic_load_explicit_u16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint16_t core_util_atomic_load_explicit_u16 </td>
          <td>(</td>
          <td class="paramtype">const volatile uint16_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00723">723</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="gade580faac99dbf59aeda5da1e4c213ad" name="gade580faac99dbf59aeda5da1e4c213ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade580faac99dbf59aeda5da1e4c213ad">&#9670;&#160;</a></span>core_util_atomic_load_u32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint32_t core_util_atomic_load_u32 </td>
          <td>(</td>
          <td class="paramtype">const volatile uint32_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00724">724</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="gaa85935b1f85886bd69c028aad61d16ce" name="gaa85935b1f85886bd69c028aad61d16ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa85935b1f85886bd69c028aad61d16ce">&#9670;&#160;</a></span>core_util_atomic_load_explicit_u32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint32_t core_util_atomic_load_explicit_u32 </td>
          <td>(</td>
          <td class="paramtype">const volatile uint32_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00724">724</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="gae79f750b7b18b9b6c54b9f67c235195f" name="gae79f750b7b18b9b6c54b9f67c235195f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae79f750b7b18b9b6c54b9f67c235195f">&#9670;&#160;</a></span>core_util_atomic_load_u64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t core_util_atomic_load_u64 </td>
          <td>(</td>
          <td class="paramtype">const volatile uint64_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="gaf24e043d3f39b59e5c4e53f7d39558d0" name="gaf24e043d3f39b59e5c4e53f7d39558d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf24e043d3f39b59e5c4e53f7d39558d0">&#9670;&#160;</a></span>core_util_atomic_load_explicit_u64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint64_t core_util_atomic_load_explicit_u64 </td>
          <td>(</td>
          <td class="paramtype">const volatile uint64_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="gaeecfddc99e71a90287f0220e8fd3e206" name="gaeecfddc99e71a90287f0220e8fd3e206"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeecfddc99e71a90287f0220e8fd3e206">&#9670;&#160;</a></span>core_util_atomic_load_s8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int8_t core_util_atomic_load_s8 </td>
          <td>(</td>
          <td class="paramtype">const volatile int8_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00725">725</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="ga765734c8f47168fbf2e1d3583466df96" name="ga765734c8f47168fbf2e1d3583466df96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga765734c8f47168fbf2e1d3583466df96">&#9670;&#160;</a></span>core_util_atomic_load_explicit_s8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int8_t core_util_atomic_load_explicit_s8 </td>
          <td>(</td>
          <td class="paramtype">const volatile int8_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00725">725</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="ga663356b18705a1c4ae4d87643ae239f6" name="ga663356b18705a1c4ae4d87643ae239f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga663356b18705a1c4ae4d87643ae239f6">&#9670;&#160;</a></span>core_util_atomic_load_s16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int16_t core_util_atomic_load_s16 </td>
          <td>(</td>
          <td class="paramtype">const volatile int16_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00726">726</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="ga99004d90211c9e8b31d40a5a86312a8f" name="ga99004d90211c9e8b31d40a5a86312a8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga99004d90211c9e8b31d40a5a86312a8f">&#9670;&#160;</a></span>core_util_atomic_load_explicit_s16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int16_t core_util_atomic_load_explicit_s16 </td>
          <td>(</td>
          <td class="paramtype">const volatile int16_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00726">726</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="ga1994aaeae2efb36b58051da401a95b36" name="ga1994aaeae2efb36b58051da401a95b36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1994aaeae2efb36b58051da401a95b36">&#9670;&#160;</a></span>core_util_atomic_load_s32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int32_t core_util_atomic_load_s32 </td>
          <td>(</td>
          <td class="paramtype">const volatile int32_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00727">727</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="ga5a70e0153206702a003de75ffe9b86aa" name="ga5a70e0153206702a003de75ffe9b86aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a70e0153206702a003de75ffe9b86aa">&#9670;&#160;</a></span>core_util_atomic_load_explicit_s32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int32_t core_util_atomic_load_explicit_s32 </td>
          <td>(</td>
          <td class="paramtype">const volatile int32_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00727">727</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="ga100297ebd80cd21846398c6ad7d81f43" name="ga100297ebd80cd21846398c6ad7d81f43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga100297ebd80cd21846398c6ad7d81f43">&#9670;&#160;</a></span>core_util_atomic_load_s64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int64_t core_util_atomic_load_s64 </td>
          <td>(</td>
          <td class="paramtype">const volatile int64_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00737">737</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="ga426c13fee706b73968b19273be5544fd" name="ga426c13fee706b73968b19273be5544fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga426c13fee706b73968b19273be5544fd">&#9670;&#160;</a></span>core_util_atomic_load_explicit_s64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int64_t core_util_atomic_load_explicit_s64 </td>
          <td>(</td>
          <td class="paramtype">const volatile int64_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__toolchain.html#ga3e0b3dc191a8e64de80be44bbc8d5193">MBED_UNUSED</a> <a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic load with explicit ordering. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">order</td><td>Currently unused since 64-bit atomic ops must be emulated</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The loaded value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00981">981</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="gaba968e929680be76321b4c639287f968" name="gaba968e929680be76321b4c639287f968"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba968e929680be76321b4c639287f968">&#9670;&#160;</a></span>core_util_atomic_load_bool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_load_bool </td>
          <td>(</td>
          <td class="paramtype">const volatile bool *&#160;</td>
          <td class="paramname"><em>valuePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00728">728</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="ga2b4b4c68346a582ed810f5a42f9083e6" name="ga2b4b4c68346a582ed810f5a42f9083e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b4b4c68346a582ed810f5a42f9083e6">&#9670;&#160;</a></span>core_util_atomic_load_explicit_bool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_load_explicit_bool </td>
          <td>(</td>
          <td class="paramtype">const volatile bool *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00728">728</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="ga87170ad015a30beac00a7764b456c7ea" name="ga87170ad015a30beac00a7764b456c7ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87170ad015a30beac00a7764b456c7ea">&#9670;&#160;</a></span>core_util_atomic_load_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void * core_util_atomic_load_ptr </td>
          <td>(</td>
          <td class="paramtype">void *const volatile *&#160;</td>
          <td class="paramname"><em>valuePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00729">729</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="ga9ce10c2fe84037a9ffc96d99090f154a" name="ga9ce10c2fe84037a9ffc96d99090f154a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ce10c2fe84037a9ffc96d99090f154a">&#9670;&#160;</a></span>core_util_atomic_load_explicit_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void * core_util_atomic_load_explicit_ptr </td>
          <td>(</td>
          <td class="paramtype">void *const volatile *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00729">729</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="gaf5c3fa6d415e012c34c7c82056817f29" name="gaf5c3fa6d415e012c34c7c82056817f29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf5c3fa6d415e012c34c7c82056817f29">&#9670;&#160;</a></span>core_util_atomic_store_u8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void core_util_atomic_store_u8 </td>
          <td>(</td>
          <td class="paramtype">volatile uint8_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>desiredValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic store. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00722">722</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="gaca1cdaf85b894b8bccb88e870577f324" name="gaca1cdaf85b894b8bccb88e870577f324"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca1cdaf85b894b8bccb88e870577f324">&#9670;&#160;</a></span>core_util_atomic_store_explicit_u8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void core_util_atomic_store_explicit_u8 </td>
          <td>(</td>
          <td class="paramtype">volatile uint8_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>desiredValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic store with explicit ordering. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store. </td></tr>
    <tr><td class="paramname">order</td><td>memory ordering constraint </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00722">722</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="ga2f38862b163d1a943b28dabfd39fc8ef" name="ga2f38862b163d1a943b28dabfd39fc8ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f38862b163d1a943b28dabfd39fc8ef">&#9670;&#160;</a></span>core_util_atomic_store_u16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void core_util_atomic_store_u16 </td>
          <td>(</td>
          <td class="paramtype">volatile uint16_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>desiredValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00723">723</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="gad81d69ed6094e7cd6cfb1f3b729955fc" name="gad81d69ed6094e7cd6cfb1f3b729955fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad81d69ed6094e7cd6cfb1f3b729955fc">&#9670;&#160;</a></span>core_util_atomic_store_explicit_u16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void core_util_atomic_store_explicit_u16 </td>
          <td>(</td>
          <td class="paramtype">volatile uint16_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>desiredValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00723">723</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="ga981dd31a80f495369723280424a3999e" name="ga981dd31a80f495369723280424a3999e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga981dd31a80f495369723280424a3999e">&#9670;&#160;</a></span>core_util_atomic_store_u32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void core_util_atomic_store_u32 </td>
          <td>(</td>
          <td class="paramtype">volatile uint32_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>desiredValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00724">724</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="ga2960e2d63e4c37c93f202cbb597189a9" name="ga2960e2d63e4c37c93f202cbb597189a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2960e2d63e4c37c93f202cbb597189a9">&#9670;&#160;</a></span>core_util_atomic_store_explicit_u32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void core_util_atomic_store_explicit_u32 </td>
          <td>(</td>
          <td class="paramtype">volatile uint32_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>desiredValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00724">724</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="gaaffb39f69f9e80d787404bcdc627bd39" name="gaaffb39f69f9e80d787404bcdc627bd39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaffb39f69f9e80d787404bcdc627bd39">&#9670;&#160;</a></span>core_util_atomic_store_u64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void core_util_atomic_store_u64 </td>
          <td>(</td>
          <td class="paramtype">volatile uint64_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>desiredValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="gad54a248229f8606e148c9708c7237334" name="gad54a248229f8606e148c9708c7237334"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad54a248229f8606e148c9708c7237334">&#9670;&#160;</a></span>core_util_atomic_store_explicit_u64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void core_util_atomic_store_explicit_u64 </td>
          <td>(</td>
          <td class="paramtype">volatile uint64_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>desiredValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="ga2024d6b1bd77f35d0bd27b9abeaca252" name="ga2024d6b1bd77f35d0bd27b9abeaca252"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2024d6b1bd77f35d0bd27b9abeaca252">&#9670;&#160;</a></span>core_util_atomic_store_s8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void core_util_atomic_store_s8 </td>
          <td>(</td>
          <td class="paramtype">volatile int8_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>desiredValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00725">725</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="ga361bc02b02df102a3f3ddf0ae84a9df0" name="ga361bc02b02df102a3f3ddf0ae84a9df0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga361bc02b02df102a3f3ddf0ae84a9df0">&#9670;&#160;</a></span>core_util_atomic_store_explicit_s8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void core_util_atomic_store_explicit_s8 </td>
          <td>(</td>
          <td class="paramtype">volatile int8_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>desiredValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00725">725</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="gae67ef75f813610e1bd3804b4cfa22565" name="gae67ef75f813610e1bd3804b4cfa22565"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae67ef75f813610e1bd3804b4cfa22565">&#9670;&#160;</a></span>core_util_atomic_store_s16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void core_util_atomic_store_s16 </td>
          <td>(</td>
          <td class="paramtype">volatile int16_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>desiredValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00726">726</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="gaedd333e4cab3877d64f041e538cff66b" name="gaedd333e4cab3877d64f041e538cff66b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaedd333e4cab3877d64f041e538cff66b">&#9670;&#160;</a></span>core_util_atomic_store_explicit_s16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void core_util_atomic_store_explicit_s16 </td>
          <td>(</td>
          <td class="paramtype">volatile int16_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>desiredValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00726">726</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="ga63d826b01dc7aae7c3a473c349f0ee32" name="ga63d826b01dc7aae7c3a473c349f0ee32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga63d826b01dc7aae7c3a473c349f0ee32">&#9670;&#160;</a></span>core_util_atomic_store_s32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void core_util_atomic_store_s32 </td>
          <td>(</td>
          <td class="paramtype">volatile int32_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>desiredValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00727">727</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="ga3b27494dba292ef9caa12d164b7a1b9d" name="ga3b27494dba292ef9caa12d164b7a1b9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b27494dba292ef9caa12d164b7a1b9d">&#9670;&#160;</a></span>core_util_atomic_store_explicit_s32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void core_util_atomic_store_explicit_s32 </td>
          <td>(</td>
          <td class="paramtype">volatile int32_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>desiredValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00727">727</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="ga15431b3da92b29949c1d597f425c7a07" name="ga15431b3da92b29949c1d597f425c7a07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15431b3da92b29949c1d597f425c7a07">&#9670;&#160;</a></span>core_util_atomic_store_s64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void core_util_atomic_store_s64 </td>
          <td>(</td>
          <td class="paramtype">volatile int64_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>desiredValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00742">742</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="gade28bd9fce9c1c0f448eab73cb00e460" name="gade28bd9fce9c1c0f448eab73cb00e460"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade28bd9fce9c1c0f448eab73cb00e460">&#9670;&#160;</a></span>core_util_atomic_store_explicit_s64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void core_util_atomic_store_explicit_s64 </td>
          <td>(</td>
          <td class="paramtype">volatile int64_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>desiredValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="ga4692889cc8d1bd170af962728be04dc3" name="ga4692889cc8d1bd170af962728be04dc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4692889cc8d1bd170af962728be04dc3">&#9670;&#160;</a></span>core_util_atomic_store_bool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void core_util_atomic_store_bool </td>
          <td>(</td>
          <td class="paramtype">volatile bool *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>desiredValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00728">728</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="gab9ca948b9322559e941dd359400ae4fe" name="gab9ca948b9322559e941dd359400ae4fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9ca948b9322559e941dd359400ae4fe">&#9670;&#160;</a></span>core_util_atomic_store_explicit_bool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void core_util_atomic_store_explicit_bool </td>
          <td>(</td>
          <td class="paramtype">volatile bool *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>desiredValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00728">728</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="gaa112a4db89b94efa5f785035415f0d5a" name="gaa112a4db89b94efa5f785035415f0d5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa112a4db89b94efa5f785035415f0d5a">&#9670;&#160;</a></span>core_util_atomic_store_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void core_util_atomic_store_ptr </td>
          <td>(</td>
          <td class="paramtype">void *volatile *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>desiredValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00729">729</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="gaca4ebe09fe2de1ddc6ce8151baefc991" name="gaca4ebe09fe2de1ddc6ce8151baefc991"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca4ebe09fe2de1ddc6ce8151baefc991">&#9670;&#160;</a></span>core_util_atomic_store_explicit_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void core_util_atomic_store_explicit_ptr </td>
          <td>(</td>
          <td class="paramtype">void *volatile *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>desiredValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00729">729</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="ga59e7a27bc6ea2f39a9ebaad40859bfe5" name="ga59e7a27bc6ea2f39a9ebaad40859bfe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59e7a27bc6ea2f39a9ebaad40859bfe5">&#9670;&#160;</a></span>core_util_atomic_exchange_u8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t core_util_atomic_exchange_u8 </td>
          <td>(</td>
          <td class="paramtype">volatile uint8_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>desiredValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic exchange. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previous value. </dd></dl>

</div>
</div>
<a id="gac7780847ac95064b466ea04bad2a61a2" name="gac7780847ac95064b466ea04bad2a61a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac7780847ac95064b466ea04bad2a61a2">&#9670;&#160;</a></span>core_util_atomic_exchange_explicit_u8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint8_t core_util_atomic_exchange_explicit_u8 </td>
          <td>(</td>
          <td class="paramtype">volatile uint8_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>desiredValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic exchange.  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previous value.  </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>memory ordering constraint </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae8bff86f0c961096d11b9e4f1b7069ae" name="gae8bff86f0c961096d11b9e4f1b7069ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae8bff86f0c961096d11b9e4f1b7069ae">&#9670;&#160;</a></span>core_util_atomic_exchange_u16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t core_util_atomic_exchange_u16 </td>
          <td>(</td>
          <td class="paramtype">volatile uint16_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>desiredValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic exchange.  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previous value.  </dd></dl>

</div>
</div>
<a id="ga09407fb1c3ba1c8518e09b75bc12c6e0" name="ga09407fb1c3ba1c8518e09b75bc12c6e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga09407fb1c3ba1c8518e09b75bc12c6e0">&#9670;&#160;</a></span>core_util_atomic_exchange_explicit_u16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint16_t core_util_atomic_exchange_explicit_u16 </td>
          <td>(</td>
          <td class="paramtype">volatile uint16_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>desiredValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="ga22e6020a2efeda8cce823c38b8d223d0" name="ga22e6020a2efeda8cce823c38b8d223d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga22e6020a2efeda8cce823c38b8d223d0">&#9670;&#160;</a></span>core_util_atomic_exchange_u32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t core_util_atomic_exchange_u32 </td>
          <td>(</td>
          <td class="paramtype">volatile uint32_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>desiredValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic exchange.  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previous value.  </dd></dl>

</div>
</div>
<a id="ga3cd0876d934c04cf3d097d6048d5b94c" name="ga3cd0876d934c04cf3d097d6048d5b94c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3cd0876d934c04cf3d097d6048d5b94c">&#9670;&#160;</a></span>core_util_atomic_exchange_explicit_u32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint32_t core_util_atomic_exchange_explicit_u32 </td>
          <td>(</td>
          <td class="paramtype">volatile uint32_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>desiredValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="ga7a53ffc716df9594b56a94fca8ce5cf7" name="ga7a53ffc716df9594b56a94fca8ce5cf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a53ffc716df9594b56a94fca8ce5cf7">&#9670;&#160;</a></span>core_util_atomic_exchange_u64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t core_util_atomic_exchange_u64 </td>
          <td>(</td>
          <td class="paramtype">volatile uint64_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>desiredValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic exchange.  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previous value.  </dd></dl>

</div>
</div>
<a id="gab492757a2fc1fdaed58f56877126fc85" name="gab492757a2fc1fdaed58f56877126fc85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab492757a2fc1fdaed58f56877126fc85">&#9670;&#160;</a></span>core_util_atomic_exchange_explicit_u64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint64_t core_util_atomic_exchange_explicit_u64 </td>
          <td>(</td>
          <td class="paramtype">volatile uint64_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>desiredValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="ga9c915efbc7c77b3c72328783af87277d" name="ga9c915efbc7c77b3c72328783af87277d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c915efbc7c77b3c72328783af87277d">&#9670;&#160;</a></span>core_util_atomic_exchange_s8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int8_t core_util_atomic_exchange_s8 </td>
          <td>(</td>
          <td class="paramtype">volatile int8_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>desiredValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic exchange.  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previous value.  </dd></dl>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00880">880</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="gab32133579ae8ddda64548e209f85a282" name="gab32133579ae8ddda64548e209f85a282"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab32133579ae8ddda64548e209f85a282">&#9670;&#160;</a></span>core_util_atomic_exchange_explicit_s8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int8_t core_util_atomic_exchange_explicit_s8 </td>
          <td>(</td>
          <td class="paramtype">volatile int8_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>desiredValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00886">886</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="gad02cc6c6d66a90be4b943dd02a682089" name="gad02cc6c6d66a90be4b943dd02a682089"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad02cc6c6d66a90be4b943dd02a682089">&#9670;&#160;</a></span>core_util_atomic_exchange_s16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int16_t core_util_atomic_exchange_s16 </td>
          <td>(</td>
          <td class="paramtype">volatile int16_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>desiredValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic exchange.  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previous value.  </dd></dl>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00880">880</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="ga3ff86a2b74166999e50784676e624a9c" name="ga3ff86a2b74166999e50784676e624a9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ff86a2b74166999e50784676e624a9c">&#9670;&#160;</a></span>core_util_atomic_exchange_explicit_s16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int16_t core_util_atomic_exchange_explicit_s16 </td>
          <td>(</td>
          <td class="paramtype">volatile int16_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>desiredValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00886">886</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="gaa5592ae0738feab92516d27d14c0921b" name="gaa5592ae0738feab92516d27d14c0921b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5592ae0738feab92516d27d14c0921b">&#9670;&#160;</a></span>core_util_atomic_exchange_s32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int32_t core_util_atomic_exchange_s32 </td>
          <td>(</td>
          <td class="paramtype">volatile int32_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>desiredValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic exchange.  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previous value.  </dd></dl>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00880">880</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="gaf601f85ee6eff49b498bd02d5355b986" name="gaf601f85ee6eff49b498bd02d5355b986"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf601f85ee6eff49b498bd02d5355b986">&#9670;&#160;</a></span>core_util_atomic_exchange_explicit_s32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int32_t core_util_atomic_exchange_explicit_s32 </td>
          <td>(</td>
          <td class="paramtype">volatile int32_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>desiredValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00886">886</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="gac09a70a91d5b50e5e4d18af85f8224de" name="gac09a70a91d5b50e5e4d18af85f8224de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac09a70a91d5b50e5e4d18af85f8224de">&#9670;&#160;</a></span>core_util_atomic_exchange_s64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int64_t core_util_atomic_exchange_s64 </td>
          <td>(</td>
          <td class="paramtype">volatile int64_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>desiredValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic exchange.  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previous value.  </dd></dl>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00880">880</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="ga44a1020edbe4b1cfc98cb2470b228c07" name="ga44a1020edbe4b1cfc98cb2470b228c07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga44a1020edbe4b1cfc98cb2470b228c07">&#9670;&#160;</a></span>core_util_atomic_exchange_explicit_s64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int64_t core_util_atomic_exchange_explicit_s64 </td>
          <td>(</td>
          <td class="paramtype">volatile int64_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>desiredValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00886">886</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="ga085fd843aab08f03815e6925b7b56e35" name="ga085fd843aab08f03815e6925b7b56e35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga085fd843aab08f03815e6925b7b56e35">&#9670;&#160;</a></span>core_util_atomic_exchange_bool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_exchange_bool </td>
          <td>(</td>
          <td class="paramtype">volatile bool *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>desiredValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic exchange.  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previous value.  </dd></dl>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00890">890</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="ga11616204b0007487d3607cfd0036e966" name="ga11616204b0007487d3607cfd0036e966"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga11616204b0007487d3607cfd0036e966">&#9670;&#160;</a></span>core_util_atomic_exchange_explicit_bool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> bool core_util_atomic_exchange_explicit_bool </td>
          <td>(</td>
          <td class="paramtype">volatile bool *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>desiredValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00895">895</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="gadd245e89bb0303090ea1f880823ccde3" name="gadd245e89bb0303090ea1f880823ccde3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd245e89bb0303090ea1f880823ccde3">&#9670;&#160;</a></span>core_util_atomic_exchange_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * core_util_atomic_exchange_ptr </td>
          <td>(</td>
          <td class="paramtype">void *volatile *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>desiredValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic exchange.  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previous value.  </dd></dl>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00900">900</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="ga373b2f859a298cb11ef3186816033c33" name="ga373b2f859a298cb11ef3186816033c33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga373b2f859a298cb11ef3186816033c33">&#9670;&#160;</a></span>core_util_atomic_exchange_explicit_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void * core_util_atomic_exchange_explicit_ptr </td>
          <td>(</td>
          <td class="paramtype">void *volatile *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>desiredValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00909">909</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="ga7b2738cdb036dd4bf42c8a496107b3c9" name="ga7b2738cdb036dd4bf42c8a496107b3c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b2738cdb036dd4bf42c8a496107b3c9">&#9670;&#160;</a></span>core_util_atomic_incr_u8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t core_util_atomic_incr_u8 </td>
          <td>(</td>
          <td class="paramtype">volatile uint8_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic increment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being incremented. </td></tr>
    <tr><td class="paramname">delta</td><td>The amount being incremented. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new incremented value. </dd></dl>

</div>
</div>
<a id="gaf11cb4e3404afe3549a26c852934c8df" name="gaf11cb4e3404afe3549a26c852934c8df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf11cb4e3404afe3549a26c852934c8df">&#9670;&#160;</a></span>core_util_atomic_incr_u16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t core_util_atomic_incr_u16 </td>
          <td>(</td>
          <td class="paramtype">volatile uint16_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic increment.  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being incremented. </td></tr>
    <tr><td class="paramname">delta</td><td>The amount being incremented. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new incremented value.  </dd></dl>

</div>
</div>
<a id="ga4a9fd9661ae1db338cd776ba45f3ad33" name="ga4a9fd9661ae1db338cd776ba45f3ad33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a9fd9661ae1db338cd776ba45f3ad33">&#9670;&#160;</a></span>core_util_atomic_incr_u32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t core_util_atomic_incr_u32 </td>
          <td>(</td>
          <td class="paramtype">volatile uint32_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic increment.  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being incremented. </td></tr>
    <tr><td class="paramname">delta</td><td>The amount being incremented. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new incremented value.  </dd></dl>

</div>
</div>
<a id="ga1da475be0bf8e7d9e7cd16177e3d13a5" name="ga1da475be0bf8e7d9e7cd16177e3d13a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1da475be0bf8e7d9e7cd16177e3d13a5">&#9670;&#160;</a></span>core_util_atomic_incr_u64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t core_util_atomic_incr_u64 </td>
          <td>(</td>
          <td class="paramtype">volatile uint64_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic increment.  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being incremented. </td></tr>
    <tr><td class="paramname">delta</td><td>The amount being incremented. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new incremented value.  </dd></dl>

</div>
</div>
<a id="gad991d615f9643f15f883e6c4638fe31e" name="gad991d615f9643f15f883e6c4638fe31e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad991d615f9643f15f883e6c4638fe31e">&#9670;&#160;</a></span>core_util_atomic_incr_s8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int8_t core_util_atomic_incr_s8 </td>
          <td>(</td>
          <td class="paramtype">volatile int8_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic increment.  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being incremented. </td></tr>
    <tr><td class="paramname">delta</td><td>The amount being incremented. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new incremented value.  </dd></dl>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00881">881</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="gaf71073f46116c910e80c0c4c7409b995" name="gaf71073f46116c910e80c0c4c7409b995"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf71073f46116c910e80c0c4c7409b995">&#9670;&#160;</a></span>core_util_atomic_incr_s16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int16_t core_util_atomic_incr_s16 </td>
          <td>(</td>
          <td class="paramtype">volatile int16_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic increment.  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being incremented. </td></tr>
    <tr><td class="paramname">delta</td><td>The amount being incremented. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new incremented value.  </dd></dl>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00881">881</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="gaad1b7864af7323246bd38768aff11cf8" name="gaad1b7864af7323246bd38768aff11cf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad1b7864af7323246bd38768aff11cf8">&#9670;&#160;</a></span>core_util_atomic_incr_s32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int32_t core_util_atomic_incr_s32 </td>
          <td>(</td>
          <td class="paramtype">volatile int32_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic increment.  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being incremented. </td></tr>
    <tr><td class="paramname">delta</td><td>The amount being incremented. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new incremented value.  </dd></dl>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00881">881</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="gad8058a48a1ddde0bfd1900f9fc789eca" name="gad8058a48a1ddde0bfd1900f9fc789eca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad8058a48a1ddde0bfd1900f9fc789eca">&#9670;&#160;</a></span>core_util_atomic_incr_s64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int64_t core_util_atomic_incr_s64 </td>
          <td>(</td>
          <td class="paramtype">volatile int64_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic increment.  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being incremented. </td></tr>
    <tr><td class="paramname">delta</td><td>The amount being incremented. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new incremented value.  </dd></dl>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00881">881</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="ga552c51b9a90675e7f5c70d3769e2c5e8" name="ga552c51b9a90675e7f5c70d3769e2c5e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga552c51b9a90675e7f5c70d3769e2c5e8">&#9670;&#160;</a></span>core_util_atomic_incr_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * core_util_atomic_incr_ptr </td>
          <td>(</td>
          <td class="paramtype">void *volatile *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic increment.  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being incremented. </td></tr>
    <tr><td class="paramname">delta</td><td>The amount being incremented. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new incremented value.  </dd></dl>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00918">918</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="ga22c32f3db5d87ca5ba9661f9efbaa205" name="ga22c32f3db5d87ca5ba9661f9efbaa205"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga22c32f3db5d87ca5ba9661f9efbaa205">&#9670;&#160;</a></span>core_util_atomic_decr_u8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t core_util_atomic_decr_u8 </td>
          <td>(</td>
          <td class="paramtype">volatile uint8_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic decrement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being decremented. </td></tr>
    <tr><td class="paramname">delta</td><td>The amount being decremented. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new decremented value. </dd></dl>

</div>
</div>
<a id="ga732744dc1479c273c7f096117a92ff83" name="ga732744dc1479c273c7f096117a92ff83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga732744dc1479c273c7f096117a92ff83">&#9670;&#160;</a></span>core_util_atomic_decr_u16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t core_util_atomic_decr_u16 </td>
          <td>(</td>
          <td class="paramtype">volatile uint16_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic decrement.  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being decremented. </td></tr>
    <tr><td class="paramname">delta</td><td>The amount being decremented. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new decremented value.  </dd></dl>

</div>
</div>
<a id="gaa5cff540da859622ef0fce52f2c25bc6" name="gaa5cff540da859622ef0fce52f2c25bc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5cff540da859622ef0fce52f2c25bc6">&#9670;&#160;</a></span>core_util_atomic_decr_u32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t core_util_atomic_decr_u32 </td>
          <td>(</td>
          <td class="paramtype">volatile uint32_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic decrement.  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being decremented. </td></tr>
    <tr><td class="paramname">delta</td><td>The amount being decremented. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new decremented value.  </dd></dl>

</div>
</div>
<a id="gad40c29bee47dc525faefb7544cce2ac0" name="gad40c29bee47dc525faefb7544cce2ac0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad40c29bee47dc525faefb7544cce2ac0">&#9670;&#160;</a></span>core_util_atomic_decr_u64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t core_util_atomic_decr_u64 </td>
          <td>(</td>
          <td class="paramtype">volatile uint64_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic decrement.  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being decremented. </td></tr>
    <tr><td class="paramname">delta</td><td>The amount being decremented. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new decremented value.  </dd></dl>

</div>
</div>
<a id="gadeb322baa1bd668947e5f0bfd3134283" name="gadeb322baa1bd668947e5f0bfd3134283"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadeb322baa1bd668947e5f0bfd3134283">&#9670;&#160;</a></span>core_util_atomic_decr_s8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int8_t core_util_atomic_decr_s8 </td>
          <td>(</td>
          <td class="paramtype">volatile int8_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic decrement.  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being decremented. </td></tr>
    <tr><td class="paramname">delta</td><td>The amount being decremented. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new decremented value.  </dd></dl>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00882">882</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="ga752f3c2b1a007fb57340d827087c7acf" name="ga752f3c2b1a007fb57340d827087c7acf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga752f3c2b1a007fb57340d827087c7acf">&#9670;&#160;</a></span>core_util_atomic_decr_s16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int16_t core_util_atomic_decr_s16 </td>
          <td>(</td>
          <td class="paramtype">volatile int16_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic decrement.  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being decremented. </td></tr>
    <tr><td class="paramname">delta</td><td>The amount being decremented. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new decremented value.  </dd></dl>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00882">882</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="ga89ffa4563fded0662921120ec752c4e9" name="ga89ffa4563fded0662921120ec752c4e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga89ffa4563fded0662921120ec752c4e9">&#9670;&#160;</a></span>core_util_atomic_decr_s32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int32_t core_util_atomic_decr_s32 </td>
          <td>(</td>
          <td class="paramtype">volatile int32_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic decrement.  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being decremented. </td></tr>
    <tr><td class="paramname">delta</td><td>The amount being decremented. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new decremented value.  </dd></dl>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00882">882</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="ga1aded12e7bbd8250c0f9392617141829" name="ga1aded12e7bbd8250c0f9392617141829"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1aded12e7bbd8250c0f9392617141829">&#9670;&#160;</a></span>core_util_atomic_decr_s64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int64_t core_util_atomic_decr_s64 </td>
          <td>(</td>
          <td class="paramtype">volatile int64_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic decrement.  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being decremented. </td></tr>
    <tr><td class="paramname">delta</td><td>The amount being decremented. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new decremented value.  </dd></dl>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00882">882</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="ga43270010ce23b14d180cac14b0070137" name="ga43270010ce23b14d180cac14b0070137"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga43270010ce23b14d180cac14b0070137">&#9670;&#160;</a></span>core_util_atomic_decr_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * core_util_atomic_decr_ptr </td>
          <td>(</td>
          <td class="paramtype">void *volatile *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic decrement.  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being decremented. </td></tr>
    <tr><td class="paramname">delta</td><td>The amount being decremented. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new decremented value.  </dd></dl>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00927">927</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="gafc7672b3ff5038e7e408a79b2d367d85" name="gafc7672b3ff5038e7e408a79b2d367d85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc7672b3ff5038e7e408a79b2d367d85">&#9670;&#160;</a></span>core_util_atomic_fetch_add_u8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t core_util_atomic_fetch_add_u8 </td>
          <td>(</td>
          <td class="paramtype">volatile uint8_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic add. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the addition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value. </dd></dl>

</div>
</div>
<a id="ga651ae50190ea63b037e38c1e3d058f62" name="ga651ae50190ea63b037e38c1e3d058f62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga651ae50190ea63b037e38c1e3d058f62">&#9670;&#160;</a></span>core_util_atomic_fetch_add_explicit_u8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint8_t core_util_atomic_fetch_add_explicit_u8 </td>
          <td>(</td>
          <td class="paramtype">volatile uint8_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic add.  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the addition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.  </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>memory ordering constraint </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2891e6f81e0f7753001610fcf27d1a14" name="ga2891e6f81e0f7753001610fcf27d1a14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2891e6f81e0f7753001610fcf27d1a14">&#9670;&#160;</a></span>core_util_atomic_fetch_add_u16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t core_util_atomic_fetch_add_u16 </td>
          <td>(</td>
          <td class="paramtype">volatile uint16_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic add.  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the addition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.  </dd></dl>

</div>
</div>
<a id="ga9b1fe9a8547ec4ba9be99695c2d10688" name="ga9b1fe9a8547ec4ba9be99695c2d10688"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9b1fe9a8547ec4ba9be99695c2d10688">&#9670;&#160;</a></span>core_util_atomic_fetch_add_explicit_u16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint16_t core_util_atomic_fetch_add_explicit_u16 </td>
          <td>(</td>
          <td class="paramtype">volatile uint16_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="ga8433a277473c8be2ecf2636b215482a4" name="ga8433a277473c8be2ecf2636b215482a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8433a277473c8be2ecf2636b215482a4">&#9670;&#160;</a></span>core_util_atomic_fetch_add_u32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t core_util_atomic_fetch_add_u32 </td>
          <td>(</td>
          <td class="paramtype">volatile uint32_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic add.  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the addition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.  </dd></dl>

</div>
</div>
<a id="ga6e2cf84841529895574591de06da0a81" name="ga6e2cf84841529895574591de06da0a81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e2cf84841529895574591de06da0a81">&#9670;&#160;</a></span>core_util_atomic_fetch_add_explicit_u32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint32_t core_util_atomic_fetch_add_explicit_u32 </td>
          <td>(</td>
          <td class="paramtype">volatile uint32_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="gaccdbfedfdbdad88c8f18caf0a3212f9b" name="gaccdbfedfdbdad88c8f18caf0a3212f9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaccdbfedfdbdad88c8f18caf0a3212f9b">&#9670;&#160;</a></span>core_util_atomic_fetch_add_u64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t core_util_atomic_fetch_add_u64 </td>
          <td>(</td>
          <td class="paramtype">volatile uint64_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic add.  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the addition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.  </dd></dl>

</div>
</div>
<a id="ga52a5a54967b6603caad8a7013b5603d4" name="ga52a5a54967b6603caad8a7013b5603d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga52a5a54967b6603caad8a7013b5603d4">&#9670;&#160;</a></span>core_util_atomic_fetch_add_explicit_u64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint64_t core_util_atomic_fetch_add_explicit_u64 </td>
          <td>(</td>
          <td class="paramtype">volatile uint64_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="gab749485f59e3e2d83e62ee565aeca6f5" name="gab749485f59e3e2d83e62ee565aeca6f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab749485f59e3e2d83e62ee565aeca6f5">&#9670;&#160;</a></span>core_util_atomic_fetch_add_s8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int8_t core_util_atomic_fetch_add_s8 </td>
          <td>(</td>
          <td class="paramtype">volatile int8_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic add.  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the addition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.  </dd></dl>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00883">883</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="gad4d95c74bb5c805196eb6f001704474e" name="gad4d95c74bb5c805196eb6f001704474e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4d95c74bb5c805196eb6f001704474e">&#9670;&#160;</a></span>core_util_atomic_fetch_add_explicit_s8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int8_t core_util_atomic_fetch_add_explicit_s8 </td>
          <td>(</td>
          <td class="paramtype">volatile int8_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00887">887</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="gadacb556c12ab10eb1bac2ce28d837415" name="gadacb556c12ab10eb1bac2ce28d837415"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadacb556c12ab10eb1bac2ce28d837415">&#9670;&#160;</a></span>core_util_atomic_fetch_add_s16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int16_t core_util_atomic_fetch_add_s16 </td>
          <td>(</td>
          <td class="paramtype">volatile int16_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic add.  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the addition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.  </dd></dl>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00883">883</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="gaeec6975ddf7e77d74ade6d5157b89224" name="gaeec6975ddf7e77d74ade6d5157b89224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeec6975ddf7e77d74ade6d5157b89224">&#9670;&#160;</a></span>core_util_atomic_fetch_add_explicit_s16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int16_t core_util_atomic_fetch_add_explicit_s16 </td>
          <td>(</td>
          <td class="paramtype">volatile int16_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00887">887</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="ga5ce4cf4be0c038e724bc5be4d03d9026" name="ga5ce4cf4be0c038e724bc5be4d03d9026"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ce4cf4be0c038e724bc5be4d03d9026">&#9670;&#160;</a></span>core_util_atomic_fetch_add_s32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int32_t core_util_atomic_fetch_add_s32 </td>
          <td>(</td>
          <td class="paramtype">volatile int32_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic add.  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the addition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.  </dd></dl>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00883">883</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="ga7e312ade8a7e075e99b146628909800c" name="ga7e312ade8a7e075e99b146628909800c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e312ade8a7e075e99b146628909800c">&#9670;&#160;</a></span>core_util_atomic_fetch_add_explicit_s32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int32_t core_util_atomic_fetch_add_explicit_s32 </td>
          <td>(</td>
          <td class="paramtype">volatile int32_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00887">887</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="ga71166f17a0453072cb2a53c9b2c70b50" name="ga71166f17a0453072cb2a53c9b2c70b50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga71166f17a0453072cb2a53c9b2c70b50">&#9670;&#160;</a></span>core_util_atomic_fetch_add_s64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int64_t core_util_atomic_fetch_add_s64 </td>
          <td>(</td>
          <td class="paramtype">volatile int64_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic add.  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the addition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.  </dd></dl>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00883">883</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="ga529c15151f84f8d992f0b7b73b89114c" name="ga529c15151f84f8d992f0b7b73b89114c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga529c15151f84f8d992f0b7b73b89114c">&#9670;&#160;</a></span>core_util_atomic_fetch_add_explicit_s64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int64_t core_util_atomic_fetch_add_explicit_s64 </td>
          <td>(</td>
          <td class="paramtype">volatile int64_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00887">887</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="ga1b970ad6426c9488eacff7a8b60f7c9a" name="ga1b970ad6426c9488eacff7a8b60f7c9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b970ad6426c9488eacff7a8b60f7c9a">&#9670;&#160;</a></span>core_util_atomic_fetch_add_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void * core_util_atomic_fetch_add_ptr </td>
          <td>(</td>
          <td class="paramtype">void *volatile *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic add.  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the addition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.  </dd></dl>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00936">936</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="ga612c1b23f221aaeb1ea9eec37c9e0924" name="ga612c1b23f221aaeb1ea9eec37c9e0924"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga612c1b23f221aaeb1ea9eec37c9e0924">&#9670;&#160;</a></span>core_util_atomic_fetch_add_explicit_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void * core_util_atomic_fetch_add_explicit_ptr </td>
          <td>(</td>
          <td class="paramtype">void *volatile *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00945">945</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="gacdd384cefb5b5c96e336c280af3d9334" name="gacdd384cefb5b5c96e336c280af3d9334"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacdd384cefb5b5c96e336c280af3d9334">&#9670;&#160;</a></span>core_util_atomic_fetch_sub_u8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t core_util_atomic_fetch_sub_u8 </td>
          <td>(</td>
          <td class="paramtype">volatile uint8_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic subtract. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the subtraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value. </dd></dl>

</div>
</div>
<a id="ga0cdf17854e749a41ffb1ef1c9391ccb1" name="ga0cdf17854e749a41ffb1ef1c9391ccb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0cdf17854e749a41ffb1ef1c9391ccb1">&#9670;&#160;</a></span>core_util_atomic_fetch_sub_explicit_u8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint8_t core_util_atomic_fetch_sub_explicit_u8 </td>
          <td>(</td>
          <td class="paramtype">volatile uint8_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic subtract.  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the subtraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.  </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>memory ordering constraint </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3a8cab6163f0c3971217a0a4b6eedc3f" name="ga3a8cab6163f0c3971217a0a4b6eedc3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a8cab6163f0c3971217a0a4b6eedc3f">&#9670;&#160;</a></span>core_util_atomic_fetch_sub_u16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t core_util_atomic_fetch_sub_u16 </td>
          <td>(</td>
          <td class="paramtype">volatile uint16_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic subtract.  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the subtraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.  </dd></dl>

</div>
</div>
<a id="gaef713cf9e4b240fc9333ae986a64f3ad" name="gaef713cf9e4b240fc9333ae986a64f3ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef713cf9e4b240fc9333ae986a64f3ad">&#9670;&#160;</a></span>core_util_atomic_fetch_sub_explicit_u16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint16_t core_util_atomic_fetch_sub_explicit_u16 </td>
          <td>(</td>
          <td class="paramtype">volatile uint16_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="ga6a439187827f741048fc07f4cc6fd0f5" name="ga6a439187827f741048fc07f4cc6fd0f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a439187827f741048fc07f4cc6fd0f5">&#9670;&#160;</a></span>core_util_atomic_fetch_sub_u32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t core_util_atomic_fetch_sub_u32 </td>
          <td>(</td>
          <td class="paramtype">volatile uint32_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic subtract.  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the subtraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.  </dd></dl>

</div>
</div>
<a id="ga6a744e93eda19b361077c2d283f69c11" name="ga6a744e93eda19b361077c2d283f69c11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a744e93eda19b361077c2d283f69c11">&#9670;&#160;</a></span>core_util_atomic_fetch_sub_explicit_u32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint32_t core_util_atomic_fetch_sub_explicit_u32 </td>
          <td>(</td>
          <td class="paramtype">volatile uint32_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="ga63f7d9554d99b226c04021bf058809e9" name="ga63f7d9554d99b226c04021bf058809e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga63f7d9554d99b226c04021bf058809e9">&#9670;&#160;</a></span>core_util_atomic_fetch_sub_u64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t core_util_atomic_fetch_sub_u64 </td>
          <td>(</td>
          <td class="paramtype">volatile uint64_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic subtract.  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the subtraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.  </dd></dl>

</div>
</div>
<a id="gaf71e00325c1ca7d78bfec53182c972a1" name="gaf71e00325c1ca7d78bfec53182c972a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf71e00325c1ca7d78bfec53182c972a1">&#9670;&#160;</a></span>core_util_atomic_fetch_sub_explicit_u64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint64_t core_util_atomic_fetch_sub_explicit_u64 </td>
          <td>(</td>
          <td class="paramtype">volatile uint64_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="ga9b868ca82165d3e1e86ff8cb3cc45878" name="ga9b868ca82165d3e1e86ff8cb3cc45878"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9b868ca82165d3e1e86ff8cb3cc45878">&#9670;&#160;</a></span>core_util_atomic_fetch_sub_s8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int8_t core_util_atomic_fetch_sub_s8 </td>
          <td>(</td>
          <td class="paramtype">volatile int8_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic subtract.  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the subtraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.  </dd></dl>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00884">884</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="gafc7d33c43f941840f436513972cffdf1" name="gafc7d33c43f941840f436513972cffdf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc7d33c43f941840f436513972cffdf1">&#9670;&#160;</a></span>core_util_atomic_fetch_sub_explicit_s8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int8_t core_util_atomic_fetch_sub_explicit_s8 </td>
          <td>(</td>
          <td class="paramtype">volatile int8_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00888">888</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="ga1b1f99cad729bd49aa63c570a968a489" name="ga1b1f99cad729bd49aa63c570a968a489"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b1f99cad729bd49aa63c570a968a489">&#9670;&#160;</a></span>core_util_atomic_fetch_sub_s16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int16_t core_util_atomic_fetch_sub_s16 </td>
          <td>(</td>
          <td class="paramtype">volatile int16_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic subtract.  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the subtraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.  </dd></dl>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00884">884</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="ga3198e21d50306edeca33e63eb6121613" name="ga3198e21d50306edeca33e63eb6121613"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3198e21d50306edeca33e63eb6121613">&#9670;&#160;</a></span>core_util_atomic_fetch_sub_explicit_s16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int16_t core_util_atomic_fetch_sub_explicit_s16 </td>
          <td>(</td>
          <td class="paramtype">volatile int16_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00888">888</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="gaf8dce75d68ca82cb52baeb761d6abee3" name="gaf8dce75d68ca82cb52baeb761d6abee3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf8dce75d68ca82cb52baeb761d6abee3">&#9670;&#160;</a></span>core_util_atomic_fetch_sub_s32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int32_t core_util_atomic_fetch_sub_s32 </td>
          <td>(</td>
          <td class="paramtype">volatile int32_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic subtract.  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the subtraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.  </dd></dl>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00884">884</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="ga038e3bea482bb48b4d2cec13a568c382" name="ga038e3bea482bb48b4d2cec13a568c382"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga038e3bea482bb48b4d2cec13a568c382">&#9670;&#160;</a></span>core_util_atomic_fetch_sub_explicit_s32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int32_t core_util_atomic_fetch_sub_explicit_s32 </td>
          <td>(</td>
          <td class="paramtype">volatile int32_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00888">888</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="ga17bf4f676b1bf6a95e8fd98fd02fe63d" name="ga17bf4f676b1bf6a95e8fd98fd02fe63d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga17bf4f676b1bf6a95e8fd98fd02fe63d">&#9670;&#160;</a></span>core_util_atomic_fetch_sub_s64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int64_t core_util_atomic_fetch_sub_s64 </td>
          <td>(</td>
          <td class="paramtype">volatile int64_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic subtract.  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the subtraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.  </dd></dl>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00884">884</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="ga644d915b39e49bf2d83f44d3b5762927" name="ga644d915b39e49bf2d83f44d3b5762927"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga644d915b39e49bf2d83f44d3b5762927">&#9670;&#160;</a></span>core_util_atomic_fetch_sub_explicit_s64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> int64_t core_util_atomic_fetch_sub_explicit_s64 </td>
          <td>(</td>
          <td class="paramtype">volatile int64_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00888">888</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="ga693d6b9a52e7334f01b6893d132cecb1" name="ga693d6b9a52e7334f01b6893d132cecb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga693d6b9a52e7334f01b6893d132cecb1">&#9670;&#160;</a></span>core_util_atomic_fetch_sub_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void * core_util_atomic_fetch_sub_ptr </td>
          <td>(</td>
          <td class="paramtype">void *volatile *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic subtract.  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the subtraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.  </dd></dl>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00954">954</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="ga096af7149a60b608b9c528530d61a232" name="ga096af7149a60b608b9c528530d61a232"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga096af7149a60b608b9c528530d61a232">&#9670;&#160;</a></span>core_util_atomic_fetch_sub_explicit_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> void * core_util_atomic_fetch_sub_explicit_ptr </td>
          <td>(</td>
          <td class="paramtype">void *volatile *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l00963">963</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="gac71103feba0ddbe9bee54759e3d1ef50" name="gac71103feba0ddbe9bee54759e3d1ef50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac71103feba0ddbe9bee54759e3d1ef50">&#9670;&#160;</a></span>core_util_atomic_fetch_and_u8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t core_util_atomic_fetch_and_u8 </td>
          <td>(</td>
          <td class="paramtype">volatile uint8_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic bitwise and. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the bitwise operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value. </dd></dl>

</div>
</div>
<a id="ga118df0bb30ca68d2be8c084be472289b" name="ga118df0bb30ca68d2be8c084be472289b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga118df0bb30ca68d2be8c084be472289b">&#9670;&#160;</a></span>core_util_atomic_fetch_and_explicit_u8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint8_t core_util_atomic_fetch_and_explicit_u8 </td>
          <td>(</td>
          <td class="paramtype">volatile uint8_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic bitwise and.  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the bitwise operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.  </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>memory ordering constraint </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0503c7ae8ed7e9105c9827bf564b2af6" name="ga0503c7ae8ed7e9105c9827bf564b2af6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0503c7ae8ed7e9105c9827bf564b2af6">&#9670;&#160;</a></span>core_util_atomic_fetch_and_u16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t core_util_atomic_fetch_and_u16 </td>
          <td>(</td>
          <td class="paramtype">volatile uint16_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic bitwise and.  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the bitwise operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.  </dd></dl>

</div>
</div>
<a id="gaeb2f48d1bb656d61c0dc92f255c6f21a" name="gaeb2f48d1bb656d61c0dc92f255c6f21a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb2f48d1bb656d61c0dc92f255c6f21a">&#9670;&#160;</a></span>core_util_atomic_fetch_and_explicit_u16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint16_t core_util_atomic_fetch_and_explicit_u16 </td>
          <td>(</td>
          <td class="paramtype">volatile uint16_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="gaa578cdd3776051931ada26258029733e" name="gaa578cdd3776051931ada26258029733e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa578cdd3776051931ada26258029733e">&#9670;&#160;</a></span>core_util_atomic_fetch_and_u32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t core_util_atomic_fetch_and_u32 </td>
          <td>(</td>
          <td class="paramtype">volatile uint32_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic bitwise and.  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the bitwise operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.  </dd></dl>

</div>
</div>
<a id="ga6169b1a76622a0260d8ce24f2a27a071" name="ga6169b1a76622a0260d8ce24f2a27a071"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6169b1a76622a0260d8ce24f2a27a071">&#9670;&#160;</a></span>core_util_atomic_fetch_and_explicit_u32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint32_t core_util_atomic_fetch_and_explicit_u32 </td>
          <td>(</td>
          <td class="paramtype">volatile uint32_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="gacf9ca48255c2fb18551881f37b86f004" name="gacf9ca48255c2fb18551881f37b86f004"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf9ca48255c2fb18551881f37b86f004">&#9670;&#160;</a></span>core_util_atomic_fetch_and_u64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t core_util_atomic_fetch_and_u64 </td>
          <td>(</td>
          <td class="paramtype">volatile uint64_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic bitwise and.  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the bitwise operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.  </dd></dl>

</div>
</div>
<a id="gac2969415714af3a77fbb565e78328a4f" name="gac2969415714af3a77fbb565e78328a4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac2969415714af3a77fbb565e78328a4f">&#9670;&#160;</a></span>core_util_atomic_fetch_and_explicit_u64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint64_t core_util_atomic_fetch_and_explicit_u64 </td>
          <td>(</td>
          <td class="paramtype">volatile uint64_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="gad9a6253c2c2c213f10a8238ac68f834f" name="gad9a6253c2c2c213f10a8238ac68f834f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad9a6253c2c2c213f10a8238ac68f834f">&#9670;&#160;</a></span>core_util_atomic_fetch_or_u8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t core_util_atomic_fetch_or_u8 </td>
          <td>(</td>
          <td class="paramtype">volatile uint8_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic bitwise inclusive or. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the bitwise operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value. </dd></dl>

</div>
</div>
<a id="ga19a483c3c606c7a95e539c269937b3fa" name="ga19a483c3c606c7a95e539c269937b3fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga19a483c3c606c7a95e539c269937b3fa">&#9670;&#160;</a></span>core_util_atomic_fetch_or_explicit_u8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint8_t core_util_atomic_fetch_or_explicit_u8 </td>
          <td>(</td>
          <td class="paramtype">volatile uint8_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic bitwise inclusive or.  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the bitwise operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.  </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>memory ordering constraint </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5171ff450449f9ec9e0cb58b5586aa43" name="ga5171ff450449f9ec9e0cb58b5586aa43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5171ff450449f9ec9e0cb58b5586aa43">&#9670;&#160;</a></span>core_util_atomic_fetch_or_u16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t core_util_atomic_fetch_or_u16 </td>
          <td>(</td>
          <td class="paramtype">volatile uint16_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic bitwise inclusive or.  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the bitwise operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.  </dd></dl>

</div>
</div>
<a id="gaffa1ebeb601da04d37d5e7170e52505d" name="gaffa1ebeb601da04d37d5e7170e52505d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaffa1ebeb601da04d37d5e7170e52505d">&#9670;&#160;</a></span>core_util_atomic_fetch_or_explicit_u16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint16_t core_util_atomic_fetch_or_explicit_u16 </td>
          <td>(</td>
          <td class="paramtype">volatile uint16_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="gad20c7d38345c87afbbc1de568c4a2ea0" name="gad20c7d38345c87afbbc1de568c4a2ea0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad20c7d38345c87afbbc1de568c4a2ea0">&#9670;&#160;</a></span>core_util_atomic_fetch_or_u32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t core_util_atomic_fetch_or_u32 </td>
          <td>(</td>
          <td class="paramtype">volatile uint32_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic bitwise inclusive or.  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the bitwise operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.  </dd></dl>

</div>
</div>
<a id="ga987adeb2ae9c2db2551a61aa4b426df2" name="ga987adeb2ae9c2db2551a61aa4b426df2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga987adeb2ae9c2db2551a61aa4b426df2">&#9670;&#160;</a></span>core_util_atomic_fetch_or_explicit_u32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint32_t core_util_atomic_fetch_or_explicit_u32 </td>
          <td>(</td>
          <td class="paramtype">volatile uint32_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="gaa8c5f724d821fa01783eeb9f9b6654bc" name="gaa8c5f724d821fa01783eeb9f9b6654bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8c5f724d821fa01783eeb9f9b6654bc">&#9670;&#160;</a></span>core_util_atomic_fetch_or_u64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t core_util_atomic_fetch_or_u64 </td>
          <td>(</td>
          <td class="paramtype">volatile uint64_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic bitwise inclusive or.  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the bitwise operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.  </dd></dl>

</div>
</div>
<a id="ga7733cc83af1260afd5484d9f8ab64a52" name="ga7733cc83af1260afd5484d9f8ab64a52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7733cc83af1260afd5484d9f8ab64a52">&#9670;&#160;</a></span>core_util_atomic_fetch_or_explicit_u64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint64_t core_util_atomic_fetch_or_explicit_u64 </td>
          <td>(</td>
          <td class="paramtype">volatile uint64_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="gacf176a784cfb5373edfc0c729cf3f528" name="gacf176a784cfb5373edfc0c729cf3f528"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf176a784cfb5373edfc0c729cf3f528">&#9670;&#160;</a></span>core_util_atomic_fetch_xor_u8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t core_util_atomic_fetch_xor_u8 </td>
          <td>(</td>
          <td class="paramtype">volatile uint8_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic bitwise exclusive or. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the bitwise operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value. </dd></dl>

</div>
</div>
<a id="ga7f687c46f29f48b760123770f9cf30f8" name="ga7f687c46f29f48b760123770f9cf30f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f687c46f29f48b760123770f9cf30f8">&#9670;&#160;</a></span>core_util_atomic_fetch_xor_explicit_u8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint8_t core_util_atomic_fetch_xor_explicit_u8 </td>
          <td>(</td>
          <td class="paramtype">volatile uint8_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic bitwise exclusive or.  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the bitwise operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.  </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>memory ordering constraint </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6e10fc29b3da441a87484046a9d3e41f" name="ga6e10fc29b3da441a87484046a9d3e41f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e10fc29b3da441a87484046a9d3e41f">&#9670;&#160;</a></span>core_util_atomic_fetch_xor_u16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t core_util_atomic_fetch_xor_u16 </td>
          <td>(</td>
          <td class="paramtype">volatile uint16_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic bitwise exclusive or.  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the bitwise operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.  </dd></dl>

</div>
</div>
<a id="ga0cac1f70d86145102d3bf1ceaaed4b54" name="ga0cac1f70d86145102d3bf1ceaaed4b54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0cac1f70d86145102d3bf1ceaaed4b54">&#9670;&#160;</a></span>core_util_atomic_fetch_xor_explicit_u16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint16_t core_util_atomic_fetch_xor_explicit_u16 </td>
          <td>(</td>
          <td class="paramtype">volatile uint16_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="ga19cbc4d57409b5eb0ebfc8eee9cd829b" name="ga19cbc4d57409b5eb0ebfc8eee9cd829b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga19cbc4d57409b5eb0ebfc8eee9cd829b">&#9670;&#160;</a></span>core_util_atomic_fetch_xor_u32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t core_util_atomic_fetch_xor_u32 </td>
          <td>(</td>
          <td class="paramtype">volatile uint32_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic bitwise exclusive or.  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the bitwise operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.  </dd></dl>

</div>
</div>
<a id="ga7cf9e78a72b5ed55edcb09240af4e187" name="ga7cf9e78a72b5ed55edcb09240af4e187"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7cf9e78a72b5ed55edcb09240af4e187">&#9670;&#160;</a></span>core_util_atomic_fetch_xor_explicit_u32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint32_t core_util_atomic_fetch_xor_explicit_u32 </td>
          <td>(</td>
          <td class="paramtype">volatile uint32_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="ga6b70c15733c776dbcae1a7ee5c056201" name="ga6b70c15733c776dbcae1a7ee5c056201"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b70c15733c776dbcae1a7ee5c056201">&#9670;&#160;</a></span>core_util_atomic_fetch_xor_u64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t core_util_atomic_fetch_xor_u64 </td>
          <td>(</td>
          <td class="paramtype">volatile uint64_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomic bitwise exclusive or.  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the bitwise operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.  </dd></dl>

</div>
</div>
<a id="ga3cda9f9445bbace6d20e5ae02bc4a6e8" name="ga3cda9f9445bbace6d20e5ae02bc4a6e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3cda9f9445bbace6d20e5ae02bc4a6e8">&#9670;&#160;</a></span>core_util_atomic_fetch_xor_explicit_u64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__platform__toolchain.html#ga4f9a9e7b05304896ba993457907b3f28">MBED_FORCEINLINE</a> uint64_t core_util_atomic_fetch_xor_explicit_u64 </td>
          <td>(</td>
          <td class="paramtype">volatile uint64_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="gaab4e48feaf31dd4fd5907a2b3a3c1aeb" name="gaab4e48feaf31dd4fd5907a2b3a3c1aeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab4e48feaf31dd4fd5907a2b3a3c1aeb">&#9670;&#160;</a></span>core_util_atomic_load() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T core_util_atomic_load </td>
          <td>(</td>
          <td class="paramtype">const volatile T *&#160;</td>
          <td class="paramname"><em>valuePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="gaf006841d45fa1b4c91177e7004d4b306" name="gaf006841d45fa1b4c91177e7004d4b306"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf006841d45fa1b4c91177e7004d4b306">&#9670;&#160;</a></span>core_util_atomic_load() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T core_util_atomic_load </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>valuePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="ga306f116d8f794c82ba15c443295ca6a1" name="ga306f116d8f794c82ba15c443295ca6a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga306f116d8f794c82ba15c443295ca6a1">&#9670;&#160;</a></span>core_util_atomic_store() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void core_util_atomic_store </td>
          <td>(</td>
          <td class="paramtype">volatile T *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mstd::type_identity_t&lt; T &gt;&#160;</td>
          <td class="paramname"><em>desiredValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="gada6132d54ca4aec79c65c19c7088ca3c" name="gada6132d54ca4aec79c65c19c7088ca3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada6132d54ca4aec79c65c19c7088ca3c">&#9670;&#160;</a></span>core_util_atomic_store() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void core_util_atomic_store </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mstd::type_identity_t&lt; T &gt;&#160;</td>
          <td class="paramname"><em>desiredValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="ga6006fb07b7f607cfb37151e4b4b56acb" name="ga6006fb07b7f607cfb37151e4b4b56acb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6006fb07b7f607cfb37151e4b4b56acb">&#9670;&#160;</a></span>core_util_atomic_exchange() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T core_util_atomic_exchange </td>
          <td>(</td>
          <td class="paramtype">volatile T *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mstd::type_identity_t&lt; T &gt;&#160;</td>
          <td class="paramname"><em>desiredValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomic exchange.  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previous value.  </dd></dl>

</div>
</div>
<a id="ga13e01d7aae5e46ac2a329eb64a2a3359" name="ga13e01d7aae5e46ac2a329eb64a2a3359"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga13e01d7aae5e46ac2a329eb64a2a3359">&#9670;&#160;</a></span>core_util_atomic_compare_exchange_strong() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool core_util_atomic_compare_exchange_strong </td>
          <td>(</td>
          <td class="paramtype">volatile T *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mstd::type_identity_t&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mstd::type_identity_t&lt; T &gt;&#160;</td>
          <td class="paramname"><em>desiredValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomic compare and set.  </p>
<p >It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p >Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = atomic_load(p) while not done { done = atomic_cas(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<p >However, if the call is made in a loop like this, the atomic_compare_exchange_weak functions are to be preferred.</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_strong" - it always succeeds if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return does not retry.  </dd></dl>

</div>
</div>
<a id="ga1045786030aaf939a0becfbc0c698d14" name="ga1045786030aaf939a0becfbc0c698d14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1045786030aaf939a0becfbc0c698d14">&#9670;&#160;</a></span>core_util_atomic_compare_exchange_weak() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool core_util_atomic_compare_exchange_weak </td>
          <td>(</td>
          <td class="paramtype">volatile T *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mstd::type_identity_t&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mstd::type_identity_t&lt; T &gt;&#160;</td>
          <td class="paramname"><em>desiredValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomic compare and set.  </p>
<p >It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p >Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old or spurious failure { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = *p // This fetch operation need not be atomic. while not done { done = atomic_compare_exchange_weak(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_weak" - it may spuriously fail if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return will cause a retry anyway, saving the need for an extra loop inside the cas operation.  </dd></dl>

</div>
</div>
<a id="ga68e506e93fabb79d88e8d187a7ac62ff" name="ga68e506e93fabb79d88e8d187a7ac62ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga68e506e93fabb79d88e8d187a7ac62ff">&#9670;&#160;</a></span>core_util_atomic_fetch_add() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T core_util_atomic_fetch_add </td>
          <td>(</td>
          <td class="paramtype">volatile T *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mstd::type_identity_t&lt; T &gt;&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomic add.  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the addition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.  </dd></dl>

</div>
</div>
<a id="gad69d7ef911a6a98e49193bda39af720a" name="gad69d7ef911a6a98e49193bda39af720a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad69d7ef911a6a98e49193bda39af720a">&#9670;&#160;</a></span>core_util_atomic_fetch_sub() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T core_util_atomic_fetch_sub </td>
          <td>(</td>
          <td class="paramtype">volatile T *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mstd::type_identity_t&lt; T &gt;&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomic subtract.  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the subtraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.  </dd></dl>

</div>
</div>
<a id="gad0396fbe5d7c594033d4a02a6c09617b" name="gad0396fbe5d7c594033d4a02a6c09617b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad0396fbe5d7c594033d4a02a6c09617b">&#9670;&#160;</a></span>core_util_atomic_fetch_and()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T core_util_atomic_fetch_and </td>
          <td>(</td>
          <td class="paramtype">volatile T *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mstd::type_identity_t&lt; T &gt;&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomic bitwise and.  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the bitwise operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.  </dd></dl>

</div>
</div>
<a id="gab6c08979b782ee2e7970a57d77ab9247" name="gab6c08979b782ee2e7970a57d77ab9247"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab6c08979b782ee2e7970a57d77ab9247">&#9670;&#160;</a></span>core_util_atomic_fetch_or()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T core_util_atomic_fetch_or </td>
          <td>(</td>
          <td class="paramtype">volatile T *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mstd::type_identity_t&lt; T &gt;&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomic bitwise inclusive or.  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the bitwise operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.  </dd></dl>

</div>
</div>
<a id="ga662a921cf2a19b168ddd5451f19ea25e" name="ga662a921cf2a19b168ddd5451f19ea25e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga662a921cf2a19b168ddd5451f19ea25e">&#9670;&#160;</a></span>core_util_atomic_fetch_xor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T core_util_atomic_fetch_xor </td>
          <td>(</td>
          <td class="paramtype">volatile T *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mstd::type_identity_t&lt; T &gt;&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomic bitwise exclusive or.  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the bitwise operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.  </dd></dl>

</div>
</div>
<a id="ga58aba5c200df94e819ecb0caac03d7b0" name="ga58aba5c200df94e819ecb0caac03d7b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58aba5c200df94e819ecb0caac03d7b0">&#9670;&#160;</a></span>core_util_atomic_load_explicit() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T core_util_atomic_load_explicit </td>
          <td>(</td>
          <td class="paramtype">const volatile T *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="ga3e4b392e7dbc3f101c7f1c11dedd0099" name="ga3e4b392e7dbc3f101c7f1c11dedd0099"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3e4b392e7dbc3f101c7f1c11dedd0099">&#9670;&#160;</a></span>core_util_atomic_load_explicit() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T core_util_atomic_load_explicit </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="gadef7d72ccdaf35745d619aebbd8af2db" name="gadef7d72ccdaf35745d619aebbd8af2db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadef7d72ccdaf35745d619aebbd8af2db">&#9670;&#160;</a></span>core_util_atomic_store_explicit() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void core_util_atomic_store_explicit </td>
          <td>(</td>
          <td class="paramtype">volatile T *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mstd::type_identity_t&lt; T &gt;&#160;</td>
          <td class="paramname"><em>desiredValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="ga6ea8c38ac4b519d90d5056ff2266558d" name="ga6ea8c38ac4b519d90d5056ff2266558d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ea8c38ac4b519d90d5056ff2266558d">&#9670;&#160;</a></span>core_util_atomic_store_explicit() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void core_util_atomic_store_explicit </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mstd::type_identity_t&lt; T &gt;&#160;</td>
          <td class="paramname"><em>desiredValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="gad440e6b45a3f1d4d6f7241b2e1e9decd" name="gad440e6b45a3f1d4d6f7241b2e1e9decd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad440e6b45a3f1d4d6f7241b2e1e9decd">&#9670;&#160;</a></span>core_util_atomic_exchange_explicit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T core_util_atomic_exchange_explicit </td>
          <td>(</td>
          <td class="paramtype">volatile T *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mstd::type_identity_t&lt; T &gt;&#160;</td>
          <td class="paramname"><em>desiredValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="gabfd30eaf5f8bff0c904836c301e5e9b5" name="gabfd30eaf5f8bff0c904836c301e5e9b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabfd30eaf5f8bff0c904836c301e5e9b5">&#9670;&#160;</a></span>core_util_atomic_compare_exchange_strong_explicit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool core_util_atomic_compare_exchange_strong_explicit </td>
          <td>(</td>
          <td class="paramtype">volatile T *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mstd::type_identity_t&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mstd::type_identity_t&lt; T &gt;&#160;</td>
          <td class="paramname"><em>desiredValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>success</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>failure</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="ga0c77005ef582df2a62ef1edd5bb79afa" name="ga0c77005ef582df2a62ef1edd5bb79afa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c77005ef582df2a62ef1edd5bb79afa">&#9670;&#160;</a></span>core_util_atomic_compare_exchange_weak_explicit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool core_util_atomic_compare_exchange_weak_explicit </td>
          <td>(</td>
          <td class="paramtype">volatile T *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mstd::type_identity_t&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mstd::type_identity_t&lt; T &gt;&#160;</td>
          <td class="paramname"><em>desiredValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>success</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>failure</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="gaa776fa21be98743bd57098890aea2417" name="gaa776fa21be98743bd57098890aea2417"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa776fa21be98743bd57098890aea2417">&#9670;&#160;</a></span>core_util_atomic_fetch_add_explicit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T core_util_atomic_fetch_add_explicit </td>
          <td>(</td>
          <td class="paramtype">volatile T *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mstd::type_identity_t&lt; T &gt;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="gae3fbf566237e0f010f72ca2885ea742d" name="gae3fbf566237e0f010f72ca2885ea742d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3fbf566237e0f010f72ca2885ea742d">&#9670;&#160;</a></span>core_util_atomic_fetch_sub_explicit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T core_util_atomic_fetch_sub_explicit </td>
          <td>(</td>
          <td class="paramtype">volatile T *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mstd::type_identity_t&lt; T &gt;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="gada1610934486f89ba3f75a7d9e5be83f" name="gada1610934486f89ba3f75a7d9e5be83f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada1610934486f89ba3f75a7d9e5be83f">&#9670;&#160;</a></span>core_util_atomic_fetch_and_explicit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T core_util_atomic_fetch_and_explicit </td>
          <td>(</td>
          <td class="paramtype">volatile T *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mstd::type_identity_t&lt; T &gt;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="ga10260701769b84170105c499807aeb8e" name="ga10260701769b84170105c499807aeb8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10260701769b84170105c499807aeb8e">&#9670;&#160;</a></span>core_util_atomic_fetch_or_explicit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T core_util_atomic_fetch_or_explicit </td>
          <td>(</td>
          <td class="paramtype">volatile T *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mstd::type_identity_t&lt; T &gt;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="gab175114f6b2881ce253b5e34c0d6b146" name="gab175114f6b2881ce253b5e34c0d6b146"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab175114f6b2881ce253b5e34c0d6b146">&#9670;&#160;</a></span>core_util_atomic_fetch_xor_explicit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T core_util_atomic_fetch_xor_explicit </td>
          <td>(</td>
          <td class="paramtype">volatile T *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mstd::type_identity_t&lt; T &gt;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="gad2e2578cdfa076b590e6d15d4ad5b5a6" name="gad2e2578cdfa076b590e6d15d4ad5b5a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad2e2578cdfa076b590e6d15d4ad5b5a6">&#9670;&#160;</a></span>core_util_atomic_load() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * core_util_atomic_load </td>
          <td>(</td>
          <td class="paramtype">T *const volatile *&#160;</td>
          <td class="paramname"><em>valuePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l01060">1060</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="ga5251d6b71eef2a7964bfb646ef0031c7" name="ga5251d6b71eef2a7964bfb646ef0031c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5251d6b71eef2a7964bfb646ef0031c7">&#9670;&#160;</a></span>core_util_atomic_load() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * core_util_atomic_load </td>
          <td>(</td>
          <td class="paramtype">T *const *&#160;</td>
          <td class="paramname"><em>valuePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l01066">1066</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="ga971305d465d358274ec12bcc76b28bf8" name="ga971305d465d358274ec12bcc76b28bf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga971305d465d358274ec12bcc76b28bf8">&#9670;&#160;</a></span>core_util_atomic_store() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void core_util_atomic_store </td>
          <td>(</td>
          <td class="paramtype">T *volatile *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mstd::type_identity_t&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>desiredValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="ga85c51f93131d885b17df222e7817cef2" name="ga85c51f93131d885b17df222e7817cef2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85c51f93131d885b17df222e7817cef2">&#9670;&#160;</a></span>core_util_atomic_store() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void core_util_atomic_store </td>
          <td>(</td>
          <td class="paramtype">T **&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mstd::type_identity_t&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>desiredValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="ga6c9399ec5c42db51fe779f3ad0bbfb5b" name="ga6c9399ec5c42db51fe779f3ad0bbfb5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c9399ec5c42db51fe779f3ad0bbfb5b">&#9670;&#160;</a></span>core_util_atomic_exchange() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * core_util_atomic_exchange </td>
          <td>(</td>
          <td class="paramtype">T *volatile *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mstd::type_identity_t&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>desiredValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomic exchange.  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location. </td></tr>
    <tr><td class="paramname">desiredValue</td><td>The value to store. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previous value.  </dd></dl>

</div>
</div>
<a id="ga42505988ea9e1ecb5de1e5c95a710a80" name="ga42505988ea9e1ecb5de1e5c95a710a80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga42505988ea9e1ecb5de1e5c95a710a80">&#9670;&#160;</a></span>core_util_atomic_compare_exchange_strong() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool core_util_atomic_compare_exchange_strong </td>
          <td>(</td>
          <td class="paramtype">T *volatile *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mstd::type_identity_t&lt; T &gt; **&#160;</td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mstd::type_identity_t&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>desiredValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomic compare and set.  </p>
<p >It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p >Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = atomic_load(p) while not done { done = atomic_cas(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<p >However, if the call is made in a loop like this, the atomic_compare_exchange_weak functions are to be preferred.</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_strong" - it always succeeds if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return does not retry.  </dd></dl>

</div>
</div>
<a id="ga5cb27ab094ba8acab17b47d5356c7579" name="ga5cb27ab094ba8acab17b47d5356c7579"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5cb27ab094ba8acab17b47d5356c7579">&#9670;&#160;</a></span>core_util_atomic_compare_exchange_weak() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool core_util_atomic_compare_exchange_weak </td>
          <td>(</td>
          <td class="paramtype">T *volatile *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mstd::type_identity_t&lt; T &gt; **&#160;</td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mstd::type_identity_t&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>desiredValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomic compare and set.  </p>
<p >It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p >Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old or spurious failure { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = *p // This fetch operation need not be atomic. while not done { done = atomic_compare_exchange_weak(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_weak" - it may spuriously fail if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. This call would normally be used when a fail return will cause a retry anyway, saving the need for an extra loop inside the cas operation.  </dd></dl>

</div>
</div>
<a id="gaf66cad08576bf9ce1be62417123d992e" name="gaf66cad08576bf9ce1be62417123d992e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf66cad08576bf9ce1be62417123d992e">&#9670;&#160;</a></span>core_util_atomic_fetch_add() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * core_util_atomic_fetch_add </td>
          <td>(</td>
          <td class="paramtype">T *volatile *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomic add.  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the addition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.  </dd></dl>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l01225">1225</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="ga54e97ec3e7f6dd8eb2437c28e4da9ccb" name="ga54e97ec3e7f6dd8eb2437c28e4da9ccb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga54e97ec3e7f6dd8eb2437c28e4da9ccb">&#9670;&#160;</a></span>core_util_atomic_fetch_sub() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * core_util_atomic_fetch_sub </td>
          <td>(</td>
          <td class="paramtype">T *volatile *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomic subtract.  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being modified. </td></tr>
    <tr><td class="paramname">arg</td><td>The argument for the subtraction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original value.  </dd></dl>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l01237">1237</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="ga1e8bc70dbb6527656dc13c1527e12617" name="ga1e8bc70dbb6527656dc13c1527e12617"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e8bc70dbb6527656dc13c1527e12617">&#9670;&#160;</a></span>core_util_atomic_load_explicit() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * core_util_atomic_load_explicit </td>
          <td>(</td>
          <td class="paramtype">T *const volatile *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l01072">1072</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="ga1242e76508f4dff0698d67dc95e71f21" name="ga1242e76508f4dff0698d67dc95e71f21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1242e76508f4dff0698d67dc95e71f21">&#9670;&#160;</a></span>core_util_atomic_load_explicit() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * core_util_atomic_load_explicit </td>
          <td>(</td>
          <td class="paramtype">T *const *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l01078">1078</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="gae85fe2c55665a5b1b46e285116a36b78" name="gae85fe2c55665a5b1b46e285116a36b78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae85fe2c55665a5b1b46e285116a36b78">&#9670;&#160;</a></span>core_util_atomic_store_explicit() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void core_util_atomic_store_explicit </td>
          <td>(</td>
          <td class="paramtype">T *volatile *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mstd::type_identity_t&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>desiredValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="ga4fe2a700dffcc55fe43509c237319deb" name="ga4fe2a700dffcc55fe43509c237319deb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4fe2a700dffcc55fe43509c237319deb">&#9670;&#160;</a></span>core_util_atomic_store_explicit() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void core_util_atomic_store_explicit </td>
          <td>(</td>
          <td class="paramtype">T **&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mstd::type_identity_t&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>desiredValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="ga52c2df411d69485bd9168b50543e942b" name="ga52c2df411d69485bd9168b50543e942b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga52c2df411d69485bd9168b50543e942b">&#9670;&#160;</a></span>core_util_atomic_exchange_explicit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * core_util_atomic_exchange_explicit </td>
          <td>(</td>
          <td class="paramtype">T *volatile *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mstd::type_identity_t&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>desiredValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="ga16e2df8237b3c8e054ac581f0e367815" name="ga16e2df8237b3c8e054ac581f0e367815"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16e2df8237b3c8e054ac581f0e367815">&#9670;&#160;</a></span>core_util_atomic_compare_exchange_strong_explicit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool core_util_atomic_compare_exchange_strong_explicit </td>
          <td>(</td>
          <td class="paramtype">T *volatile *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mstd::type_identity_t&lt; T &gt; **&#160;</td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mstd::type_identity_t&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>desiredValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>success</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>failure</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="gad5c1182e5bb8f704ec8f747fdf6811a6" name="gad5c1182e5bb8f704ec8f747fdf6811a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5c1182e5bb8f704ec8f747fdf6811a6">&#9670;&#160;</a></span>core_util_atomic_compare_exchange_weak_explicit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool core_util_atomic_compare_exchange_weak_explicit </td>
          <td>(</td>
          <td class="paramtype">T *volatile *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mstd::type_identity_t&lt; T &gt; **&#160;</td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mstd::type_identity_t&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>desiredValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>success</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>failure</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a id="ga2a77ed3c60e37bb68a768e88da648456" name="ga2a77ed3c60e37bb68a768e88da648456"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2a77ed3c60e37bb68a768e88da648456">&#9670;&#160;</a></span>core_util_atomic_fetch_add_explicit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * core_util_atomic_fetch_add_explicit </td>
          <td>(</td>
          <td class="paramtype">T *volatile *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l01231">1231</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
<a id="ga769fd6289b36b9baf9006a52adfc503b" name="ga769fd6289b36b9baf9006a52adfc503b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga769fd6289b36b9baf9006a52adfc503b">&#9670;&#160;</a></span>core_util_atomic_fetch_sub_explicit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * core_util_atomic_fetch_sub_explicit </td>
          <td>(</td>
          <td class="paramtype">T *volatile *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__platform__atomic.html#gaa770b34054b2e54c6bcbd0e9423ecd88">mbed_memory_order</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="mbed__atomic__impl_8h_source.html#l01243">1243</a> of file <a class="el" href="mbed__atomic__impl_8h_source.html">mbed_atomic_impl.h</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Mbed OS Reference: NetworkStack Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="mbed-ce_55x55.png"/></td>
  <td id="projectalign">
   <div id="projectname">Mbed OS Reference
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('class_network_stack.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a>  </div>
  <div class="headertitle"><div class="title">NetworkStack Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group__mbed-os-public.html">Public API</a> &raquo; <a class="el" href="group__connectivity-public-api.html">Connectivity</a> &raquo; <a class="el" href="group___net_socket.html">NetSocket</a></div></div></div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="class_network_stack.html" title="NetworkStack class.">NetworkStack</a> class.  
 <a href="class_network_stack.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_network_stack_8h_source.html">NetworkStack.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for NetworkStack:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_network_stack.png" usemap="#NetworkStack_map" alt=""/>
  <map id="NetworkStack_map" name="NetworkStack_map">
<area href="class_d_n_s.html" title="Base class for DNS provider." alt="DNS" shape="rect" coords="119,0,347,24"/>
<area href="class_onboard_network_stack.html" title="mbed OS API for onboard IP stack abstraction" alt="OnboardNetworkStack" shape="rect" coords="0,112,228,136"/>
<area href="classmbed_1_1_a_t___cellular_stack.html" title="Class AT_CellularStack." alt="AT_CellularStack" shape="rect" coords="238,112,466,136"/>
<area href="class_nanostack.html" alt="Nanostack" shape="rect" coords="0,168,228,192"/>
<area href="classmbed_1_1_g_e_m_a_l_t_o___c_i_n_t_e_r_i_o_n___cellular_stack.html" alt="GEMALTO_CINTERION_CellularStack" shape="rect" coords="476,168,704,192"/>
<area href="classmbed_1_1_q_u_e_c_t_e_l___b_c95___cellular_stack.html" alt="QUECTEL_BC95_CellularStack" shape="rect" coords="476,224,704,248"/>
<area href="classmbed_1_1_q_u_e_c_t_e_l___b_g96___cellular_stack.html" alt="QUECTEL_BG96_CellularStack" shape="rect" coords="476,280,704,304"/>
<area href="classmbed_1_1_q_u_e_c_t_e_l___m26___cellular_stack.html" alt="QUECTEL_M26_CellularStack" shape="rect" coords="476,336,704,360"/>
<area href="classmbed_1_1_r_m1000___a_t___cellular_stack.html" alt="RM1000_AT_CellularStack" shape="rect" coords="476,392,704,416"/>
<area href="classmbed_1_1_t_e_l_i_t___m_e310___cellular_stack.html" alt="TELIT_ME310_CellularStack" shape="rect" coords="476,448,704,472"/>
<area href="classmbed_1_1_u_b_l_o_x___a_t___cellular_stack.html" alt="UBLOX_AT_CellularStack" shape="rect" coords="476,504,704,528"/>
<area href="classmbed_1_1_u_b_l_o_x___n2_x_x___cellular_stack.html" alt="UBLOX_N2XX_CellularStack" shape="rect" coords="476,560,704,584"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a7640d35fa5798e1ff5ce0cf9a7faa097"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>(int delay_ms, <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; void()&gt; user_cb)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_stack.html#a7640d35fa5798e1ff5ce0cf9a7faa097">call_in_callback_cb_t</a></td></tr>
<tr class="memdesc:a7640d35fa5798e1ff5ce0cf9a7faa097"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for a call-in callback.  <a href="class_network_stack.html#a7640d35fa5798e1ff5ce0cf9a7faa097">More...</a><br /></td></tr>
<tr class="separator:a7640d35fa5798e1ff5ce0cf9a7faa097"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2ab48210e24fc7efb4e1cada14c4b57b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_stack.html#a2ab48210e24fc7efb4e1cada14c4b57b">get_ip_address</a> (<a class="el" href="class_socket_address.html">SocketAddress</a> *address)</td></tr>
<tr class="memdesc:a2ab48210e24fc7efb4e1cada14c4b57b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the local IP address.  <a href="class_network_stack.html#a2ab48210e24fc7efb4e1cada14c4b57b">More...</a><br /></td></tr>
<tr class="separator:a2ab48210e24fc7efb4e1cada14c4b57b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77de8d1afa4b83dd6f560dc39251e1eb"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_stack.html#a77de8d1afa4b83dd6f560dc39251e1eb">get_ipv6_link_local_address</a> (<a class="el" href="class_socket_address.html">SocketAddress</a> *address)</td></tr>
<tr class="memdesc:a77de8d1afa4b83dd6f560dc39251e1eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the IPv6 link local address.  <a href="class_network_stack.html#a77de8d1afa4b83dd6f560dc39251e1eb">More...</a><br /></td></tr>
<tr class="separator:a77de8d1afa4b83dd6f560dc39251e1eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad597f0496e42b17be72d00fa832e0963"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_stack.html#ad597f0496e42b17be72d00fa832e0963">get_ip_address_if</a> (<a class="el" href="class_socket_address.html">SocketAddress</a> *address, const char *interface_name)</td></tr>
<tr class="memdesc:ad597f0496e42b17be72d00fa832e0963"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the local IP address on interface name.  <a href="class_network_stack.html#ad597f0496e42b17be72d00fa832e0963">More...</a><br /></td></tr>
<tr class="separator:ad597f0496e42b17be72d00fa832e0963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eeb3e01ec53546b61fd7b823a4980ef"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_stack.html#a5eeb3e01ec53546b61fd7b823a4980ef">gethostbyname</a> (const char *host, <a class="el" href="class_socket_address.html">SocketAddress</a> *address, nsapi_version_t version=<a class="el" href="group___net_socket.html#ggacde826f51019112728ee4ae4e10b8a4fa09ed8714a685448ae2e149c4a142ffe7">NSAPI_UNSPEC</a>, const char *interface_name=NULL)</td></tr>
<tr class="memdesc:a5eeb3e01ec53546b61fd7b823a4980ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translates a hostname to an IP address with specific version.  <a href="class_network_stack.html#a5eeb3e01ec53546b61fd7b823a4980ef">More...</a><br /></td></tr>
<tr class="separator:a5eeb3e01ec53546b61fd7b823a4980ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87a975b9ef736cef63334895c5770660"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga4dc6e8ec26b364f135278917c3f27c6e">nsapi_value_or_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_stack.html#a87a975b9ef736cef63334895c5770660">getaddrinfo</a> (const char *hostname, <a class="el" href="class_socket_address.html">SocketAddress</a> *hints, <a class="el" href="class_socket_address.html">SocketAddress</a> **res, const char *interface_name=NULL)</td></tr>
<tr class="memdesc:a87a975b9ef736cef63334895c5770660"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate a hostname to the multiple IP addresses with specific version using network interface name.  <a href="class_network_stack.html#a87a975b9ef736cef63334895c5770660">More...</a><br /></td></tr>
<tr class="separator:a87a975b9ef736cef63334895c5770660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab43b64cae1f145615db7f697d34552d7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga4dc6e8ec26b364f135278917c3f27c6e">nsapi_value_or_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_stack.html#ab43b64cae1f145615db7f697d34552d7">gethostbyname_async</a> (const char *host, <a class="el" href="classmbed_1_1_callback.html">hostbyname_cb_t</a> callback, nsapi_version_t version=<a class="el" href="group___net_socket.html#ggacde826f51019112728ee4ae4e10b8a4fa09ed8714a685448ae2e149c4a142ffe7">NSAPI_UNSPEC</a>, const char *interface_name=NULL)</td></tr>
<tr class="memdesc:ab43b64cae1f145615db7f697d34552d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translates a hostname to multiple IP addresses (asynchronous)  <a href="class_network_stack.html#ab43b64cae1f145615db7f697d34552d7">More...</a><br /></td></tr>
<tr class="separator:ab43b64cae1f145615db7f697d34552d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa964732e6c585b596adc760fe95f40f5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga4dc6e8ec26b364f135278917c3f27c6e">nsapi_value_or_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_stack.html#aa964732e6c585b596adc760fe95f40f5">getaddrinfo_async</a> (const char *hostname, <a class="el" href="class_socket_address.html">SocketAddress</a> *hints, <a class="el" href="classmbed_1_1_callback.html">hostbyname_cb_t</a> callback, const char *interface_name=NULL)</td></tr>
<tr class="memdesc:aa964732e6c585b596adc760fe95f40f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translates a hostname to the multiple IP addresses (asynchronous)  <a href="class_network_stack.html#aa964732e6c585b596adc760fe95f40f5">More...</a><br /></td></tr>
<tr class="separator:aa964732e6c585b596adc760fe95f40f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26000e958701f5b35886fac1757c0bf4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_stack.html#a26000e958701f5b35886fac1757c0bf4">gethostbyname_async_cancel</a> (int id)</td></tr>
<tr class="memdesc:a26000e958701f5b35886fac1757c0bf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancels asynchronous hostname translation.  <a href="class_network_stack.html#a26000e958701f5b35886fac1757c0bf4">More...</a><br /></td></tr>
<tr class="separator:a26000e958701f5b35886fac1757c0bf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbf8dbcd865fee3ebef07fefbea802a7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_stack.html#adbf8dbcd865fee3ebef07fefbea802a7">add_dns_server</a> (const <a class="el" href="class_socket_address.html">SocketAddress</a> &amp;address, const char *interface_name=NULL)</td></tr>
<tr class="memdesc:adbf8dbcd865fee3ebef07fefbea802a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a domain name server to list of servers to query.  <a href="class_network_stack.html#adbf8dbcd865fee3ebef07fefbea802a7">More...</a><br /></td></tr>
<tr class="separator:adbf8dbcd865fee3ebef07fefbea802a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ccb0f7a5af95e76d0dea335ab866047"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_stack.html#a0ccb0f7a5af95e76d0dea335ab866047">get_dns_server</a> (int index, <a class="el" href="class_socket_address.html">SocketAddress</a> *address, const char *interface_name=NULL)</td></tr>
<tr class="memdesc:a0ccb0f7a5af95e76d0dea335ab866047"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a domain name server from a list of servers to query.  <a href="class_network_stack.html#a0ccb0f7a5af95e76d0dea335ab866047">More...</a><br /></td></tr>
<tr class="separator:a0ccb0f7a5af95e76d0dea335ab866047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5f46dd32614b93bc8a9d41b822a7ab7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_onboard_network_stack.html">OnboardNetworkStack</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_stack.html#aa5f46dd32614b93bc8a9d41b822a7ab7">onboardNetworkStack</a> ()</td></tr>
<tr class="memdesc:aa5f46dd32614b93bc8a9d41b822a7ab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamic downcast to a <a class="el" href="class_onboard_network_stack.html" title="mbed OS API for onboard IP stack abstraction">OnboardNetworkStack</a>.  <a href="class_network_stack.html#aa5f46dd32614b93bc8a9d41b822a7ab7">More...</a><br /></td></tr>
<tr class="separator:aa5f46dd32614b93bc8a9d41b822a7ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a917003ace34919b35f8e1dced0b52a05"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_stack.html#a917003ace34919b35f8e1dced0b52a05">socket_open</a> (<a class="el" href="group___net_socket.html#gad0273762e5e5643dda87a74c7de45b69">nsapi_socket_t</a> *handle, nsapi_protocol_t proto)=0</td></tr>
<tr class="memdesc:a917003ace34919b35f8e1dced0b52a05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens a socket.  <a href="class_network_stack.html#a917003ace34919b35f8e1dced0b52a05">More...</a><br /></td></tr>
<tr class="separator:a917003ace34919b35f8e1dced0b52a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a519c5ecb722a17ea2acafad17f9386a3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_stack.html#a519c5ecb722a17ea2acafad17f9386a3">socket_close</a> (<a class="el" href="group___net_socket.html#gad0273762e5e5643dda87a74c7de45b69">nsapi_socket_t</a> handle)=0</td></tr>
<tr class="memdesc:a519c5ecb722a17ea2acafad17f9386a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the socket.  <a href="class_network_stack.html#a519c5ecb722a17ea2acafad17f9386a3">More...</a><br /></td></tr>
<tr class="separator:a519c5ecb722a17ea2acafad17f9386a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac92c15ee2f3ef7e26cb881393559d1ff"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_stack.html#ac92c15ee2f3ef7e26cb881393559d1ff">socket_bind</a> (<a class="el" href="group___net_socket.html#gad0273762e5e5643dda87a74c7de45b69">nsapi_socket_t</a> handle, const <a class="el" href="class_socket_address.html">SocketAddress</a> &amp;address)=0</td></tr>
<tr class="memdesc:ac92c15ee2f3ef7e26cb881393559d1ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a specific address to a socket.  <a href="class_network_stack.html#ac92c15ee2f3ef7e26cb881393559d1ff">More...</a><br /></td></tr>
<tr class="separator:ac92c15ee2f3ef7e26cb881393559d1ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45a50de4d7a421ac592f7effa7765639"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_stack.html#a45a50de4d7a421ac592f7effa7765639">socket_listen</a> (<a class="el" href="group___net_socket.html#gad0273762e5e5643dda87a74c7de45b69">nsapi_socket_t</a> handle, int backlog)=0</td></tr>
<tr class="memdesc:a45a50de4d7a421ac592f7effa7765639"><td class="mdescLeft">&#160;</td><td class="mdescRight">Listen for connections on a TCP socket.  <a href="class_network_stack.html#a45a50de4d7a421ac592f7effa7765639">More...</a><br /></td></tr>
<tr class="separator:a45a50de4d7a421ac592f7effa7765639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad584c350cb47627892fd2783e4c0c88a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_stack.html#ad584c350cb47627892fd2783e4c0c88a">socket_connect</a> (<a class="el" href="group___net_socket.html#gad0273762e5e5643dda87a74c7de45b69">nsapi_socket_t</a> handle, const <a class="el" href="class_socket_address.html">SocketAddress</a> &amp;address)=0</td></tr>
<tr class="memdesc:ad584c350cb47627892fd2783e4c0c88a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connects TCP socket to a remote host.  <a href="class_network_stack.html#ad584c350cb47627892fd2783e4c0c88a">More...</a><br /></td></tr>
<tr class="separator:ad584c350cb47627892fd2783e4c0c88a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa497dbf81d1e9844f7c73ea44a9b6e54"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_stack.html#aa497dbf81d1e9844f7c73ea44a9b6e54">socket_accept</a> (<a class="el" href="group___net_socket.html#gad0273762e5e5643dda87a74c7de45b69">nsapi_socket_t</a> server, <a class="el" href="group___net_socket.html#gad0273762e5e5643dda87a74c7de45b69">nsapi_socket_t</a> *handle, <a class="el" href="class_socket_address.html">SocketAddress</a> *address=0)=0</td></tr>
<tr class="memdesc:aa497dbf81d1e9844f7c73ea44a9b6e54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accepts a connection on a TCP socket.  <a href="class_network_stack.html#aa497dbf81d1e9844f7c73ea44a9b6e54">More...</a><br /></td></tr>
<tr class="separator:aa497dbf81d1e9844f7c73ea44a9b6e54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70b5c1fd2bc705be0cc7651532008b8a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga1aef0d1a2599df92bb4499b5c4262d25">nsapi_size_or_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_stack.html#a70b5c1fd2bc705be0cc7651532008b8a">socket_send</a> (<a class="el" href="group___net_socket.html#gad0273762e5e5643dda87a74c7de45b69">nsapi_socket_t</a> handle, const void *data, <a class="el" href="group___net_socket.html#gaeaef3ae1ffcf0d50c66fa2ca37621281">nsapi_size_t</a> size)=0</td></tr>
<tr class="memdesc:a70b5c1fd2bc705be0cc7651532008b8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send data over a TCP socket.  <a href="class_network_stack.html#a70b5c1fd2bc705be0cc7651532008b8a">More...</a><br /></td></tr>
<tr class="separator:a70b5c1fd2bc705be0cc7651532008b8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a178a8c725d8f646ff6b26b381d2ac2c6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga1aef0d1a2599df92bb4499b5c4262d25">nsapi_size_or_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_stack.html#a178a8c725d8f646ff6b26b381d2ac2c6">socket_recv</a> (<a class="el" href="group___net_socket.html#gad0273762e5e5643dda87a74c7de45b69">nsapi_socket_t</a> handle, void *data, <a class="el" href="group___net_socket.html#gaeaef3ae1ffcf0d50c66fa2ca37621281">nsapi_size_t</a> size)=0</td></tr>
<tr class="memdesc:a178a8c725d8f646ff6b26b381d2ac2c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive data over a TCP socket.  <a href="class_network_stack.html#a178a8c725d8f646ff6b26b381d2ac2c6">More...</a><br /></td></tr>
<tr class="separator:a178a8c725d8f646ff6b26b381d2ac2c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75c6134df4d9116db6d9354c000bc354"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga1aef0d1a2599df92bb4499b5c4262d25">nsapi_size_or_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_stack.html#a75c6134df4d9116db6d9354c000bc354">socket_sendto</a> (<a class="el" href="group___net_socket.html#gad0273762e5e5643dda87a74c7de45b69">nsapi_socket_t</a> handle, const <a class="el" href="class_socket_address.html">SocketAddress</a> &amp;address, const void *data, <a class="el" href="group___net_socket.html#gaeaef3ae1ffcf0d50c66fa2ca37621281">nsapi_size_t</a> size)=0</td></tr>
<tr class="memdesc:a75c6134df4d9116db6d9354c000bc354"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a packet over a UDP socket.  <a href="class_network_stack.html#a75c6134df4d9116db6d9354c000bc354">More...</a><br /></td></tr>
<tr class="separator:a75c6134df4d9116db6d9354c000bc354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33819f2c330cad315163b285e28371e0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga1aef0d1a2599df92bb4499b5c4262d25">nsapi_size_or_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_stack.html#a33819f2c330cad315163b285e28371e0">socket_recvfrom</a> (<a class="el" href="group___net_socket.html#gad0273762e5e5643dda87a74c7de45b69">nsapi_socket_t</a> handle, <a class="el" href="class_socket_address.html">SocketAddress</a> *address, void *buffer, <a class="el" href="group___net_socket.html#gaeaef3ae1ffcf0d50c66fa2ca37621281">nsapi_size_t</a> size)=0</td></tr>
<tr class="memdesc:a33819f2c330cad315163b285e28371e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive a packet over a UDP socket.  <a href="class_network_stack.html#a33819f2c330cad315163b285e28371e0">More...</a><br /></td></tr>
<tr class="separator:a33819f2c330cad315163b285e28371e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6e5ab3271a4df6347b400bd7e16fdc0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga1aef0d1a2599df92bb4499b5c4262d25">nsapi_size_or_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_stack.html#aa6e5ab3271a4df6347b400bd7e16fdc0">socket_sendto_control</a> (<a class="el" href="group___net_socket.html#gad0273762e5e5643dda87a74c7de45b69">nsapi_socket_t</a> handle, const <a class="el" href="class_socket_address.html">SocketAddress</a> &amp;address, const void *data, <a class="el" href="group___net_socket.html#gaeaef3ae1ffcf0d50c66fa2ca37621281">nsapi_size_t</a> size, <a class="el" href="group___net_socket.html#gad737df4845d4a53ab1bf720f73572a7e">nsapi_msghdr_t</a> *control, <a class="el" href="group___net_socket.html#gaeaef3ae1ffcf0d50c66fa2ca37621281">nsapi_size_t</a> control_size)</td></tr>
<tr class="memdesc:aa6e5ab3271a4df6347b400bd7e16fdc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a packet with ancillary data over a UDP socket.  <a href="class_network_stack.html#aa6e5ab3271a4df6347b400bd7e16fdc0">More...</a><br /></td></tr>
<tr class="separator:aa6e5ab3271a4df6347b400bd7e16fdc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a345f6e49fcae39c08ca892e2d1b6337b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga1aef0d1a2599df92bb4499b5c4262d25">nsapi_size_or_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_stack.html#a345f6e49fcae39c08ca892e2d1b6337b">socket_recvfrom_control</a> (<a class="el" href="group___net_socket.html#gad0273762e5e5643dda87a74c7de45b69">nsapi_socket_t</a> handle, <a class="el" href="class_socket_address.html">SocketAddress</a> *address, void *data, <a class="el" href="group___net_socket.html#gaeaef3ae1ffcf0d50c66fa2ca37621281">nsapi_size_t</a> size, <a class="el" href="group___net_socket.html#gad737df4845d4a53ab1bf720f73572a7e">nsapi_msghdr_t</a> *control, <a class="el" href="group___net_socket.html#gaeaef3ae1ffcf0d50c66fa2ca37621281">nsapi_size_t</a> control_size)</td></tr>
<tr class="memdesc:a345f6e49fcae39c08ca892e2d1b6337b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive a packet with ancillary data over a UDP socket.  <a href="class_network_stack.html#a345f6e49fcae39c08ca892e2d1b6337b">More...</a><br /></td></tr>
<tr class="separator:a345f6e49fcae39c08ca892e2d1b6337b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a836e3ddbc6fea2ce55bfcb477f56387c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_stack.html#a836e3ddbc6fea2ce55bfcb477f56387c">socket_attach</a> (<a class="el" href="group___net_socket.html#gad0273762e5e5643dda87a74c7de45b69">nsapi_socket_t</a> handle, void(*callback)(void *), void *data)=0</td></tr>
<tr class="memdesc:a836e3ddbc6fea2ce55bfcb477f56387c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a callback on state change of the socket.  <a href="class_network_stack.html#a836e3ddbc6fea2ce55bfcb477f56387c">More...</a><br /></td></tr>
<tr class="separator:a836e3ddbc6fea2ce55bfcb477f56387c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac9e14a8be89337c5aea17fd705c3f46"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_stack.html#aac9e14a8be89337c5aea17fd705c3f46">setsockopt</a> (<a class="el" href="group___net_socket.html#gad0273762e5e5643dda87a74c7de45b69">nsapi_socket_t</a> handle, int level, int optname, const void *optval, unsigned optlen)</td></tr>
<tr class="memdesc:aac9e14a8be89337c5aea17fd705c3f46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set stack-specific socket options.  <a href="class_network_stack.html#aac9e14a8be89337c5aea17fd705c3f46">More...</a><br /></td></tr>
<tr class="separator:aac9e14a8be89337c5aea17fd705c3f46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add47ee70f334bcabd0df63f116143311"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_network_stack.html#add47ee70f334bcabd0df63f116143311">getsockopt</a> (<a class="el" href="group___net_socket.html#gad0273762e5e5643dda87a74c7de45b69">nsapi_socket_t</a> handle, int level, int optname, void *optval, unsigned *optlen)</td></tr>
<tr class="memdesc:add47ee70f334bcabd0df63f116143311"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get stack-specific socket options.  <a href="class_network_stack.html#add47ee70f334bcabd0df63f116143311">More...</a><br /></td></tr>
<tr class="separator:add47ee70f334bcabd0df63f116143311"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p ><a class="el" href="class_network_stack.html" title="NetworkStack class.">NetworkStack</a> class. </p>
<p >Common interface that is shared between hardware that can connect to a network over IP. By implementing the <a class="el" href="class_network_stack.html" title="NetworkStack class.">NetworkStack</a>, a network stack can be used as a target for instantiating network sockets. </p>

<p class="definition">Definition at line <a class="el" href="_network_stack_8h_source.html#l00042">42</a> of file <a class="el" href="_network_stack_8h_source.html">NetworkStack.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a7640d35fa5798e1ff5ce0cf9a7faa097" name="a7640d35fa5798e1ff5ce0cf9a7faa097"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7640d35fa5798e1ff5ce0cf9a7faa097">&#9670;&#160;</a></span>call_in_callback_cb_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt;<a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> (int delay_ms, <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt;void()&gt; user_cb)&gt; <a class="el" href="class_network_stack.html#a7640d35fa5798e1ff5ce0cf9a7faa097">call_in_callback_cb_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type for a call-in callback. </p>
<p >This is a pointer to a function that will call the provided callback from the network stack after a given delay, or immediately if <code>delay_ms</code> is 0. </p>

<p class="definition">Definition at line <a class="el" href="_network_stack_8h_source.html#l00235">235</a> of file <a class="el" href="_network_stack_8h_source.html">NetworkStack.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a2ab48210e24fc7efb4e1cada14c4b57b" name="a2ab48210e24fc7efb4e1cada14c4b57b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ab48210e24fc7efb4e1cada14c4b57b">&#9670;&#160;</a></span>get_ip_address()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> get_ip_address </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_socket_address.html">SocketAddress</a> *&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the local IP address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td><a class="el" href="class_socket_address.html" title="SocketAddress class.">SocketAddress</a> representation of the local IP address </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NSAPI_ERROR_OK</td><td>on success </td></tr>
    <tr><td class="paramname">NSAPI_ERROR_UNSUPPORTED</td><td>if this feature is not supported </td></tr>
    <tr><td class="paramname">NSAPI_ERROR_PARAMETER</td><td>if the provided pointer is invalid </td></tr>
    <tr><td class="paramname">NSAPI_ERROR_NO_ADDRESS</td><td>if the address cannot be obtained from stack </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classmbed_1_1_a_t___cellular_stack.html#a2ab48210e24fc7efb4e1cada14c4b57b">AT_CellularStack</a>, <a class="el" href="classmbed_1_1_q_u_e_c_t_e_l___b_g96___cellular_stack.html#a2ab48210e24fc7efb4e1cada14c4b57b">QUECTEL_BG96_CellularStack</a>, <a class="el" href="classmbed_1_1_u_b_l_o_x___a_t___cellular_stack.html#a2ab48210e24fc7efb4e1cada14c4b57b">UBLOX_AT_CellularStack</a>, and <a class="el" href="class_nanostack.html#a839e3aefbadd82c35902dd53ef5a21fa">Nanostack</a>.</p>

</div>
</div>
<a id="a77de8d1afa4b83dd6f560dc39251e1eb" name="a77de8d1afa4b83dd6f560dc39251e1eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77de8d1afa4b83dd6f560dc39251e1eb">&#9670;&#160;</a></span>get_ipv6_link_local_address()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> get_ipv6_link_local_address </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_socket_address.html">SocketAddress</a> *&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the IPv6 link local address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td><a class="el" href="class_socket_address.html" title="SocketAddress class.">SocketAddress</a> representation of the link local IPv6 address </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NSAPI_ERROR_OK</td><td>on success </td></tr>
    <tr><td class="paramname">NSAPI_ERROR_UNSUPPORTED</td><td>if this feature is not supported </td></tr>
    <tr><td class="paramname">NSAPI_ERROR_PARAMETER</td><td>if the provided pointer is invalid </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad597f0496e42b17be72d00fa832e0963" name="ad597f0496e42b17be72d00fa832e0963"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad597f0496e42b17be72d00fa832e0963">&#9670;&#160;</a></span>get_ip_address_if()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> get_ip_address_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_socket_address.html">SocketAddress</a> *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>interface_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the local IP address on interface name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td><a class="el" href="class_socket_address.html" title="SocketAddress class.">SocketAddress</a> representation of the link local IPv6 address </td></tr>
    <tr><td class="paramname">interface_name</td><td>Network interface_name </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NSAPI_ERROR_OK</td><td>on success </td></tr>
    <tr><td class="paramname">NSAPI_ERROR_UNSUPPORTED</td><td>if this feature is not supported </td></tr>
    <tr><td class="paramname">NSAPI_ERROR_PARAMETER</td><td>if the provided pointer is invalid </td></tr>
    <tr><td class="paramname">NSAPI_ERROR_NO_ADDRESS</td><td>if the address cannot be obtained from stack </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5eeb3e01ec53546b61fd7b823a4980ef" name="a5eeb3e01ec53546b61fd7b823a4980ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eeb3e01ec53546b61fd7b823a4980ef">&#9670;&#160;</a></span>gethostbyname()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> gethostbyname </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_socket_address.html">SocketAddress</a> *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nsapi_version_t&#160;</td>
          <td class="paramname"><em>version</em> = <code><a class="el" href="group___net_socket.html#ggacde826f51019112728ee4ae4e10b8a4fa09ed8714a685448ae2e149c4a142ffe7">NSAPI_UNSPEC</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>interface_name</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Translates a hostname to an IP address with specific version. </p>
<p >The hostname may be either a domain name or an IP address. If the hostname is an IP address, no network transactions will be performed.</p>
<p >If no stack-specific <a class="el" href="class_d_n_s.html" title="Base class for DNS provider.">DNS</a> resolution is provided, the hostname will be resolve using a UDP socket on the stack.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>Hostname to resolve </td></tr>
    <tr><td class="paramname">address</td><td>Pointer to a <a class="el" href="class_socket_address.html" title="SocketAddress class.">SocketAddress</a> to store the result. </td></tr>
    <tr><td class="paramname">version</td><td>IP version of address to resolve, NSAPI_UNSPEC indicates version is chosen by the stack (defaults to NSAPI_UNSPEC) </td></tr>
    <tr><td class="paramname">interface_name</td><td>Network interface_name </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NSAPI_ERROR_OK</td><td>on success </td></tr>
    <tr><td class="paramname">NSAPI_ERROR_PARAMETER</td><td>if invalid (null) name is provided </td></tr>
    <tr><td class="paramname">NSAPI_ERROR_DNS_FAILURE</td><td>if <a class="el" href="class_d_n_s.html" title="Base class for DNS provider.">DNS</a> resolution fails </td></tr>
    <tr><td class="paramname">int</td><td>other negative errors, see <a class="el" href="group___net_socket.html#ga3b2c4e56b8617f6c04860d627a7896a9">nsapi_dns_query</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_d_n_s.html#ae247aa841e5b519a5e47305ee00bacd2">DNS</a>.</p>

<p>Reimplemented in <a class="el" href="class_nanostack.html#acdc95fb930de625b8f727680c3476d43">Nanostack</a>, <a class="el" href="classmbed_1_1_r_m1000___a_t___cellular_stack.html#a5eeb3e01ec53546b61fd7b823a4980ef">RM1000_AT_CellularStack</a>, and <a class="el" href="classmbed_1_1_u_b_l_o_x___a_t___cellular_stack.html#a5eeb3e01ec53546b61fd7b823a4980ef">UBLOX_AT_CellularStack</a>.</p>

</div>
</div>
<a id="a87a975b9ef736cef63334895c5770660" name="a87a975b9ef736cef63334895c5770660"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87a975b9ef736cef63334895c5770660">&#9670;&#160;</a></span>getaddrinfo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga4dc6e8ec26b364f135278917c3f27c6e">nsapi_value_or_error_t</a> getaddrinfo </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>hostname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_socket_address.html">SocketAddress</a> *&#160;</td>
          <td class="paramname"><em>hints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_socket_address.html">SocketAddress</a> **&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>interface_name</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Translate a hostname to the multiple IP addresses with specific version using network interface name. </p>
<p >The hostname may be either a domain name or an IP address. If the hostname is an IP address, no network transactions will be performed.</p>
<p >If no stack-specific <a class="el" href="class_d_n_s.html" title="Base class for DNS provider.">DNS</a> resolution is provided, the hostname will be resolve using a UDP socket on the stack.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hostname</td><td>Hostname to resolve. </td></tr>
    <tr><td class="paramname">hints</td><td>Pointer to a <a class="el" href="class_socket_address.html" title="SocketAddress class.">SocketAddress</a> with query parameters. </td></tr>
    <tr><td class="paramname">res</td><td>Pointer to a <a class="el" href="class_socket_address.html" title="SocketAddress class.">SocketAddress</a> array to store the result.. </td></tr>
    <tr><td class="paramname">interface_name</td><td>Network interface name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of results on success, negative error code on failure. </dd></dl>

<p>Implements <a class="el" href="class_d_n_s.html#a4e2299044fa2bbb37717a7661bb608f7">DNS</a>.</p>

</div>
</div>
<a id="ab43b64cae1f145615db7f697d34552d7" name="ab43b64cae1f145615db7f697d34552d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab43b64cae1f145615db7f697d34552d7">&#9670;&#160;</a></span>gethostbyname_async()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga4dc6e8ec26b364f135278917c3f27c6e">nsapi_value_or_error_t</a> gethostbyname_async </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmbed_1_1_callback.html">hostbyname_cb_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nsapi_version_t&#160;</td>
          <td class="paramname"><em>version</em> = <code><a class="el" href="group___net_socket.html#ggacde826f51019112728ee4ae4e10b8a4fa09ed8714a685448ae2e149c4a142ffe7">NSAPI_UNSPEC</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>interface_name</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Translates a hostname to multiple IP addresses (asynchronous) </p>
<p >The hostname may be either a domain name or an IP address. If the hostname is an IP address, no network transactions will be performed.</p>
<p >If no stack-specific <a class="el" href="class_d_n_s.html" title="Base class for DNS provider.">DNS</a> resolution is provided, the hostname will be resolve using a UDP socket on the stack.</p>
<p >Call is non-blocking. Result of the <a class="el" href="class_d_n_s.html" title="Base class for DNS provider.">DNS</a> operation is returned by the callback. If this function returns failure, callback will not be called. In case result is success (IP address was found from <a class="el" href="class_d_n_s.html" title="Base class for DNS provider.">DNS</a> cache), callback will be called before function returns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>Hostname to resolve </td></tr>
    <tr><td class="paramname">callback</td><td>Callback that is called for result </td></tr>
    <tr><td class="paramname">version</td><td>IP version of address to resolve, NSAPI_UNSPEC indicates version is chosen by the stack (defaults to NSAPI_UNSPEC) </td></tr>
    <tr><td class="paramname">interface_name</td><td>Network interface_name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on immediate success, negative error code on immediate failure or a positive unique id that represents the hostname translation operation and can be passed to cancel </dd></dl>

<p>Implements <a class="el" href="class_d_n_s.html#aede5e7d96c7b2141f60a9fefec11e462">DNS</a>.</p>

<p>Reimplemented in <a class="el" href="class_nanostack.html#ab738a37df7a1cec6fba88e6b9c45dde1">Nanostack</a>.</p>

</div>
</div>
<a id="aa964732e6c585b596adc760fe95f40f5" name="aa964732e6c585b596adc760fe95f40f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa964732e6c585b596adc760fe95f40f5">&#9670;&#160;</a></span>getaddrinfo_async()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga4dc6e8ec26b364f135278917c3f27c6e">nsapi_value_or_error_t</a> getaddrinfo_async </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>hostname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_socket_address.html">SocketAddress</a> *&#160;</td>
          <td class="paramname"><em>hints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmbed_1_1_callback.html">hostbyname_cb_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>interface_name</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Translates a hostname to the multiple IP addresses (asynchronous) </p>
<p >The hostname may be either a domain name or an IP address. If the hostname is an IP address, no network transactions will be performed.</p>
<p >If no stack-specific <a class="el" href="class_d_n_s.html" title="Base class for DNS provider.">DNS</a> resolution is provided, the hostname will be resolve using a UDP socket on the stack.</p>
<p >The call is non-blocking. Result of the <a class="el" href="class_d_n_s.html" title="Base class for DNS provider.">DNS</a> operation is returned by the callback. If this function returns failure, callback will not be called. In case that IP addresses are found from <a class="el" href="class_d_n_s.html" title="Base class for DNS provider.">DNS</a> cache, callback will be called before function returns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hostname</td><td>Hostname to resolve </td></tr>
    <tr><td class="paramname">hints</td><td>Pointer to a <a class="el" href="class_socket_address.html" title="SocketAddress class.">SocketAddress</a> with query parameters. </td></tr>
    <tr><td class="paramname">callback</td><td>Callback that is called for result </td></tr>
    <tr><td class="paramname">interface_name</td><td>Network interface_name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on immediate success, negative error code on immediate failure or a positive unique id that represents the hostname translation operation and can be passed to cancel </dd></dl>

<p>Implements <a class="el" href="class_d_n_s.html#afd29392442faa47f202cd69ede31dd03">DNS</a>.</p>

</div>
</div>
<a id="a26000e958701f5b35886fac1757c0bf4" name="a26000e958701f5b35886fac1757c0bf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26000e958701f5b35886fac1757c0bf4">&#9670;&#160;</a></span>gethostbyname_async_cancel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> gethostbyname_async_cancel </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cancels asynchronous hostname translation. </p>
<p >When translation is cancelled, callback will not be called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Unique id of the hostname translation operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NSAPI_ERROR_OK on success, negative error code on failure </dd></dl>

<p>Implements <a class="el" href="class_d_n_s.html#a3ba06c19476ec03988c7cd7807823d63">DNS</a>.</p>

</div>
</div>
<a id="adbf8dbcd865fee3ebef07fefbea802a7" name="adbf8dbcd865fee3ebef07fefbea802a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbf8dbcd865fee3ebef07fefbea802a7">&#9670;&#160;</a></span>add_dns_server()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> add_dns_server </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_socket_address.html">SocketAddress</a> &amp;&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>interface_name</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a domain name server to list of servers to query. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>Destination for the host address </td></tr>
    <tr><td class="paramname">interface_name</td><td>Network interface name. Currently unused, the server is added for all interfaces. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NSAPI_ERROR_OK on success, negative error code on failure </dd></dl>

<p>Implements <a class="el" href="class_d_n_s.html#ad222683619bf0a9e32e0499e25cd3a98">DNS</a>.</p>

</div>
</div>
<a id="a0ccb0f7a5af95e76d0dea335ab866047" name="a0ccb0f7a5af95e76d0dea335ab866047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ccb0f7a5af95e76d0dea335ab866047">&#9670;&#160;</a></span>get_dns_server()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> get_dns_server </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_socket_address.html">SocketAddress</a> *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>interface_name</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a domain name server from a list of servers to query. </p>
<p >Returns a <a class="el" href="class_d_n_s.html" title="Base class for DNS provider.">DNS</a> server address for a index. If returns error no more <a class="el" href="class_d_n_s.html" title="Base class for DNS provider.">DNS</a> servers to read.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index of the <a class="el" href="class_d_n_s.html" title="Base class for DNS provider.">DNS</a> server, starts from zero </td></tr>
    <tr><td class="paramname">address</td><td>Destination for the host address </td></tr>
    <tr><td class="paramname">interface_name</td><td>Network interface name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NSAPI_ERROR_OK on success, negative error code on failure </dd></dl>

<p>Reimplemented in <a class="el" href="class_nanostack.html#a2d043b7dbb9ec7bcb1f21dccff63d04f">Nanostack</a>.</p>

</div>
</div>
<a id="aa5f46dd32614b93bc8a9d41b822a7ab7" name="aa5f46dd32614b93bc8a9d41b822a7ab7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5f46dd32614b93bc8a9d41b822a7ab7">&#9670;&#160;</a></span>onboardNetworkStack()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_onboard_network_stack.html">OnboardNetworkStack</a> * onboardNetworkStack </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dynamic downcast to a <a class="el" href="class_onboard_network_stack.html" title="mbed OS API for onboard IP stack abstraction">OnboardNetworkStack</a>. </p>

<p>Reimplemented in <a class="el" href="class_onboard_network_stack.html#a320ba06d48aa2401a4e62d69b79297ba">OnboardNetworkStack</a>.</p>

<p class="definition">Definition at line <a class="el" href="_network_stack_8h_source.html#l00225">225</a> of file <a class="el" href="_network_stack_8h_source.html">NetworkStack.h</a>.</p>

</div>
</div>
<a id="a917003ace34919b35f8e1dced0b52a05" name="a917003ace34919b35f8e1dced0b52a05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a917003ace34919b35f8e1dced0b52a05">&#9670;&#160;</a></span>socket_open()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> socket_open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___net_socket.html#gad0273762e5e5643dda87a74c7de45b69">nsapi_socket_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nsapi_protocol_t&#160;</td>
          <td class="paramname"><em>proto</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Opens a socket. </p>
<p >Creates a network socket and stores it in the specified handle. The handle must be passed to following calls on the socket.</p>
<p >A stack may have a finite number of sockets, in this case NSAPI_ERROR_NO_SOCKET is returned if no socket is available.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Destination for the handle to a newly created socket </td></tr>
    <tr><td class="paramname">proto</td><td>Protocol of socket to open, NSAPI_TCP or NSAPI_UDP </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NSAPI_ERROR_OK on success, negative error code on failure </dd></dl>

<p>Implemented in <a class="el" href="classmbed_1_1_a_t___cellular_stack.html#ab8764dd88c43681da5580c4594744182">AT_CellularStack</a>, and <a class="el" href="class_nanostack.html#adb28d1dbec5bd932b9eaae360d6da91b">Nanostack</a>.</p>

</div>
</div>
<a id="a519c5ecb722a17ea2acafad17f9386a3" name="a519c5ecb722a17ea2acafad17f9386a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a519c5ecb722a17ea2acafad17f9386a3">&#9670;&#160;</a></span>socket_close()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> socket_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___net_socket.html#gad0273762e5e5643dda87a74c7de45b69">nsapi_socket_t</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Close the socket. </p>
<p >Closes any open connection and deallocates any memory associated with the socket.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td><a class="el" href="class_socket.html" title="Socket interface.">Socket</a> handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NSAPI_ERROR_OK on success, negative error code on failure </dd></dl>

<p>Implemented in <a class="el" href="classmbed_1_1_a_t___cellular_stack.html#ac9afb2c8c08cc2bfda295cbee6dbbaa9">AT_CellularStack</a>, and <a class="el" href="class_nanostack.html#aba6b0a7fc6f7f0a6b79c89c93e9e3bf3">Nanostack</a>.</p>

</div>
</div>
<a id="ac92c15ee2f3ef7e26cb881393559d1ff" name="ac92c15ee2f3ef7e26cb881393559d1ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac92c15ee2f3ef7e26cb881393559d1ff">&#9670;&#160;</a></span>socket_bind()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> socket_bind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___net_socket.html#gad0273762e5e5643dda87a74c7de45b69">nsapi_socket_t</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_socket_address.html">SocketAddress</a> &amp;&#160;</td>
          <td class="paramname"><em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind a specific address to a socket. </p>
<p >Binding a socket specifies the address and port on which to receive data. If the IP address is zeroed, only the port is bound.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td><a class="el" href="class_socket.html" title="Socket interface.">Socket</a> handle </td></tr>
    <tr><td class="paramname">address</td><td>Local address to bind </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NSAPI_ERROR_OK on success, negative error code on failure. </dd></dl>

<p>Implemented in <a class="el" href="classmbed_1_1_a_t___cellular_stack.html#a0f8eff9d8ce0563b212d1206d09dbb0d">AT_CellularStack</a>, <a class="el" href="classmbed_1_1_q_u_e_c_t_e_l___m26___cellular_stack.html#a0f8eff9d8ce0563b212d1206d09dbb0d">QUECTEL_M26_CellularStack</a>, and <a class="el" href="class_nanostack.html#a23709b7e5fcaf12b6a74de0f2cab9986">Nanostack</a>.</p>

</div>
</div>
<a id="a45a50de4d7a421ac592f7effa7765639" name="a45a50de4d7a421ac592f7effa7765639"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45a50de4d7a421ac592f7effa7765639">&#9670;&#160;</a></span>socket_listen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> socket_listen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___net_socket.html#gad0273762e5e5643dda87a74c7de45b69">nsapi_socket_t</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>backlog</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Listen for connections on a TCP socket. </p>
<p >Marks the socket as a passive socket that can be used to accept incoming connections.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td><a class="el" href="class_socket.html" title="Socket interface.">Socket</a> handle </td></tr>
    <tr><td class="paramname">backlog</td><td>Number of pending connections that can be queued simultaneously </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NSAPI_ERROR_OK on success, negative error code on failure </dd></dl>

<p>Implemented in <a class="el" href="classmbed_1_1_a_t___cellular_stack.html#a6e54a554bb1b0341b9482dbd993e5f86">AT_CellularStack</a>, <a class="el" href="classmbed_1_1_q_u_e_c_t_e_l___b_c95___cellular_stack.html#a6e54a554bb1b0341b9482dbd993e5f86">QUECTEL_BC95_CellularStack</a>, <a class="el" href="classmbed_1_1_q_u_e_c_t_e_l___b_g96___cellular_stack.html#a6e54a554bb1b0341b9482dbd993e5f86">QUECTEL_BG96_CellularStack</a>, <a class="el" href="classmbed_1_1_q_u_e_c_t_e_l___m26___cellular_stack.html#a6e54a554bb1b0341b9482dbd993e5f86">QUECTEL_M26_CellularStack</a>, <a class="el" href="classmbed_1_1_r_m1000___a_t___cellular_stack.html#a6e54a554bb1b0341b9482dbd993e5f86">RM1000_AT_CellularStack</a>, <a class="el" href="classmbed_1_1_t_e_l_i_t___m_e310___cellular_stack.html#a6e54a554bb1b0341b9482dbd993e5f86">TELIT_ME310_CellularStack</a>, <a class="el" href="classmbed_1_1_u_b_l_o_x___a_t___cellular_stack.html#a6e54a554bb1b0341b9482dbd993e5f86">UBLOX_AT_CellularStack</a>, <a class="el" href="classmbed_1_1_u_b_l_o_x___n2_x_x___cellular_stack.html#a6e54a554bb1b0341b9482dbd993e5f86">UBLOX_N2XX_CellularStack</a>, and <a class="el" href="class_nanostack.html#a90e1932e34889754ddb018166054e3c4">Nanostack</a>.</p>

</div>
</div>
<a id="ad584c350cb47627892fd2783e4c0c88a" name="ad584c350cb47627892fd2783e4c0c88a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad584c350cb47627892fd2783e4c0c88a">&#9670;&#160;</a></span>socket_connect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> socket_connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___net_socket.html#gad0273762e5e5643dda87a74c7de45b69">nsapi_socket_t</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_socket_address.html">SocketAddress</a> &amp;&#160;</td>
          <td class="paramname"><em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Connects TCP socket to a remote host. </p>
<p >Initiates a connection to a remote server specified by the indicated address.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td><a class="el" href="class_socket.html" title="Socket interface.">Socket</a> handle </td></tr>
    <tr><td class="paramname">address</td><td>The <a class="el" href="class_socket_address.html" title="SocketAddress class.">SocketAddress</a> of the remote host </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NSAPI_ERROR_OK on success, negative error code on failure </dd></dl>

<p>Implemented in <a class="el" href="classmbed_1_1_a_t___cellular_stack.html#a32a16282892785c939e9c6914718ab75">AT_CellularStack</a>, <a class="el" href="classmbed_1_1_g_e_m_a_l_t_o___c_i_n_t_e_r_i_o_n___cellular_stack.html#a32a16282892785c939e9c6914718ab75">GEMALTO_CINTERION_CellularStack</a>, <a class="el" href="classmbed_1_1_q_u_e_c_t_e_l___b_c95___cellular_stack.html#a32a16282892785c939e9c6914718ab75">QUECTEL_BC95_CellularStack</a>, <a class="el" href="classmbed_1_1_q_u_e_c_t_e_l___b_g96___cellular_stack.html#a32a16282892785c939e9c6914718ab75">QUECTEL_BG96_CellularStack</a>, <a class="el" href="classmbed_1_1_q_u_e_c_t_e_l___m26___cellular_stack.html#a32a16282892785c939e9c6914718ab75">QUECTEL_M26_CellularStack</a>, <a class="el" href="classmbed_1_1_r_m1000___a_t___cellular_stack.html#a32a16282892785c939e9c6914718ab75">RM1000_AT_CellularStack</a>, <a class="el" href="classmbed_1_1_t_e_l_i_t___m_e310___cellular_stack.html#a32a16282892785c939e9c6914718ab75">TELIT_ME310_CellularStack</a>, <a class="el" href="classmbed_1_1_u_b_l_o_x___a_t___cellular_stack.html#a32a16282892785c939e9c6914718ab75">UBLOX_AT_CellularStack</a>, and <a class="el" href="class_nanostack.html#a8b14e3ba4378d810612622483c194ad2">Nanostack</a>.</p>

</div>
</div>
<a id="aa497dbf81d1e9844f7c73ea44a9b6e54" name="aa497dbf81d1e9844f7c73ea44a9b6e54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa497dbf81d1e9844f7c73ea44a9b6e54">&#9670;&#160;</a></span>socket_accept()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> socket_accept </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___net_socket.html#gad0273762e5e5643dda87a74c7de45b69">nsapi_socket_t</a>&#160;</td>
          <td class="paramname"><em>server</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___net_socket.html#gad0273762e5e5643dda87a74c7de45b69">nsapi_socket_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_socket_address.html">SocketAddress</a> *&#160;</td>
          <td class="paramname"><em>address</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accepts a connection on a TCP socket. </p>
<p >The server socket must be bound and set to listen for connections. On a new connection, creates a network socket and stores it in the specified handle. The handle must be passed to following calls on the socket.</p>
<p >A stack may have a finite number of sockets, in this case NSAPI_ERROR_NO_SOCKET is returned if no socket is available.</p>
<p >This call is non-blocking. If accept would block, NSAPI_ERROR_WOULD_BLOCK is returned immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">server</td><td><a class="el" href="class_socket.html" title="Socket interface.">Socket</a> handle to server to accept from </td></tr>
    <tr><td class="paramname">handle</td><td>Destination for a handle to the newly created socket </td></tr>
    <tr><td class="paramname">address</td><td>Destination for the remote address or NULL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NSAPI_ERROR_OK on success, negative error code on failure </dd></dl>

<p>Implemented in <a class="el" href="classmbed_1_1_a_t___cellular_stack.html#a718744f981e91aabfc0e206a7563621f">AT_CellularStack</a>, <a class="el" href="classmbed_1_1_q_u_e_c_t_e_l___b_c95___cellular_stack.html#a718744f981e91aabfc0e206a7563621f">QUECTEL_BC95_CellularStack</a>, <a class="el" href="classmbed_1_1_q_u_e_c_t_e_l___b_g96___cellular_stack.html#a718744f981e91aabfc0e206a7563621f">QUECTEL_BG96_CellularStack</a>, <a class="el" href="classmbed_1_1_q_u_e_c_t_e_l___m26___cellular_stack.html#a718744f981e91aabfc0e206a7563621f">QUECTEL_M26_CellularStack</a>, <a class="el" href="classmbed_1_1_r_m1000___a_t___cellular_stack.html#a718744f981e91aabfc0e206a7563621f">RM1000_AT_CellularStack</a>, <a class="el" href="classmbed_1_1_t_e_l_i_t___m_e310___cellular_stack.html#a718744f981e91aabfc0e206a7563621f">TELIT_ME310_CellularStack</a>, <a class="el" href="classmbed_1_1_u_b_l_o_x___a_t___cellular_stack.html#a718744f981e91aabfc0e206a7563621f">UBLOX_AT_CellularStack</a>, <a class="el" href="classmbed_1_1_u_b_l_o_x___n2_x_x___cellular_stack.html#a718744f981e91aabfc0e206a7563621f">UBLOX_N2XX_CellularStack</a>, and <a class="el" href="class_nanostack.html#ab9d7af8652bf95bb3a99cbd988a60f02">Nanostack</a>.</p>

</div>
</div>
<a id="a70b5c1fd2bc705be0cc7651532008b8a" name="a70b5c1fd2bc705be0cc7651532008b8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70b5c1fd2bc705be0cc7651532008b8a">&#9670;&#160;</a></span>socket_send()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga1aef0d1a2599df92bb4499b5c4262d25">nsapi_size_or_error_t</a> socket_send </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___net_socket.html#gad0273762e5e5643dda87a74c7de45b69">nsapi_socket_t</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___net_socket.html#gaeaef3ae1ffcf0d50c66fa2ca37621281">nsapi_size_t</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send data over a TCP socket. </p>
<p >The socket must be connected to a remote host. Returns the number of bytes sent from the buffer.</p>
<p >This call is non-blocking. If send would block, NSAPI_ERROR_WOULD_BLOCK is returned immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td><a class="el" href="class_socket.html" title="Socket interface.">Socket</a> handle </td></tr>
    <tr><td class="paramname">data</td><td>Buffer of data to send to the host </td></tr>
    <tr><td class="paramname">size</td><td>Size of the buffer in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of sent bytes on success, negative error code on failure </dd></dl>

<p>Implemented in <a class="el" href="classmbed_1_1_a_t___cellular_stack.html#af715b34a97a4bfb91b3694d308cdfd71">AT_CellularStack</a>, and <a class="el" href="class_nanostack.html#a9e66843535784598a3fa76105801e77f">Nanostack</a>.</p>

</div>
</div>
<a id="a178a8c725d8f646ff6b26b381d2ac2c6" name="a178a8c725d8f646ff6b26b381d2ac2c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a178a8c725d8f646ff6b26b381d2ac2c6">&#9670;&#160;</a></span>socket_recv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga1aef0d1a2599df92bb4499b5c4262d25">nsapi_size_or_error_t</a> socket_recv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___net_socket.html#gad0273762e5e5643dda87a74c7de45b69">nsapi_socket_t</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___net_socket.html#gaeaef3ae1ffcf0d50c66fa2ca37621281">nsapi_size_t</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Receive data over a TCP socket. </p>
<p >The socket must be connected to a remote host. Returns the number of bytes received into the buffer.</p>
<p >This call is non-blocking. If recv would block, NSAPI_ERROR_WOULD_BLOCK is returned immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td><a class="el" href="class_socket.html" title="Socket interface.">Socket</a> handle </td></tr>
    <tr><td class="paramname">data</td><td>Destination buffer for data received from the host </td></tr>
    <tr><td class="paramname">size</td><td>Size of the buffer in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of received bytes on success, negative error code on failure </dd></dl>

<p>Implemented in <a class="el" href="classmbed_1_1_a_t___cellular_stack.html#abadfc103bba741fc2a9b403aa9f58985">AT_CellularStack</a>, and <a class="el" href="class_nanostack.html#aed43f4c030344db652e7821fd0fff994">Nanostack</a>.</p>

</div>
</div>
<a id="a75c6134df4d9116db6d9354c000bc354" name="a75c6134df4d9116db6d9354c000bc354"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75c6134df4d9116db6d9354c000bc354">&#9670;&#160;</a></span>socket_sendto()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga1aef0d1a2599df92bb4499b5c4262d25">nsapi_size_or_error_t</a> socket_sendto </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___net_socket.html#gad0273762e5e5643dda87a74c7de45b69">nsapi_socket_t</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_socket_address.html">SocketAddress</a> &amp;&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___net_socket.html#gaeaef3ae1ffcf0d50c66fa2ca37621281">nsapi_size_t</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send a packet over a UDP socket. </p>
<p >Sends data to the specified address. Returns the number of bytes sent from the buffer.</p>
<p >This call is non-blocking. If sendto would block, NSAPI_ERROR_WOULD_BLOCK is returned immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td><a class="el" href="class_socket.html" title="Socket interface.">Socket</a> handle </td></tr>
    <tr><td class="paramname">address</td><td>The <a class="el" href="class_socket_address.html" title="SocketAddress class.">SocketAddress</a> of the remote host </td></tr>
    <tr><td class="paramname">data</td><td>Buffer of data to send to the host </td></tr>
    <tr><td class="paramname">size</td><td>Size of the buffer in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of sent bytes on success, negative error code on failure </dd></dl>

<p>Implemented in <a class="el" href="classmbed_1_1_a_t___cellular_stack.html#a6b32b9bfc80dcd9a9108b5913ba0ac3a">AT_CellularStack</a>, and <a class="el" href="class_nanostack.html#aceb411cbca87cde852280cb94a982f73">Nanostack</a>.</p>

</div>
</div>
<a id="a33819f2c330cad315163b285e28371e0" name="a33819f2c330cad315163b285e28371e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33819f2c330cad315163b285e28371e0">&#9670;&#160;</a></span>socket_recvfrom()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga1aef0d1a2599df92bb4499b5c4262d25">nsapi_size_or_error_t</a> socket_recvfrom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___net_socket.html#gad0273762e5e5643dda87a74c7de45b69">nsapi_socket_t</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_socket_address.html">SocketAddress</a> *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___net_socket.html#gaeaef3ae1ffcf0d50c66fa2ca37621281">nsapi_size_t</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Receive a packet over a UDP socket. </p>
<p >Receives data and stores the source address in address if address is not NULL. Returns the number of bytes received into the buffer.</p>
<p >This call is non-blocking. If recvfrom would block, NSAPI_ERROR_WOULD_BLOCK is returned immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td><a class="el" href="class_socket.html" title="Socket interface.">Socket</a> handle </td></tr>
    <tr><td class="paramname">address</td><td>Destination for the source address or NULL </td></tr>
    <tr><td class="paramname">buffer</td><td>Destination buffer for data received from the host </td></tr>
    <tr><td class="paramname">size</td><td>Size of the buffer in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of received bytes on success, negative error code on failure </dd></dl>

<p>Implemented in <a class="el" href="classmbed_1_1_a_t___cellular_stack.html#a83fe036e785a5410bd4ed24b9c7a2399">AT_CellularStack</a>, and <a class="el" href="class_nanostack.html#a264b90bbb8fd5b6a5ac0c93ea5617453">Nanostack</a>.</p>

</div>
</div>
<a id="aa6e5ab3271a4df6347b400bd7e16fdc0" name="aa6e5ab3271a4df6347b400bd7e16fdc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6e5ab3271a4df6347b400bd7e16fdc0">&#9670;&#160;</a></span>socket_sendto_control()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga1aef0d1a2599df92bb4499b5c4262d25">nsapi_size_or_error_t</a> socket_sendto_control </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___net_socket.html#gad0273762e5e5643dda87a74c7de45b69">nsapi_socket_t</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_socket_address.html">SocketAddress</a> &amp;&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___net_socket.html#gaeaef3ae1ffcf0d50c66fa2ca37621281">nsapi_size_t</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___net_socket.html#gad737df4845d4a53ab1bf720f73572a7e">nsapi_msghdr_t</a> *&#160;</td>
          <td class="paramname"><em>control</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___net_socket.html#gaeaef3ae1ffcf0d50c66fa2ca37621281">nsapi_size_t</a>&#160;</td>
          <td class="paramname"><em>control_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send a packet with ancillary data over a UDP socket. </p>
<p >Sends data to the specified address. Returns the number of bytes sent from the buffer.</p>
<p >This call is non-blocking. If sendto would block, NSAPI_ERROR_WOULD_BLOCK is returned immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td><a class="el" href="class_socket.html" title="Socket interface.">Socket</a> handle </td></tr>
    <tr><td class="paramname">address</td><td>The <a class="el" href="class_socket_address.html" title="SocketAddress class.">SocketAddress</a> of the remote host </td></tr>
    <tr><td class="paramname">data</td><td>Buffer of data to send to the host </td></tr>
    <tr><td class="paramname">size</td><td>Size of the buffer in bytes </td></tr>
    <tr><td class="paramname">control</td><td>Storage for ancillary data </td></tr>
    <tr><td class="paramname">control_size</td><td>Size of ancillary data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of sent bytes on success, negative error code on failure </dd></dl>

<p class="definition">Definition at line <a class="el" href="_network_stack_8h_source.html#l00408">408</a> of file <a class="el" href="_network_stack_8h_source.html">NetworkStack.h</a>.</p>

</div>
</div>
<a id="a345f6e49fcae39c08ca892e2d1b6337b" name="a345f6e49fcae39c08ca892e2d1b6337b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a345f6e49fcae39c08ca892e2d1b6337b">&#9670;&#160;</a></span>socket_recvfrom_control()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga1aef0d1a2599df92bb4499b5c4262d25">nsapi_size_or_error_t</a> socket_recvfrom_control </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___net_socket.html#gad0273762e5e5643dda87a74c7de45b69">nsapi_socket_t</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_socket_address.html">SocketAddress</a> *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___net_socket.html#gaeaef3ae1ffcf0d50c66fa2ca37621281">nsapi_size_t</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___net_socket.html#gad737df4845d4a53ab1bf720f73572a7e">nsapi_msghdr_t</a> *&#160;</td>
          <td class="paramname"><em>control</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___net_socket.html#gaeaef3ae1ffcf0d50c66fa2ca37621281">nsapi_size_t</a>&#160;</td>
          <td class="paramname"><em>control_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Receive a packet with ancillary data over a UDP socket. </p>
<p >Receives data and stores the source address in address if address is not NULL. Returns the number of bytes received into the buffer.</p>
<p >Ancillary data is stored into <code>control</code>. The caller needs to allocate a buffer that is large enough to contain the data they want to receive, then pass the pointer in through the <code>control</code> member. The data will be filled into <code>control</code>, beginning with a header specifying what data was received. See <a class="el" href="struct_msg_header_iterator.html" title="Allows iteration through the list of message headers received in the control parameter of the socket_...">MsgHeaderIterator</a> for how to parse this data.</p>
<p >This call is non-blocking. If recvfrom would block, NSAPI_ERROR_WOULD_BLOCK is returned immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td><a class="el" href="class_socket.html" title="Socket interface.">Socket</a> handle </td></tr>
    <tr><td class="paramname">address</td><td>Destination for the source address or NULL </td></tr>
    <tr><td class="paramname">data</td><td>Destination buffer for data received from the host </td></tr>
    <tr><td class="paramname">size</td><td>Size of the buffer in bytes </td></tr>
    <tr><td class="paramname">control</td><td>Storage for ancillary data </td></tr>
    <tr><td class="paramname">control_size</td><td>Size of ancillary data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of received bytes on success, negative error code on failure </dd></dl>

<p class="definition">Definition at line <a class="el" href="_network_stack_8h_source.html#l00441">441</a> of file <a class="el" href="_network_stack_8h_source.html">NetworkStack.h</a>.</p>

</div>
</div>
<a id="a836e3ddbc6fea2ce55bfcb477f56387c" name="a836e3ddbc6fea2ce55bfcb477f56387c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a836e3ddbc6fea2ce55bfcb477f56387c">&#9670;&#160;</a></span>socket_attach()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void socket_attach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___net_socket.html#gad0273762e5e5643dda87a74c7de45b69">nsapi_socket_t</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register a callback on state change of the socket. </p>
<p >The specified callback will be called on state changes such as when the socket can recv/send/accept successfully and on when an error occurs. The callback may also be called spuriously without reason.</p>
<p >The callback may be called in an interrupt context and should not perform expensive operations such as recv/send calls.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td><a class="el" href="class_socket.html" title="Socket interface.">Socket</a> handle </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call on state change </td></tr>
    <tr><td class="paramname">data</td><td>Argument to pass to callback </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classmbed_1_1_a_t___cellular_stack.html#a70610f8436bc26b2df666dda0b5af80b">AT_CellularStack</a>, and <a class="el" href="class_nanostack.html#aa39dc687ca69ce33807642fee47e7db8">Nanostack</a>.</p>

</div>
</div>
<a id="aac9e14a8be89337c5aea17fd705c3f46" name="aac9e14a8be89337c5aea17fd705c3f46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac9e14a8be89337c5aea17fd705c3f46">&#9670;&#160;</a></span>setsockopt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> setsockopt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___net_socket.html#gad0273762e5e5643dda87a74c7de45b69">nsapi_socket_t</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>optval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>optlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set stack-specific socket options. </p>
<p >The setsockopt allow an application to pass stack-specific hints to the underlying stack. For unsupported options, NSAPI_ERROR_UNSUPPORTED is returned and the socket is unmodified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td><a class="el" href="class_socket.html" title="Socket interface.">Socket</a> handle. </td></tr>
    <tr><td class="paramname">level</td><td>Stack-specific protocol level. </td></tr>
    <tr><td class="paramname">optname</td><td>Stack-specific option identifier. </td></tr>
    <tr><td class="paramname">optval</td><td>Option value. </td></tr>
    <tr><td class="paramname">optlen</td><td>Length of the option value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NSAPI_ERROR_OK on success, negative error code on failure. </dd></dl>

<p>Reimplemented in <a class="el" href="class_nanostack.html#a45cb37f5bbe111d0e64a45d9bb1204cc">Nanostack</a>.</p>

</div>
</div>
<a id="add47ee70f334bcabd0df63f116143311" name="add47ee70f334bcabd0df63f116143311"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add47ee70f334bcabd0df63f116143311">&#9670;&#160;</a></span>getsockopt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group___net_socket.html#ga67a8f07758d2ee2a1809293fa52bdf14">nsapi_error_t</a> getsockopt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___net_socket.html#gad0273762e5e5643dda87a74c7de45b69">nsapi_socket_t</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>optval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>optlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get stack-specific socket options. </p>
<p >The getstackopt allow an application to retrieve stack-specific hints from the underlying stack. For unsupported options, NSAPI_ERROR_UNSUPPORTED is returned and optval is unmodified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td><a class="el" href="class_socket.html" title="Socket interface.">Socket</a> handle. </td></tr>
    <tr><td class="paramname">level</td><td>Stack-specific protocol level. </td></tr>
    <tr><td class="paramname">optname</td><td>Stack-specific option identifier. </td></tr>
    <tr><td class="paramname">optval</td><td>Destination for option value. </td></tr>
    <tr><td class="paramname">optlen</td><td>Length of the option value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NSAPI_ERROR_OK on success, negative error code on failure. </dd></dl>

<p>Reimplemented in <a class="el" href="class_nanostack.html#a324213e6725ac48b2842bcdcce383022">Nanostack</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_network_stack.html">NetworkStack</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>

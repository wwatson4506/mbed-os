<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Mbed OS Reference: ConditionVariable Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="mbed-ce_55x55.png"/></td>
  <td id="projectalign">
   <div id="projectname">Mbed OS Reference
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classrtos_1_1_condition_variable.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle"><div class="title">ConditionVariable Class Reference<div class="ingroups"><a class="el" href="group__mbed-os-public.html">Public API</a> &raquo; <a class="el" href="group__rtos-public-api.html">RTOS</a> &raquo; <a class="el" href="group__rtos___condition_variable.html">ConditionVariable class</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="classrtos_1_1_condition_variable.html" title="The ConditionVariable class is a synchronization primitive that allows threads to wait until a partic...">ConditionVariable</a> class is a synchronization primitive that allows threads to wait until a particular condition occurs.  
 <a href="classrtos_1_1_condition_variable.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_condition_variable_8h_source.html">ConditionVariable.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ConditionVariable:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classrtos_1_1_condition_variable.png" usemap="#ConditionVariable_map" alt=""/>
  <map id="ConditionVariable_map" name="ConditionVariable_map">
<area href="classmbed_1_1_non_copyable.html" alt="NonCopyable&lt; ConditionVariable &gt;" shape="rect" coords="0,0,214,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7ee4f4dcb1cef7f40d618efa3f5324fb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrtos_1_1_condition_variable.html#a7ee4f4dcb1cef7f40d618efa3f5324fb">ConditionVariable</a> (<a class="el" href="classrtos_1_1_mutex.html">Mutex</a> &amp;mutex)</td></tr>
<tr class="memdesc:a7ee4f4dcb1cef7f40d618efa3f5324fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create and initialize a <a class="el" href="classrtos_1_1_condition_variable.html" title="The ConditionVariable class is a synchronization primitive that allows threads to wait until a partic...">ConditionVariable</a> object.  <a href="classrtos_1_1_condition_variable.html#a7ee4f4dcb1cef7f40d618efa3f5324fb">More...</a><br /></td></tr>
<tr class="separator:a7ee4f4dcb1cef7f40d618efa3f5324fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3b21853f890838c88d047d6c2786917"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrtos_1_1_condition_variable.html#aa3b21853f890838c88d047d6c2786917">wait</a> ()</td></tr>
<tr class="memdesc:aa3b21853f890838c88d047d6c2786917"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for a notification.  <a href="classrtos_1_1_condition_variable.html#aa3b21853f890838c88d047d6c2786917">More...</a><br /></td></tr>
<tr class="separator:aa3b21853f890838c88d047d6c2786917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cf7dd6065a1139a3846645e09d2a1de"><td class="memTemplParams" colspan="2">template&lt;typename Predicate &gt; </td></tr>
<tr class="memitem:a5cf7dd6065a1139a3846645e09d2a1de"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrtos_1_1_condition_variable.html#a5cf7dd6065a1139a3846645e09d2a1de">wait</a> (Predicate pred)</td></tr>
<tr class="memdesc:a5cf7dd6065a1139a3846645e09d2a1de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for a predicate.  <a href="classrtos_1_1_condition_variable.html#a5cf7dd6065a1139a3846645e09d2a1de">More...</a><br /></td></tr>
<tr class="separator:a5cf7dd6065a1139a3846645e09d2a1de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae084b54ba5230e339c944faef3441930"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrtos_1_1_condition_variable.html#ae084b54ba5230e339c944faef3441930">wait_until</a> (uint64_t millisec)</td></tr>
<tr class="memdesc:ae084b54ba5230e339c944faef3441930"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for a notification until the specified time.  <a href="classrtos_1_1_condition_variable.html#ae084b54ba5230e339c944faef3441930">More...</a><br /></td></tr>
<tr class="separator:ae084b54ba5230e339c944faef3441930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6a2507757e7b46d4230ed53fe51578f"><td class="memItemLeft" align="right" valign="top">cv_status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrtos_1_1_condition_variable.html#ad6a2507757e7b46d4230ed53fe51578f">wait_until</a> (Kernel::Clock::time_point abs_time)</td></tr>
<tr class="memdesc:ad6a2507757e7b46d4230ed53fe51578f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for a notification until the specified time.  <a href="classrtos_1_1_condition_variable.html#ad6a2507757e7b46d4230ed53fe51578f">More...</a><br /></td></tr>
<tr class="separator:ad6a2507757e7b46d4230ed53fe51578f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3ffe9c3f4356f7d6a7369bb268b96b1"><td class="memTemplParams" colspan="2">template&lt;class Predicate &gt; </td></tr>
<tr class="memitem:ae3ffe9c3f4356f7d6a7369bb268b96b1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrtos_1_1_condition_variable.html#ae3ffe9c3f4356f7d6a7369bb268b96b1">wait_until</a> (Kernel::Clock::time_point abs_time, Predicate pred)</td></tr>
<tr class="memdesc:ae3ffe9c3f4356f7d6a7369bb268b96b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for a predicate until the specified time.  <a href="classrtos_1_1_condition_variable.html#ae3ffe9c3f4356f7d6a7369bb268b96b1">More...</a><br /></td></tr>
<tr class="separator:ae3ffe9c3f4356f7d6a7369bb268b96b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2de4c6d8577bfcd6900e545d9b305c85"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrtos_1_1_condition_variable.html#a2de4c6d8577bfcd6900e545d9b305c85">wait_for</a> (uint32_t millisec)</td></tr>
<tr class="memdesc:a2de4c6d8577bfcd6900e545d9b305c85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for a notification or timeout.  <a href="classrtos_1_1_condition_variable.html#a2de4c6d8577bfcd6900e545d9b305c85">More...</a><br /></td></tr>
<tr class="separator:a2de4c6d8577bfcd6900e545d9b305c85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05eede6489f4ecd963013b76ca8b3737"><td class="memItemLeft" align="right" valign="top">cv_status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrtos_1_1_condition_variable.html#a05eede6489f4ecd963013b76ca8b3737">wait_for</a> (Kernel::Clock::duration_u32 rel_time)</td></tr>
<tr class="memdesc:a05eede6489f4ecd963013b76ca8b3737"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for a notification or timeout.  <a href="classrtos_1_1_condition_variable.html#a05eede6489f4ecd963013b76ca8b3737">More...</a><br /></td></tr>
<tr class="separator:a05eede6489f4ecd963013b76ca8b3737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f041b42b9a59ab3bac3ca808138ca61"><td class="memTemplParams" colspan="2">template&lt;class Predicate &gt; </td></tr>
<tr class="memitem:a6f041b42b9a59ab3bac3ca808138ca61"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrtos_1_1_condition_variable.html#a6f041b42b9a59ab3bac3ca808138ca61">wait_for</a> (Kernel::Clock::duration rel_time, Predicate pred)</td></tr>
<tr class="memdesc:a6f041b42b9a59ab3bac3ca808138ca61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for a predicate or timeout.  <a href="classrtos_1_1_condition_variable.html#a6f041b42b9a59ab3bac3ca808138ca61">More...</a><br /></td></tr>
<tr class="separator:a6f041b42b9a59ab3bac3ca808138ca61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84c2ec0dd971c593883198a323eeb394"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrtos_1_1_condition_variable.html#a84c2ec0dd971c593883198a323eeb394">notify_one</a> ()</td></tr>
<tr class="memdesc:a84c2ec0dd971c593883198a323eeb394"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify one waiter on this condition variable that a condition changed.  <a href="classrtos_1_1_condition_variable.html#a84c2ec0dd971c593883198a323eeb394">More...</a><br /></td></tr>
<tr class="separator:a84c2ec0dd971c593883198a323eeb394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad35a04e61229c15c5211ebff00089326"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrtos_1_1_condition_variable.html#ad35a04e61229c15c5211ebff00089326">notify_all</a> ()</td></tr>
<tr class="memdesc:ad35a04e61229c15c5211ebff00089326"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify all waiters on this condition variable that a condition changed.  <a href="classrtos_1_1_condition_variable.html#ad35a04e61229c15c5211ebff00089326">More...</a><br /></td></tr>
<tr class="separator:ad35a04e61229c15c5211ebff00089326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06c2fc08612a8d85989d3538f6d5ac8f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrtos_1_1_condition_variable.html#a06c2fc08612a8d85989d3538f6d5ac8f">~ConditionVariable</a> ()</td></tr>
<tr class="memdesc:a06c2fc08612a8d85989d3538f6d5ac8f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classrtos_1_1_condition_variable.html" title="The ConditionVariable class is a synchronization primitive that allows threads to wait until a partic...">ConditionVariable</a> destructor.  <a href="classrtos_1_1_condition_variable.html#a06c2fc08612a8d85989d3538f6d5ac8f">More...</a><br /></td></tr>
<tr class="separator:a06c2fc08612a8d85989d3538f6d5ac8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >The <a class="el" href="classrtos_1_1_condition_variable.html" title="The ConditionVariable class is a synchronization primitive that allows threads to wait until a partic...">ConditionVariable</a> class is a synchronization primitive that allows threads to wait until a particular condition occurs. </p>
<p >Use the condition variable in conjunction with a mutex to safely wait for or notify waiters of condition changes to a resource accessible by multiple threads.</p>
<p >The thread that intends to wait on a <a class="el" href="classrtos_1_1_condition_variable.html" title="The ConditionVariable class is a synchronization primitive that allows threads to wait until a partic...">ConditionVariable</a> must:</p><ul>
<li>Acquire a lock on a mutex.</li>
<li>Execute <code>wait</code>, <code>wait_for</code> or <code>wait_until</code>. While the thread is waiting, the mutex is unlocked.</li>
<li>When the condition variable has been notified, or in the case of <code>wait_for</code> and <code>wait_until</code> the timeout expires, the thread is awakened.</li>
</ul>
<p >The thread that intends to notify a <a class="el" href="classrtos_1_1_condition_variable.html" title="The ConditionVariable class is a synchronization primitive that allows threads to wait until a partic...">ConditionVariable</a> must:</p><ul>
<li>Acquire a lock on the mutex used to construct the condition variable.</li>
<li>Execute <code>notify_one</code> or <code>notify_all</code> on the condition variable.</li>
</ul>
<p >All threads waiting on the condition variable wake when <code><a class="el" href="classrtos_1_1_condition_variable.html#ad35a04e61229c15c5211ebff00089326" title="Notify all waiters on this condition variable that a condition changed.">ConditionVariable::notify_all</a></code> is called. At least one thread waiting on the condition variable wakes when <code><a class="el" href="classrtos_1_1_condition_variable.html#a84c2ec0dd971c593883198a323eeb394" title="Notify one waiter on this condition variable that a condition changed.">ConditionVariable::notify_one</a></code> is called.</p>
<p >While a thread is waiting for notification of a <a class="el" href="classrtos_1_1_condition_variable.html" title="The ConditionVariable class is a synchronization primitive that allows threads to wait until a partic...">ConditionVariable</a>, it releases the lock held on the mutex. The <a class="el" href="classrtos_1_1_condition_variable.html" title="The ConditionVariable class is a synchronization primitive that allows threads to wait until a partic...">ConditionVariable</a> reacquires the mutex lock before exiting the wait function.</p>
<h4><a class="anchor" id="autotoc_md71"></a>
Unspecified behavior</h4>
<ul>
<li>The thread that is unblocked on <code><a class="el" href="classrtos_1_1_condition_variable.html#a84c2ec0dd971c593883198a323eeb394" title="Notify one waiter on this condition variable that a condition changed.">ConditionVariable::notify_one</a></code> is unspecified if there are multiple waiters.</li>
<li>When <code><a class="el" href="classrtos_1_1_condition_variable.html#a84c2ec0dd971c593883198a323eeb394" title="Notify one waiter on this condition variable that a condition changed.">ConditionVariable::notify_one</a></code> or <code><a class="el" href="classrtos_1_1_condition_variable.html#ad35a04e61229c15c5211ebff00089326" title="Notify all waiters on this condition variable that a condition changed.">ConditionVariable::notify_all</a></code> is called and there are one or more waiters, and one or more threads attempting to acquire the condition variable's mutex, the order in which the mutex is acquired is unspecified.</li>
<li>Spurious notifications (not triggered by the application) can occur.</li>
</ul>
<h4><a class="anchor" id="autotoc_md72"></a>
Undefined behavior</h4>
<ul>
<li>Calling wait if the mutex is not locked by the current thread is undefined behavior.</li>
<li>The order in which waiting threads acquire the condition variable's mutex after <code><a class="el" href="classrtos_1_1_condition_variable.html#ad35a04e61229c15c5211ebff00089326" title="Notify all waiters on this condition variable that a condition changed.">ConditionVariable::notify_all</a></code> is called is undefined.</li>
<li>The behavior of <code><a class="el" href="classrtos_1_1_condition_variable.html#aa3b21853f890838c88d047d6c2786917" title="Wait for a notification.">ConditionVariable::wait</a></code> and <code><a class="el" href="classrtos_1_1_condition_variable.html#a2de4c6d8577bfcd6900e545d9b305c85" title="Wait for a notification or timeout.">ConditionVariable::wait_for</a></code> is undefined if the condition variable's mutex is locked more than once by the calling thread.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Synchronization level: <a class="el" href="classrtos_1_1_thread.html" title="The Thread class allow defining, creating, and controlling thread functions in the system.">Thread</a> safe</dd>
<dd>
Bare metal profile: This class is not supported.</dd></dl>
<p>Example:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;mbed.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classrtos_1_1_mutex.html">Mutex</a> mutex;</div>
<div class="line"><a class="code hl_class" href="classrtos_1_1_condition_variable.html">ConditionVariable</a> cv(mutex);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// These variables are protected by locking the mutex.</span></div>
<div class="line">uint32_t work_count = 0;</div>
<div class="line"><span class="keywordtype">bool</span> done = <span class="keyword">false</span>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> worker_thread()</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// Acquire lock on mutex before accessing protected variables and waiting.</span></div>
<div class="line">  mutex.<a class="code hl_function" href="classrtos_1_1_mutex.html#aa81aed607133209dade63a226818224d">lock</a>();</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">while</span> (done == <span class="keyword">false</span>) {</div>
<div class="line">    printf(<span class="stringliteral">&quot;Worker thread: Count: %lu\r\n&quot;</span>, work_count);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Wait for main thread to notify the condition variable.</span></div>
<div class="line">    printf(<span class="stringliteral">&quot;Worker thread: Waiting\r\n&quot;</span>);</div>
<div class="line">    cv.wait();</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  printf(<span class="stringliteral">&quot;Worker: Exiting\r\n&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// The condition variable acquires the lock when exiting the `wait` function.</span></div>
<div class="line">  <span class="comment">// Unlock mutex when exiting the thread.</span></div>
<div class="line">  mutex.<a class="code hl_function" href="classrtos_1_1_mutex.html#a9278be8203e1c42e2619179882ae4403">unlock</a>();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">  Thread thread;</div>
<div class="line">  thread.start(worker_thread);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 5; i++) {</div>
<div class="line">    <span class="comment">// Acquire lock on mutex before modifying variables and notifying.</span></div>
<div class="line">    mutex.<a class="code hl_function" href="classrtos_1_1_mutex.html#aa81aed607133209dade63a226818224d">lock</a>();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Change count and notify waiters.</span></div>
<div class="line">    work_count++;</div>
<div class="line">    printf(<span class="stringliteral">&quot;Main thread: Set count to: %lu\r\n&quot;</span>, work_count);</div>
<div class="line">    printf(<span class="stringliteral">&quot;Main thread: Notifying worker thread\r\n&quot;</span>);</div>
<div class="line">    cv.notify_all();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Mutex must be unlocked before the worker thread can acquire it.</span></div>
<div class="line">    mutex.<a class="code hl_function" href="classrtos_1_1_mutex.html#a9278be8203e1c42e2619179882ae4403">unlock</a>();</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_function" href="group__rtos___this_thread.html#gac99d5c8a930be72c11b16bc1bef5a174">ThisThread::sleep_for</a>(1000);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Change done and notify waiters of this.</span></div>
<div class="line">  mutex.<a class="code hl_function" href="classrtos_1_1_mutex.html#aa81aed607133209dade63a226818224d">lock</a>();</div>
<div class="line">  done = <span class="keyword">true</span>;</div>
<div class="line">  cv.notify_all();</div>
<div class="line">  mutex.<a class="code hl_function" href="classrtos_1_1_mutex.html#a9278be8203e1c42e2619179882ae4403">unlock</a>();</div>
<div class="line"> </div>
<div class="line">  thread.join();</div>
<div class="line"> </div>
<div class="line">  printf(<span class="stringliteral">&quot;Main: Exiting\r\n&quot;</span>);</div>
<div class="line">}</div>
<div class="ttc" id="aclassrtos_1_1_condition_variable_html"><div class="ttname"><a href="classrtos_1_1_condition_variable.html">rtos::ConditionVariable</a></div><div class="ttdoc">The ConditionVariable class is a synchronization primitive that allows threads to wait until a partic...</div><div class="ttdef"><b>Definition:</b> <a href="_condition_variable_8h_source.html#l00168">ConditionVariable.h:168</a></div></div>
<div class="ttc" id="aclassrtos_1_1_mutex_html"><div class="ttname"><a href="classrtos_1_1_mutex.html">rtos::Mutex</a></div><div class="ttdoc">The Mutex class is used to synchronize the execution of threads.</div><div class="ttdef"><b>Definition:</b> <a href="_mutex_8h_source.html#l00070">Mutex.h:70</a></div></div>
<div class="ttc" id="aclassrtos_1_1_mutex_html_a9278be8203e1c42e2619179882ae4403"><div class="ttname"><a href="classrtos_1_1_mutex.html#a9278be8203e1c42e2619179882ae4403">rtos::Mutex::unlock</a></div><div class="ttdeci">void unlock()</div><div class="ttdoc">Unlock the mutex that has previously been locked by the same thread.</div></div>
<div class="ttc" id="aclassrtos_1_1_mutex_html_aa81aed607133209dade63a226818224d"><div class="ttname"><a href="classrtos_1_1_mutex.html#aa81aed607133209dade63a226818224d">rtos::Mutex::lock</a></div><div class="ttdeci">void lock()</div><div class="ttdoc">Wait until a Mutex becomes available.</div></div>
<div class="ttc" id="agroup__rtos___this_thread_html_gac99d5c8a930be72c11b16bc1bef5a174"><div class="ttname"><a href="group__rtos___this_thread.html#gac99d5c8a930be72c11b16bc1bef5a174">rtos::ThisThread::sleep_for</a></div><div class="ttdeci">void sleep_for(uint32_t millisec)</div><div class="ttdoc">Sleep for a specified time period in millisec:</div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="_condition_variable_8h_source.html#l00168">168</a> of file <a class="el" href="_condition_variable_8h_source.html">ConditionVariable.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a7ee4f4dcb1cef7f40d618efa3f5324fb" name="a7ee4f4dcb1cef7f40d618efa3f5324fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ee4f4dcb1cef7f40d618efa3f5324fb">&#9670;&#160;</a></span>ConditionVariable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrtos_1_1_condition_variable.html">ConditionVariable</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrtos_1_1_mutex.html">Mutex</a> &amp;&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create and initialize a <a class="el" href="classrtos_1_1_condition_variable.html" title="The ConditionVariable class is a synchronization primitive that allows threads to wait until a partic...">ConditionVariable</a> object. </p>
<dl class="section note"><dt>Note</dt><dd>You cannot call this function from ISR context. </dd></dl>

</div>
</div>
<a id="a06c2fc08612a8d85989d3538f6d5ac8f" name="a06c2fc08612a8d85989d3538f6d5ac8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06c2fc08612a8d85989d3538f6d5ac8f">&#9670;&#160;</a></span>~ConditionVariable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="classrtos_1_1_condition_variable.html">ConditionVariable</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classrtos_1_1_condition_variable.html" title="The ConditionVariable class is a synchronization primitive that allows threads to wait until a partic...">ConditionVariable</a> destructor. </p>
<dl class="section note"><dt>Note</dt><dd>You cannot call this function from ISR context. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa3b21853f890838c88d047d6c2786917" name="aa3b21853f890838c88d047d6c2786917"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3b21853f890838c88d047d6c2786917">&#9670;&#160;</a></span>wait() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wait </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for a notification. </p>
<p >Wait causes the current thread to block until the condition variable receives a notification from another thread.</p>
<dl class="section note"><dt>Note</dt><dd>- The thread calling this function must be the owner of the <a class="el" href="classrtos_1_1_condition_variable.html" title="The ConditionVariable class is a synchronization primitive that allows threads to wait until a partic...">ConditionVariable</a>'s mutex, and it must be locked exactly once.</dd>
<dd>
- Spurious notifications can occur, so the caller of this API should check to make sure the condition the caller is waiting on has been met.</dd>
<dd>
- The current thread releases the mutex while inside the wait function and reacquires it upon exiting the function.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line">mutex.lock();</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">while</span> (!condition_met) {</div>
<div class="line">    cond.wait();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">function_to_handle_condition();</div>
<div class="line"> </div>
<div class="line">mutex.unlock();</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>You cannot call this function from ISR context. </dd></dl>

</div>
</div>
<a id="a5cf7dd6065a1139a3846645e09d2a1de" name="a5cf7dd6065a1139a3846645e09d2a1de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cf7dd6065a1139a3846645e09d2a1de">&#9670;&#160;</a></span>wait() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wait </td>
          <td>(</td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for a predicate. </p>
<p >Wait causes the current thread to block until the predicate is true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pred</td><td>A function-like object such that <code>pred()</code> is convertible to bool</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>- The thread calling this function must be the owner of the <a class="el" href="classrtos_1_1_condition_variable.html" title="The ConditionVariable class is a synchronization primitive that allows threads to wait until a partic...">ConditionVariable</a>'s mutex, and it must be locked exactly once.</dd>
<dd>
- The current thread releases the mutex while inside the wait function and reacquires it upon exiting the function.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">extern</span> <span class="keywordtype">bool</span> data_available();</div>
<div class="line"> </div>
<div class="line">mutex.lock();</div>
<div class="line"> </div>
<div class="line">cond.wait(data_available);</div>
<div class="line"> </div>
<div class="line">function_to_handle_data();</div>
<div class="line"> </div>
<div class="line">mutex.unlock();</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>You cannot call this function from ISR context. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_condition_variable_8h_source.html#l00237">237</a> of file <a class="el" href="_condition_variable_8h_source.html">ConditionVariable.h</a>.</p>

</div>
</div>
<a id="ae084b54ba5230e339c944faef3441930" name="ae084b54ba5230e339c944faef3441930"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae084b54ba5230e339c944faef3441930">&#9670;&#160;</a></span>wait_until() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool wait_until </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>millisec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for a notification until the specified time. </p>
<p >Wait until causes the current thread to block until the condition variable is notified, or a specific time given by millisec parameter is reached.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">millisec</td><td>Absolute end time referenced to <code><a class="el" href="namespacertos_1_1_kernel.html#a5744e4ade0a4700887b7f390a530da02" title="Read the current RTOS kernel millisecond tick count.">Kernel::get_ms_count()</a></code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a timeout occurred, <code>false</code> otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>- The thread calling this function must be the owner of the <a class="el" href="classrtos_1_1_condition_variable.html" title="The ConditionVariable class is a synchronization primitive that allows threads to wait until a partic...">ConditionVariable</a>'s mutex, and it must be locked exactly once.</dd>
<dd>
- Spurious notifications can occur, so the caller of this API should check to make sure the condition the caller is waiting on has been met.</dd>
<dd>
- The current thread releases the lock while inside the wait function and reacquires it upon exiting the function.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line">mutex.lock();</div>
<div class="line">uint64_t end_time = <a class="code hl_function" href="namespacertos_1_1_kernel.html#a5744e4ade0a4700887b7f390a530da02">Kernel::get_ms_count</a>() + COND_WAIT_TIMEOUT;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">while</span> (!condition_met) {</div>
<div class="line">    <span class="keywordflow">if</span> (cond.wait_until(end_time)) {</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (condition_met) {</div>
<div class="line">    function_to_handle_condition();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">mutex.unlock();</div>
<div class="ttc" id="anamespacertos_1_1_kernel_html_a5744e4ade0a4700887b7f390a530da02"><div class="ttname"><a href="namespacertos_1_1_kernel.html#a5744e4ade0a4700887b7f390a530da02">rtos::Kernel::get_ms_count</a></div><div class="ttdeci">uint64_t get_ms_count()</div><div class="ttdoc">Read the current RTOS kernel millisecond tick count.</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>You cannot call this function from ISR context. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000082">Deprecated:</a></b></dt><dd>Pass a chrono time_point, not an integer millisecond count. For example use <code>Kernel::Clock::now() + 5s</code> rather than <code><a class="el" href="namespacertos_1_1_kernel.html#a5744e4ade0a4700887b7f390a530da02" title="Read the current RTOS kernel millisecond tick count.">Kernel::get_ms_count()</a> + 5000</code>. </dd></dl>

</div>
</div>
<a id="ad6a2507757e7b46d4230ed53fe51578f" name="ad6a2507757e7b46d4230ed53fe51578f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6a2507757e7b46d4230ed53fe51578f">&#9670;&#160;</a></span>wait_until() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cv_status wait_until </td>
          <td>(</td>
          <td class="paramtype">Kernel::Clock::time_point&#160;</td>
          <td class="paramname"><em>abs_time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for a notification until the specified time. </p>
<p >Wait until causes the current thread to block until the condition variable is notified, or a specific time given by millisec parameter is reached.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">abs_time</td><td>Absolute end time referenced to <code><a class="el" href="structrtos_1_1_kernel_1_1_clock.html" title="A C++11 chrono TrivialClock for the kernel millisecond tick count.">Kernel::Clock</a></code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>cv_status::timeout</code> if a timeout occurred, <code>cv_status::no_timeout</code> otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>- The thread calling this function must be the owner of the <a class="el" href="classrtos_1_1_condition_variable.html" title="The ConditionVariable class is a synchronization primitive that allows threads to wait until a partic...">ConditionVariable</a>'s mutex, and it must be locked exactly once.</dd>
<dd>
- Spurious notifications can occur, so the caller of this API should check to make sure the condition the caller is waiting on has been met.</dd>
<dd>
- The current thread releases the lock while inside the wait function and reacquires it upon exiting the function.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line">mutex.lock();</div>
<div class="line">Kernel::Clock::time_point end_time = Kernel::Clock::now() + 2s;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">while</span> (!condition_met) {</div>
<div class="line">    <span class="keywordflow">if</span> (cond.wait_until(end_time) == cv_status::timeout) {</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (condition_met) {</div>
<div class="line">    function_to_handle_condition();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">mutex.unlock();</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>You cannot call this function from ISR context. </dd></dl>

</div>
</div>
<a id="ae3ffe9c3f4356f7d6a7369bb268b96b1" name="ae3ffe9c3f4356f7d6a7369bb268b96b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3ffe9c3f4356f7d6a7369bb268b96b1">&#9670;&#160;</a></span>wait_until() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool wait_until </td>
          <td>(</td>
          <td class="paramtype">Kernel::Clock::time_point&#160;</td>
          <td class="paramname"><em>abs_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for a predicate until the specified time. </p>
<p >Wait until causes the current thread to block until the predicate is true, or a specific time given by abs_time parameter is reached.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">abs_time</td><td>Absolute end time referenced to <code><a class="el" href="structrtos_1_1_kernel_1_1_clock.html" title="A C++11 chrono TrivialClock for the kernel millisecond tick count.">Kernel::Clock</a></code> </td></tr>
    <tr><td class="paramname">pred</td><td>A function-like object such that <code>pred()</code> is convertible to bool </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The state of the predicate</dd></dl>
<dl class="section note"><dt>Note</dt><dd>- The thread calling this function must be the owner of the <a class="el" href="classrtos_1_1_condition_variable.html" title="The ConditionVariable class is a synchronization primitive that allows threads to wait until a partic...">ConditionVariable</a>'s mutex, and it must be locked exactly once.</dd>
<dd>
- The current thread releases the mutex while inside the wait function and reacquires it upon exiting the function.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">extern</span> <span class="keywordtype">bool</span> data_available();</div>
<div class="line"> </div>
<div class="line">mutex.lock();</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (cond.wait_until(Kernel::Clock::now() + 2s, data_available)) {</div>
<div class="line">    function_to_handle_data();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">mutex.unlock();</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>You cannot call this function from ISR context. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_condition_variable_8h_source.html#l00361">361</a> of file <a class="el" href="_condition_variable_8h_source.html">ConditionVariable.h</a>.</p>

</div>
</div>
<a id="a2de4c6d8577bfcd6900e545d9b305c85" name="a2de4c6d8577bfcd6900e545d9b305c85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2de4c6d8577bfcd6900e545d9b305c85">&#9670;&#160;</a></span>wait_for() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool wait_for </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>millisec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for a notification or timeout. </p>
<p ><code>Wait for</code> causes the current thread to block until the condition variable receives a notification from another thread, or the timeout specified by the millisec parameter is reached.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">millisec</td><td>Timeout value or osWaitForever in case of no timeout. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a timeout occurred, <code>false</code> otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>- The thread calling this function must be the owner of the <a class="el" href="classrtos_1_1_condition_variable.html" title="The ConditionVariable class is a synchronization primitive that allows threads to wait until a partic...">ConditionVariable</a>'s mutex, and it must be locked exactly once.</dd>
<dd>
- Spurious notifications can occur, so the caller of this API should check to make sure the condition the caller is waiting on has been met.</dd>
<dd>
- The current thread releases the lock while inside the wait function and reacquire it upon exiting the function.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line">mutex.lock();</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">while</span> (!condition_met) {</div>
<div class="line">    cond.wait_for(MAX_SLEEP_TIME);</div>
<div class="line">    <span class="keywordflow">if</span> (!condition_met) {</div>
<div class="line">        do_other_work_while_condition_false();</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (condition_met) {</div>
<div class="line">    function_to_handle_condition();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">mutex.unlock();</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>You cannot call this function from ISR context. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000083">Deprecated:</a></b></dt><dd>Pass a chrono duration, not an integer millisecond count. For example use <code>5s</code> rather than <code>5000</code>. </dd></dl>

</div>
</div>
<a id="a05eede6489f4ecd963013b76ca8b3737" name="a05eede6489f4ecd963013b76ca8b3737"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05eede6489f4ecd963013b76ca8b3737">&#9670;&#160;</a></span>wait_for() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cv_status wait_for </td>
          <td>(</td>
          <td class="paramtype">Kernel::Clock::duration_u32&#160;</td>
          <td class="paramname"><em>rel_time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for a notification or timeout. </p>
<p ><code>Wait for</code> causes the current thread to block until the condition variable receives a notification from another thread, or the timeout specified by the millisec parameter is reached.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rel_time</td><td>Timeout value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>cv_status::timeout</code> if a timeout occurred, <code>cv_status::no_timeout</code> otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>- The thread calling this function must be the owner of the <a class="el" href="classrtos_1_1_condition_variable.html" title="The ConditionVariable class is a synchronization primitive that allows threads to wait until a partic...">ConditionVariable</a>'s mutex, and it must be locked exactly once.</dd>
<dd>
- Spurious notifications can occur, so the caller of this API should check to make sure the condition the caller is waiting on has been met.</dd>
<dd>
- The current thread releases the lock while inside the wait function and reacquire it upon exiting the function.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line">mutex.lock();</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">while</span> (!condition_met) {</div>
<div class="line">    cond.wait_for(MAX_SLEEP_TIME);</div>
<div class="line">    <span class="keywordflow">if</span> (!condition_met) {</div>
<div class="line">        do_other_work_while_condition_false();</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (condition_met) {</div>
<div class="line">    function_to_handle_condition();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">mutex.unlock();</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>You cannot call this function from ISR context. </dd></dl>

</div>
</div>
<a id="a6f041b42b9a59ab3bac3ca808138ca61" name="a6f041b42b9a59ab3bac3ca808138ca61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f041b42b9a59ab3bac3ca808138ca61">&#9670;&#160;</a></span>wait_for() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool wait_for </td>
          <td>(</td>
          <td class="paramtype">Kernel::Clock::duration&#160;</td>
          <td class="paramname"><em>rel_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for a predicate or timeout. </p>
<p ><code>Wait for</code> causes the current thread to block until the predicate is true, or the timeout specified by the rel_time parameter is reached.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rel_time</td><td>Timeout value. </td></tr>
    <tr><td class="paramname">pred</td><td>a function-like object such that <code>pred()</code> is convertible to bool </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The state of the predicate</dd></dl>
<dl class="section note"><dt>Note</dt><dd>- The thread calling this function must be the owner of the <a class="el" href="classrtos_1_1_condition_variable.html" title="The ConditionVariable class is a synchronization primitive that allows threads to wait until a partic...">ConditionVariable</a>'s mutex, and it must be locked exactly once.</dd>
<dd>
- The current thread releases the mutex while inside the wait function and reacquire it upon exiting the function.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">extern</span> <span class="keywordtype">bool</span> data_available();</div>
<div class="line"> </div>
<div class="line">mutex.lock();</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (cond.wait_for(2s, data_available)) {</div>
<div class="line">    function_to_handle_data();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">mutex.unlock();</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>You cannot call this function from ISR context. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_condition_variable_8h_source.html#l00486">486</a> of file <a class="el" href="_condition_variable_8h_source.html">ConditionVariable.h</a>.</p>

</div>
</div>
<a id="a84c2ec0dd971c593883198a323eeb394" name="a84c2ec0dd971c593883198a323eeb394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84c2ec0dd971c593883198a323eeb394">&#9670;&#160;</a></span>notify_one()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void notify_one </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Notify one waiter on this condition variable that a condition changed. </p>
<p >This function unblocks one of the threads waiting for the condition variable.</p>
<dl class="section note"><dt>Note</dt><dd>- The thread calling this function must be the owner of the <a class="el" href="classrtos_1_1_condition_variable.html" title="The ConditionVariable class is a synchronization primitive that allows threads to wait until a partic...">ConditionVariable</a>'s mutex.</dd>
<dd>
- The thread that is unblocked on <a class="el" href="classrtos_1_1_condition_variable.html#a84c2ec0dd971c593883198a323eeb394" title="Notify one waiter on this condition variable that a condition changed.">ConditionVariable::notify_one</a> is undefined if there are multiple waiters.</dd>
<dd>
You cannot call this function from ISR context. </dd></dl>

</div>
</div>
<a id="ad35a04e61229c15c5211ebff00089326" name="ad35a04e61229c15c5211ebff00089326"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad35a04e61229c15c5211ebff00089326">&#9670;&#160;</a></span>notify_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void notify_all </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Notify all waiters on this condition variable that a condition changed. </p>
<p >This function unblocks all of the threads waiting for the condition variable.</p>
<dl class="section note"><dt>Note</dt><dd>- The thread calling this function must be the owner of the <a class="el" href="classrtos_1_1_condition_variable.html" title="The ConditionVariable class is a synchronization primitive that allows threads to wait until a partic...">ConditionVariable</a>'s mutex.</dd>
<dd>
- If there are one or more waiters and one or more threads attempting to acquire the condition variable's mutex the order in which the mutex is acquired is undefined.</dd>
<dd>
You cannot call this function from ISR context. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>rtos</b></li><li class="navelem"><a class="el" href="classrtos_1_1_condition_variable.html">ConditionVariable</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>

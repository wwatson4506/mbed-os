<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Mbed OS Reference: SPIMasterTester Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Mbed OS Reference
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('class_s_p_i_master_tester.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle"><div class="title">SPIMasterTester Class Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for SPIMasterTester:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_s_p_i_master_tester.png" usemap="#SPIMasterTester_map" alt=""/>
  <map id="SPIMasterTester_map" name="SPIMasterTester_map">
<area href="class_s_p_i_tester.html" alt="SPITester" shape="rect" coords="0,56,105,80"/>
<area href="class_mbed_tester.html" title="The base class for controlling the FPGA CI Test Shield." alt="MbedTester" shape="rect" coords="0,0,105,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ad91c9bfd2d0e98dcb4be89caa6e86f52"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mbed_tester.html#ad91c9bfd2d0e98dcb4be89caa6e86f52">PullMode</a> </td></tr>
<tr class="memdesc:ad91c9bfd2d0e98dcb4be89caa6e86f52"><td class="mdescLeft">&#160;</td><td class="mdescRight">FPGA Pullup mode.  <a href="class_mbed_tester.html#ad91c9bfd2d0e98dcb4be89caa6e86f52">More...</a><br /></td></tr>
<tr class="separator:ad91c9bfd2d0e98dcb4be89caa6e86f52"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1706ad3153de269c4be6898ab985168a"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_i_master_tester.html#a1706ad3153de269c4be6898ab985168a">get_transfer_count</a> ()</td></tr>
<tr class="memdesc:a1706ad3153de269c4be6898ab985168a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the number of transfers which have occurred.  <a href="class_s_p_i_master_tester.html#a1706ad3153de269c4be6898ab985168a">More...</a><br /></td></tr>
<tr class="separator:a1706ad3153de269c4be6898ab985168a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d038185c09c969ab5a7879c00d95f9c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_i_master_tester.html#a1d038185c09c969ab5a7879c00d95f9c">get_receive_checksum</a> ()</td></tr>
<tr class="memdesc:a1d038185c09c969ab5a7879c00d95f9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a checksum of data send to the tester.  <a href="class_s_p_i_master_tester.html#a1d038185c09c969ab5a7879c00d95f9c">More...</a><br /></td></tr>
<tr class="separator:a1d038185c09c969ab5a7879c00d95f9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7a48c0e0d5b1e2f60b7b197a5572099"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_i_master_tester.html#ad7a48c0e0d5b1e2f60b7b197a5572099">set_mode</a> (SpiMode mode)</td></tr>
<tr class="memdesc:ad7a48c0e0d5b1e2f60b7b197a5572099"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the clock mode of the spi_slave module.  <a href="class_s_p_i_master_tester.html#ad7a48c0e0d5b1e2f60b7b197a5572099">More...</a><br /></td></tr>
<tr class="separator:ad7a48c0e0d5b1e2f60b7b197a5572099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e5d7cc92ec95ce1ec3d434b6b4303b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_i_master_tester.html#a8e5d7cc92ec95ce1ec3d434b6b4303b7">set_bit_order</a> (SpiBitOrder bit_order)</td></tr>
<tr class="memdesc:a8e5d7cc92ec95ce1ec3d434b6b4303b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set bit order durring transmission of the spi_slave module.  <a href="class_s_p_i_master_tester.html#a8e5d7cc92ec95ce1ec3d434b6b4303b7">More...</a><br /></td></tr>
<tr class="separator:a8e5d7cc92ec95ce1ec3d434b6b4303b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae61d348f133e03c3a0330b8a79f5af2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_i_master_tester.html#aae61d348f133e03c3a0330b8a79f5af2">set_sym_size</a> (uint32_t sym_size)</td></tr>
<tr class="memdesc:aae61d348f133e03c3a0330b8a79f5af2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set symbol size used durring transmission of the spi_slave module.  <a href="class_s_p_i_master_tester.html#aae61d348f133e03c3a0330b8a79f5af2">More...</a><br /></td></tr>
<tr class="separator:aae61d348f133e03c3a0330b8a79f5af2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0ce7769e07314e4b86a13f5e383507b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_i_master_tester.html#ae0ce7769e07314e4b86a13f5e383507b">set_duplex_mode</a> (SpiDuplex duplex)</td></tr>
<tr class="memdesc:ae0ce7769e07314e4b86a13f5e383507b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set full-duplex/half-duplex transmission mode of the spi_slave module.  <a href="class_s_p_i_master_tester.html#ae0ce7769e07314e4b86a13f5e383507b">More...</a><br /></td></tr>
<tr class="separator:ae0ce7769e07314e4b86a13f5e383507b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2fba9756e2235ecf1be34be2ed73a77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_i_master_tester.html#ae2fba9756e2235ecf1be34be2ed73a77">set_hd_tx_rx_cnt</a> (uint16_t tx_cnt, uint16_t rx_cnt)</td></tr>
<tr class="memdesc:ae2fba9756e2235ecf1be34be2ed73a77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set tx/rx symbol count.  <a href="class_s_p_i_master_tester.html#ae2fba9756e2235ecf1be34be2ed73a77">More...</a><br /></td></tr>
<tr class="separator:ae2fba9756e2235ecf1be34be2ed73a77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5adc6d8fc646ebf3aad5b21f5a4d6f94"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_i_master_tester.html#a5adc6d8fc646ebf3aad5b21f5a4d6f94">get_cs_to_first_clk_edge_ns</a> ()</td></tr>
<tr class="memdesc:a5adc6d8fc646ebf3aad5b21f5a4d6f94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get nano seconds between chip select assertion and the first spi clock edge.  <a href="class_s_p_i_master_tester.html#a5adc6d8fc646ebf3aad5b21f5a4d6f94">More...</a><br /></td></tr>
<tr class="separator:a5adc6d8fc646ebf3aad5b21f5a4d6f94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35235530410c978466bf4781e38686da"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_i_master_tester.html#a35235530410c978466bf4781e38686da">get_last_clk_edge_to_cs_ns</a> ()</td></tr>
<tr class="memdesc:a35235530410c978466bf4781e38686da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get nano seconds between last spi clock edge and chip select de-assertion.  <a href="class_s_p_i_master_tester.html#a35235530410c978466bf4781e38686da">More...</a><br /></td></tr>
<tr class="separator:a35235530410c978466bf4781e38686da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a626ba9c3ff3e539b7fb3213fef3551a3"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_i_master_tester.html#a626ba9c3ff3e539b7fb3213fef3551a3">get_start_stop_stats</a> ()</td></tr>
<tr class="memdesc:a626ba9c3ff3e539b7fb3213fef3551a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get SCLK and SIN states on transmission start and stop.  <a href="class_s_p_i_master_tester.html#a626ba9c3ff3e539b7fb3213fef3551a3">More...</a><br /></td></tr>
<tr class="separator:a626ba9c3ff3e539b7fb3213fef3551a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac70d0289063e596b4e8ec6b1990d8bc1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mbed_tester.html#ac70d0289063e596b4e8ec6b1990d8bc1">set_control_pins_auto</a> ()</td></tr>
<tr class="memdesc:ac70d0289063e596b4e8ec6b1990d8bc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable automatic selection and update of control pins.  <a href="class_mbed_tester.html#ac70d0289063e596b4e8ec6b1990d8bc1">More...</a><br /></td></tr>
<tr class="separator:ac70d0289063e596b4e8ec6b1990d8bc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdb5133547384f59b7eba1043ecdcbec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mbed_tester.html#abdb5133547384f59b7eba1043ecdcbec">set_control_pins_manual</a> (PinName clk, PinName mosi, PinName miso, PinName aux)</td></tr>
<tr class="memdesc:abdb5133547384f59b7eba1043ecdcbec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the control pins to use for communication.  <a href="class_mbed_tester.html#abdb5133547384f59b7eba1043ecdcbec">More...</a><br /></td></tr>
<tr class="separator:abdb5133547384f59b7eba1043ecdcbec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae728defed648d72e61e42de80f6f1bdd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mbed_tester.html#ae728defed648d72e61e42de80f6f1bdd">firmware_dump</a> (<a class="el" href="classmbed_1_1_file_handle.html">mbed::FileHandle</a> *dest, <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; void(uint8_t)&gt; progress=<a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; void(uint8_t)&gt;())</td></tr>
<tr class="memdesc:ae728defed648d72e61e42de80f6f1bdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read FPGA CI Test Shield firmware.  <a href="class_mbed_tester.html#ae728defed648d72e61e42de80f6f1bdd">More...</a><br /></td></tr>
<tr class="separator:ae728defed648d72e61e42de80f6f1bdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1073a11b35157a6194311550d3fbe15"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mbed_tester.html#aa1073a11b35157a6194311550d3fbe15">firmware_dump_all</a> (<a class="el" href="classmbed_1_1_file_handle.html">mbed::FileHandle</a> *dest, <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; void(uint8_t)&gt; progress=<a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; void(uint8_t)&gt;())</td></tr>
<tr class="memdesc:aa1073a11b35157a6194311550d3fbe15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read FPGA CI Test Shield flash.  <a href="class_mbed_tester.html#aa1073a11b35157a6194311550d3fbe15">More...</a><br /></td></tr>
<tr class="separator:aa1073a11b35157a6194311550d3fbe15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa3dc94a89371462e855c8dfd85e8aec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mbed_tester.html#afa3dc94a89371462e855c8dfd85e8aec">firmware_update</a> (<a class="el" href="classmbed_1_1_file_handle.html">mbed::FileHandle</a> *src, <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; void(uint8_t)&gt; progress=<a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; void(uint8_t)&gt;())</td></tr>
<tr class="memdesc:afa3dc94a89371462e855c8dfd85e8aec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Program new FPGA CI Test Shield firmware.  <a href="class_mbed_tester.html#afa3dc94a89371462e855c8dfd85e8aec">More...</a><br /></td></tr>
<tr class="separator:afa3dc94a89371462e855c8dfd85e8aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89a38f832cf0df5ac4281114ce47fed1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mbed_tester.html#a89a38f832cf0df5ac4281114ce47fed1">pin_map_set</a> (PinName physical, LogicalPin logical)</td></tr>
<tr class="memdesc:a89a38f832cf0df5ac4281114ce47fed1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map a physical pin to the given logical pin.  <a href="class_mbed_tester.html#a89a38f832cf0df5ac4281114ce47fed1">More...</a><br /></td></tr>
<tr class="separator:a89a38f832cf0df5ac4281114ce47fed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c3097ebcd9371a45b18a3f8c1dabf85"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mbed_tester.html#a1c3097ebcd9371a45b18a3f8c1dabf85">pin_map_reset</a> ()</td></tr>
<tr class="memdesc:a1c3097ebcd9371a45b18a3f8c1dabf85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset all pin mappings.  <a href="class_mbed_tester.html#a1c3097ebcd9371a45b18a3f8c1dabf85">More...</a><br /></td></tr>
<tr class="separator:a1c3097ebcd9371a45b18a3f8c1dabf85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64ef1c1f3b9f27219fb0cf041865f1e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mbed_tester.html#a64ef1c1f3b9f27219fb0cf041865f1e3">peripherals_reset</a> ()</td></tr>
<tr class="memdesc:a64ef1c1f3b9f27219fb0cf041865f1e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset all peripherals.  <a href="class_mbed_tester.html#a64ef1c1f3b9f27219fb0cf041865f1e3">More...</a><br /></td></tr>
<tr class="separator:a64ef1c1f3b9f27219fb0cf041865f1e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad20897c5c8bd47f5d4005989bead0e55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mbed_tester.html#ad20897c5c8bd47f5d4005989bead0e55">reset</a> ()</td></tr>
<tr class="memdesc:ad20897c5c8bd47f5d4005989bead0e55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset everything.  <a href="class_mbed_tester.html#ad20897c5c8bd47f5d4005989bead0e55">More...</a><br /></td></tr>
<tr class="separator:ad20897c5c8bd47f5d4005989bead0e55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14db2eb3ee7c5c811b4d982d79aec8e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mbed_tester.html#a14db2eb3ee7c5c811b4d982d79aec8e0">reprogram</a> ()</td></tr>
<tr class="memdesc:a14db2eb3ee7c5c811b4d982d79aec8e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reprogram the FPGA.  <a href="class_mbed_tester.html#a14db2eb3ee7c5c811b4d982d79aec8e0">More...</a><br /></td></tr>
<tr class="separator:a14db2eb3ee7c5c811b4d982d79aec8e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cc07efe3a621a94b28f1d9bf7bff3cd"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mbed_tester.html#a1cc07efe3a621a94b28f1d9bf7bff3cd">version</a> ()</td></tr>
<tr class="memdesc:a1cc07efe3a621a94b28f1d9bf7bff3cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the running FPGA firmware version.  <a href="class_mbed_tester.html#a1cc07efe3a621a94b28f1d9bf7bff3cd">More...</a><br /></td></tr>
<tr class="separator:a1cc07efe3a621a94b28f1d9bf7bff3cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedf6f6c5852e8c5e4fd28da83834bc66"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mbed_tester.html#aedf6f6c5852e8c5e4fd28da83834bc66">select_peripheral</a> (Peripheral peripheral)</td></tr>
<tr class="memdesc:aedf6f6c5852e8c5e4fd28da83834bc66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select the currently active peripheral.  <a href="class_mbed_tester.html#aedf6f6c5852e8c5e4fd28da83834bc66">More...</a><br /></td></tr>
<tr class="separator:aedf6f6c5852e8c5e4fd28da83834bc66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40b8e1ca49ead640a37e985f618e5e05"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mbed_tester.html#a40b8e1ca49ead640a37e985f618e5e05">gpio_read</a> (LogicalPin gpio)</td></tr>
<tr class="memdesc:a40b8e1ca49ead640a37e985f618e5e05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a gpio pin.  <a href="class_mbed_tester.html#a40b8e1ca49ead640a37e985f618e5e05">More...</a><br /></td></tr>
<tr class="separator:a40b8e1ca49ead640a37e985f618e5e05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac295cbdf2256b829a8d0a91cddad16eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mbed_tester.html#ac295cbdf2256b829a8d0a91cddad16eb">gpio_write</a> (LogicalPin gpio, int value, bool drive)</td></tr>
<tr class="memdesc:ac295cbdf2256b829a8d0a91cddad16eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set value and drive of a gpio pin.  <a href="class_mbed_tester.html#ac295cbdf2256b829a8d0a91cddad16eb">More...</a><br /></td></tr>
<tr class="separator:ac295cbdf2256b829a8d0a91cddad16eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46de87c0fd447ce48a9153e4a4c989f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mbed_tester.html#a46de87c0fd447ce48a9153e4a4c989f2">io_metrics_start</a> ()</td></tr>
<tr class="memdesc:a46de87c0fd447ce48a9153e4a4c989f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start recording metrics on all logical pins.  <a href="class_mbed_tester.html#a46de87c0fd447ce48a9153e4a4c989f2">More...</a><br /></td></tr>
<tr class="separator:a46de87c0fd447ce48a9153e4a4c989f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6471bb52f4d357cd39614d910433f9a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mbed_tester.html#a6471bb52f4d357cd39614d910433f9a9">io_metrics_stop</a> ()</td></tr>
<tr class="memdesc:a6471bb52f4d357cd39614d910433f9a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop recording metrics on all logical pins.  <a href="class_mbed_tester.html#a6471bb52f4d357cd39614d910433f9a9">More...</a><br /></td></tr>
<tr class="separator:a6471bb52f4d357cd39614d910433f9a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5943471dd9ca342c70cf5b5106e9b32f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mbed_tester.html#a5943471dd9ca342c70cf5b5106e9b32f">io_metrics_continue</a> ()</td></tr>
<tr class="memdesc:a5943471dd9ca342c70cf5b5106e9b32f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Continue recording metrics on all logical pins.  <a href="class_mbed_tester.html#a5943471dd9ca342c70cf5b5106e9b32f">More...</a><br /></td></tr>
<tr class="separator:a5943471dd9ca342c70cf5b5106e9b32f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e85b38f8a2ff60e932404a1aca12746"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mbed_tester.html#a9e85b38f8a2ff60e932404a1aca12746">io_metrics_min_pulse_low</a> (LogicalPin pin)</td></tr>
<tr class="memdesc:a9e85b38f8a2ff60e932404a1aca12746"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the shortest low pulse recorded.  <a href="class_mbed_tester.html#a9e85b38f8a2ff60e932404a1aca12746">More...</a><br /></td></tr>
<tr class="separator:a9e85b38f8a2ff60e932404a1aca12746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a778de7d7f6b0c11d40026455431faf32"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mbed_tester.html#a778de7d7f6b0c11d40026455431faf32">io_metrics_min_pulse_high</a> (LogicalPin pin)</td></tr>
<tr class="memdesc:a778de7d7f6b0c11d40026455431faf32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the shortest high pulse recorded.  <a href="class_mbed_tester.html#a778de7d7f6b0c11d40026455431faf32">More...</a><br /></td></tr>
<tr class="separator:a778de7d7f6b0c11d40026455431faf32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99b0a6d20c97a2f16930506c18463169"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mbed_tester.html#a99b0a6d20c97a2f16930506c18463169">io_metrics_max_pulse_low</a> (LogicalPin pin)</td></tr>
<tr class="memdesc:a99b0a6d20c97a2f16930506c18463169"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the longest low pulse recorded.  <a href="class_mbed_tester.html#a99b0a6d20c97a2f16930506c18463169">More...</a><br /></td></tr>
<tr class="separator:a99b0a6d20c97a2f16930506c18463169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac560ef4377d8f8d72d2cee07bf7c4582"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mbed_tester.html#ac560ef4377d8f8d72d2cee07bf7c4582">io_metrics_max_pulse_high</a> (LogicalPin pin)</td></tr>
<tr class="memdesc:ac560ef4377d8f8d72d2cee07bf7c4582"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the longest high pulse recorded.  <a href="class_mbed_tester.html#ac560ef4377d8f8d72d2cee07bf7c4582">More...</a><br /></td></tr>
<tr class="separator:ac560ef4377d8f8d72d2cee07bf7c4582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a754d9ecc38b6bfbc80f892dbc2429378"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mbed_tester.html#a754d9ecc38b6bfbc80f892dbc2429378">io_metrics_rising_edges</a> (LogicalPin pin)</td></tr>
<tr class="memdesc:a754d9ecc38b6bfbc80f892dbc2429378"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of rising edges.  <a href="class_mbed_tester.html#a754d9ecc38b6bfbc80f892dbc2429378">More...</a><br /></td></tr>
<tr class="separator:a754d9ecc38b6bfbc80f892dbc2429378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affee4e3c418ed89b3541b90ff1ac9224"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mbed_tester.html#affee4e3c418ed89b3541b90ff1ac9224">io_metrics_falling_edges</a> (LogicalPin pin)</td></tr>
<tr class="memdesc:affee4e3c418ed89b3541b90ff1ac9224"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of falling edges.  <a href="class_mbed_tester.html#affee4e3c418ed89b3541b90ff1ac9224">More...</a><br /></td></tr>
<tr class="separator:affee4e3c418ed89b3541b90ff1ac9224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a899da77e493cc99e301faea15bfdb413"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mbed_tester.html#a899da77e493cc99e301faea15bfdb413">pin_pull_reset_all</a> ()</td></tr>
<tr class="memdesc:a899da77e493cc99e301faea15bfdb413"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the IO expander modules.  <a href="class_mbed_tester.html#a899da77e493cc99e301faea15bfdb413">More...</a><br /></td></tr>
<tr class="separator:a899da77e493cc99e301faea15bfdb413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21e16d04752892415a8279e099ea3333"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mbed_tester.html#a21e16d04752892415a8279e099ea3333">pin_set_pull</a> (PinName pin, <a class="el" href="class_mbed_tester.html#ad91c9bfd2d0e98dcb4be89caa6e86f52">PullMode</a> mode)</td></tr>
<tr class="memdesc:a21e16d04752892415a8279e099ea3333"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure an Mbed pin for a pulldown resistor, pullup resistor, or tristate mode via PinName.  <a href="class_mbed_tester.html#a21e16d04752892415a8279e099ea3333">More...</a><br /></td></tr>
<tr class="separator:a21e16d04752892415a8279e099ea3333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af559c95db92afa9f5fef01331f28e0d0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mbed_tester.html#af559c95db92afa9f5fef01331f28e0d0">pin_set_pull_index</a> (int index, <a class="el" href="class_mbed_tester.html#ad91c9bfd2d0e98dcb4be89caa6e86f52">PullMode</a> mode)</td></tr>
<tr class="memdesc:af559c95db92afa9f5fef01331f28e0d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure an Mbed pin for a pulldown resistor, pullup resistor, or tristate mode via pin index.  <a href="class_mbed_tester.html#af559c95db92afa9f5fef01331f28e0d0">More...</a><br /></td></tr>
<tr class="separator:af559c95db92afa9f5fef01331f28e0d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20378153c45434854ef0da0eac81f818"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mbed_tester.html#a20378153c45434854ef0da0eac81f818">io_expander_read</a> (PinName pin, IOExpanderReg reg_type)</td></tr>
<tr class="memdesc:a20378153c45434854ef0da0eac81f818"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a bit for a specific Mbed pin that is set in the input, output, or configuration registers inside of the IO expander via PinName.  <a href="class_mbed_tester.html#a20378153c45434854ef0da0eac81f818">More...</a><br /></td></tr>
<tr class="separator:a20378153c45434854ef0da0eac81f818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c7caf14d4d019023a81868cedb14a82"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mbed_tester.html#a5c7caf14d4d019023a81868cedb14a82">io_expander_read_index</a> (int index, IOExpanderReg reg_type)</td></tr>
<tr class="memdesc:a5c7caf14d4d019023a81868cedb14a82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a bit for a specific Mbed pin that is set in the input, output, or configuration registers inside of the IO expander via pin index.  <a href="class_mbed_tester.html#a5c7caf14d4d019023a81868cedb14a82">More...</a><br /></td></tr>
<tr class="separator:a5c7caf14d4d019023a81868cedb14a82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32f15d00dd9df5abadd596c6585a7438"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mbed_tester.html#a32f15d00dd9df5abadd596c6585a7438">pin_set_pull_bb</a> (PinName pin, <a class="el" href="class_mbed_tester.html#ad91c9bfd2d0e98dcb4be89caa6e86f52">PullMode</a> mode)</td></tr>
<tr class="memdesc:a32f15d00dd9df5abadd596c6585a7438"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure an Mbed pin for a pulldown resistor, pullup resistor, or tristate mode (this version of the function uses io_expander_i2c_read_bb and io_expander_i2c_write_bb)  <a href="class_mbed_tester.html#a32f15d00dd9df5abadd596c6585a7438">More...</a><br /></td></tr>
<tr class="separator:a32f15d00dd9df5abadd596c6585a7438"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1836957e22fa3cecbf0b7a2291690fcf"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mbed_tester.html#a1836957e22fa3cecbf0b7a2291690fcf">io_expander_read_bb</a> (PinName pin, IOExpanderReg reg_type)</td></tr>
<tr class="memdesc:a1836957e22fa3cecbf0b7a2291690fcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a bit for a specific Mbed pin that is set in the input, output, or configuration registers inside of the IO expander (this version of the function uses io_expander_i2c_read_bb)  <a href="class_mbed_tester.html#a1836957e22fa3cecbf0b7a2291690fcf">More...</a><br /></td></tr>
<tr class="separator:a1836957e22fa3cecbf0b7a2291690fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22a332ce0ca574f076bf174c5ae5cc18"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mbed_tester.html#a22a332ce0ca574f076bf174c5ae5cc18">set_analog_out</a> (bool enable, float voltage)</td></tr>
<tr class="memdesc:a22a332ce0ca574f076bf174c5ae5cc18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an analog voltage via the FPGA sys pwm in order to test Mbed AnalogIn.  <a href="class_mbed_tester.html#a22a332ce0ca574f076bf174c5ae5cc18">More...</a><br /></td></tr>
<tr class="separator:a22a332ce0ca574f076bf174c5ae5cc18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3119ad21d71329daa79cc15108fc2a8b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mbed_tester.html#a3119ad21d71329daa79cc15108fc2a8b">set_sample_adc</a> (bool val)</td></tr>
<tr class="memdesc:a3119ad21d71329daa79cc15108fc2a8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn the FPGA ADC on and off (power management data will be collected while the ADC is on)  <a href="class_mbed_tester.html#a3119ad21d71329daa79cc15108fc2a8b">More...</a><br /></td></tr>
<tr class="separator:a3119ad21d71329daa79cc15108fc2a8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaf36b5543f96a717246a28152e035f2"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mbed_tester.html#aaaf36b5543f96a717246a28152e035f2">get_analog_in</a> ()</td></tr>
<tr class="memdesc:aaaf36b5543f96a717246a28152e035f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the result of the analog to digital conversion computed on the FPGA in the form of a voltage reading.  <a href="class_mbed_tester.html#aaaf36b5543f96a717246a28152e035f2">More...</a><br /></td></tr>
<tr class="separator:aaaf36b5543f96a717246a28152e035f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa08bbf8a790e481242a75d2be0a967c0"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mbed_tester.html#aa08bbf8a790e481242a75d2be0a967c0">get_anin_voltage</a> (int index)</td></tr>
<tr class="memdesc:aa08bbf8a790e481242a75d2be0a967c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to 'get_analog_in' but returns a voltage reading from ANIN0-3.  <a href="class_mbed_tester.html#aa08bbf8a790e481242a75d2be0a967c0">More...</a><br /></td></tr>
<tr class="separator:aa08bbf8a790e481242a75d2be0a967c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a621924c294fd2aac4e6c5b3b72f1a708"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mbed_tester.html#a621924c294fd2aac4e6c5b3b72f1a708">sys_pin_read</a> (SystemPin pin)</td></tr>
<tr class="memdesc:a621924c294fd2aac4e6c5b3b72f1a708"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read from the given system pin.  <a href="class_mbed_tester.html#a621924c294fd2aac4e6c5b3b72f1a708">More...</a><br /></td></tr>
<tr class="separator:a621924c294fd2aac4e6c5b3b72f1a708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa599490906aed03297ecf9c8b3ed0bdb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mbed_tester.html#aa599490906aed03297ecf9c8b3ed0bdb">sys_pin_write</a> (SystemPin pin, int value, bool drive)</td></tr>
<tr class="memdesc:aa599490906aed03297ecf9c8b3ed0bdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write to the given system pin.  <a href="class_mbed_tester.html#aa599490906aed03297ecf9c8b3ed0bdb">More...</a><br /></td></tr>
<tr class="separator:aa599490906aed03297ecf9c8b3ed0bdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bb41a2bd89c8693a27b007af9f17636"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mbed_tester.html#a1bb41a2bd89c8693a27b007af9f17636">io_expander_i2c_read</a> (uint8_t i2c_index, uint8_t dev_addr, uint8_t start_reg, uint8_t *data, int length)</td></tr>
<tr class="memdesc:a1bb41a2bd89c8693a27b007af9f17636"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C read on I2C system channels 0, 1, or 2.  <a href="class_mbed_tester.html#a1bb41a2bd89c8693a27b007af9f17636">More...</a><br /></td></tr>
<tr class="separator:a1bb41a2bd89c8693a27b007af9f17636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad87a1861252adc575d7092c03756b81f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mbed_tester.html#ad87a1861252adc575d7092c03756b81f">io_expander_i2c_write</a> (uint8_t i2c_index, uint8_t dev_addr, uint8_t *data, int length)</td></tr>
<tr class="memdesc:ad87a1861252adc575d7092c03756b81f"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C write on I2C system channels 0, 1, or 2.  <a href="class_mbed_tester.html#ad87a1861252adc575d7092c03756b81f">More...</a><br /></td></tr>
<tr class="separator:ad87a1861252adc575d7092c03756b81f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9b1f8d9e819a7ecd25d818e41ded815"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mbed_tester.html#ac9b1f8d9e819a7ecd25d818e41ded815">io_expander_i2c_read_bb</a> (SystemPin sda, SystemPin scl, uint8_t dev_addr, uint8_t start_reg, uint8_t *data, int length)</td></tr>
<tr class="memdesc:ac9b1f8d9e819a7ecd25d818e41ded815"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C read on I2C system channels 0, 1, or 2 (bit banged version of function, bit banged over control channel)  <a href="class_mbed_tester.html#ac9b1f8d9e819a7ecd25d818e41ded815">More...</a><br /></td></tr>
<tr class="separator:ac9b1f8d9e819a7ecd25d818e41ded815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2def5404d53f8eef23f5222bc98fcf48"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mbed_tester.html#a2def5404d53f8eef23f5222bc98fcf48">io_expander_i2c_write_bb</a> (SystemPin sda, SystemPin scl, uint8_t dev_addr, uint8_t *data, int length)</td></tr>
<tr class="memdesc:a2def5404d53f8eef23f5222bc98fcf48"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C write on I2C system channels 0, 1, or 2 (bit banged version of function, bit banged over control channel)  <a href="class_mbed_tester.html#a2def5404d53f8eef23f5222bc98fcf48">More...</a><br /></td></tr>
<tr class="separator:a2def5404d53f8eef23f5222bc98fcf48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81fecd8c9c1d3ba88632cb734da43c2b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mbed_tester.html#a81fecd8c9c1d3ba88632cb734da43c2b">set_mux_addr</a> (PinName pin)</td></tr>
<tr class="memdesc:a81fecd8c9c1d3ba88632cb734da43c2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the AnalogMuxAddr pins on the FPGA via PinName.  <a href="class_mbed_tester.html#a81fecd8c9c1d3ba88632cb734da43c2b">More...</a><br /></td></tr>
<tr class="separator:a81fecd8c9c1d3ba88632cb734da43c2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad41919ba357ad8fdc04642489593c436"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mbed_tester.html#ad41919ba357ad8fdc04642489593c436">set_mux_addr_index</a> (int index)</td></tr>
<tr class="memdesc:ad41919ba357ad8fdc04642489593c436"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the AnalogMuxAddr pins on the FPGA via pin index.  <a href="class_mbed_tester.html#ad41919ba357ad8fdc04642489593c436">More...</a><br /></td></tr>
<tr class="separator:ad41919ba357ad8fdc04642489593c436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afee16bb712db65e27346730f8e6cd049"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mbed_tester.html#afee16bb712db65e27346730f8e6cd049">set_mux_enable</a> (bool val)</td></tr>
<tr class="memdesc:afee16bb712db65e27346730f8e6cd049"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn on/off the analog muxes.  <a href="class_mbed_tester.html#afee16bb712db65e27346730f8e6cd049">More...</a><br /></td></tr>
<tr class="separator:afee16bb712db65e27346730f8e6cd049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acefb87575238ed961edc561c5223c0ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mbed_tester.html#acefb87575238ed961edc561c5223c0ba">set_pwm_enable</a> (bool val)</td></tr>
<tr class="memdesc:acefb87575238ed961edc561c5223c0ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn on/off pwm output on FPGA to test Mbed AnalogIn.  <a href="class_mbed_tester.html#acefb87575238ed961edc561c5223c0ba">More...</a><br /></td></tr>
<tr class="separator:acefb87575238ed961edc561c5223c0ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d5d641201e78923e17b383817e856f8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mbed_tester.html#a5d5d641201e78923e17b383817e856f8">get_pwm_enable</a> ()</td></tr>
<tr class="memdesc:a5d5d641201e78923e17b383817e856f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if FPGA pwm out is on or off.  <a href="class_mbed_tester.html#a5d5d641201e78923e17b383817e856f8">More...</a><br /></td></tr>
<tr class="separator:a5d5d641201e78923e17b383817e856f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addafc573e0c82dae996f0322e2595f40"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mbed_tester.html#addafc573e0c82dae996f0322e2595f40">set_pwm_period_and_cycles_high</a> (uint32_t period, uint32_t cycles_high)</td></tr>
<tr class="memdesc:addafc573e0c82dae996f0322e2595f40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the pwm output period and number of cycles high (duty cycle) on the FPGA.  <a href="class_mbed_tester.html#addafc573e0c82dae996f0322e2595f40">More...</a><br /></td></tr>
<tr class="separator:addafc573e0c82dae996f0322e2595f40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52b4408dde26134ce0582c1d74ad350c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mbed_tester.html#a52b4408dde26134ce0582c1d74ad350c">get_pwm_period</a> ()</td></tr>
<tr class="memdesc:a52b4408dde26134ce0582c1d74ad350c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the pwm output period of the FPGA.  <a href="class_mbed_tester.html#a52b4408dde26134ce0582c1d74ad350c">More...</a><br /></td></tr>
<tr class="separator:a52b4408dde26134ce0582c1d74ad350c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19b675095afd0f1d3bd5cf1cd82e98ee"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mbed_tester.html#a19b675095afd0f1d3bd5cf1cd82e98ee">get_pwm_cycles_high</a> ()</td></tr>
<tr class="memdesc:a19b675095afd0f1d3bd5cf1cd82e98ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of cycles that are high (duty cycle) from FPGA pwm.  <a href="class_mbed_tester.html#a19b675095afd0f1d3bd5cf1cd82e98ee">More...</a><br /></td></tr>
<tr class="separator:a19b675095afd0f1d3bd5cf1cd82e98ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62d8618fe45a6c9ba4ce36ee47680338"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mbed_tester.html#a62d8618fe45a6c9ba4ce36ee47680338">get_analogmuxin_measurement</a> ()</td></tr>
<tr class="memdesc:a62d8618fe45a6c9ba4ce36ee47680338"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the 12-bit analog to digital conversion result from the FPGA.  <a href="class_mbed_tester.html#a62d8618fe45a6c9ba4ce36ee47680338">More...</a><br /></td></tr>
<tr class="separator:a62d8618fe45a6c9ba4ce36ee47680338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafbbbe691a8bee00c28953ba8ed11df1"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mbed_tester.html#aafbbbe691a8bee00c28953ba8ed11df1">get_anin_measurement</a> (int index)</td></tr>
<tr class="memdesc:aafbbbe691a8bee00c28953ba8ed11df1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to 'get_analogmuxin_measurement' but returns the current XADC measurement for ANIN0-3.  <a href="class_mbed_tester.html#aafbbbe691a8bee00c28953ba8ed11df1">More...</a><br /></td></tr>
<tr class="separator:aafbbbe691a8bee00c28953ba8ed11df1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7571005306ebc97908fa29a6bcf3b0ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mbed_tester.html#a7571005306ebc97908fa29a6bcf3b0ba">get_anin_sum_samples_cycles</a> (int index, uint64_t *sum, uint32_t *samples, uint64_t *cycles)</td></tr>
<tr class="memdesc:a7571005306ebc97908fa29a6bcf3b0ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets (by reference) the sum of all ANIN ADC results for any of the 4 ANIN pins specified by the index, number of ADC sample sequences that have completed since the XADC was turned on, and the number of FPGA clk cycles that have taken place since the ADC was turned on.  <a href="class_mbed_tester.html#a7571005306ebc97908fa29a6bcf3b0ba">More...</a><br /></td></tr>
<tr class="separator:a7571005306ebc97908fa29a6bcf3b0ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e458283e6ae7d99f8fb457ffadabf9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mbed_tester.html#ac2e458283e6ae7d99f8fb457ffadabf9">set_snapshot</a> ()</td></tr>
<tr class="memdesc:ac2e458283e6ae7d99f8fb457ffadabf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows safe reading of FPGA ADC related values while the FPGA ADC is on If snapshot is set then the ADC values will be safely latched in the FPGA and safe to read.  <a href="class_mbed_tester.html#ac2e458283e6ae7d99f8fb457ffadabf9">More...</a><br /></td></tr>
<tr class="separator:ac2e458283e6ae7d99f8fb457ffadabf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1429793080888c9e682898796646dbd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mbed_tester.html#ad1429793080888c9e682898796646dbd">sys_pin_mode_disabled</a> ()</td></tr>
<tr class="memdesc:ad1429793080888c9e682898796646dbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the current system pin mode to disabled.  <a href="class_mbed_tester.html#ad1429793080888c9e682898796646dbd">More...</a><br /></td></tr>
<tr class="separator:ad1429793080888c9e682898796646dbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8a72a1f632b1b053e3a4398688b6ad7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mbed_tester.html#ae8a72a1f632b1b053e3a4398688b6ad7">sys_pin_mode_spi_serial_flash</a> (PhysicalIndex mosi, PhysicalIndex miso, PhysicalIndex clk, PhysicalIndex ssel)</td></tr>
<tr class="memdesc:ae8a72a1f632b1b053e3a4398688b6ad7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the current system pin mode to serial flash.  <a href="class_mbed_tester.html#ae8a72a1f632b1b053e3a4398688b6ad7">More...</a><br /></td></tr>
<tr class="separator:ae8a72a1f632b1b053e3a4398688b6ad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20d0b2afb587422aadd59aa819398814"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mbed_tester.html#a20d0b2afb587422aadd59aa819398814">sys_pin_mode_i2c_io_expander</a> (int index, PhysicalIndex sda_in, PhysicalIndex sda_val, PhysicalIndex scl_in, PhysicalIndex scl_val)</td></tr>
<tr class="memdesc:a20d0b2afb587422aadd59aa819398814"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the current system pin mode to io expander I2C bus.  <a href="class_mbed_tester.html#a20d0b2afb587422aadd59aa819398814">More...</a><br /></td></tr>
<tr class="separator:a20d0b2afb587422aadd59aa819398814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35479ffc930d5153242802491c3bdf6b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mbed_tester.html#a35479ffc930d5153242802491c3bdf6b">pin_map_index</a> (PhysicalIndex physical_index, LogicalPin logical)</td></tr>
<tr class="memdesc:a35479ffc930d5153242802491c3bdf6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map a physical pin index to the given logical pin.  <a href="class_mbed_tester.html#a35479ffc930d5153242802491c3bdf6b">More...</a><br /></td></tr>
<tr class="separator:a35479ffc930d5153242802491c3bdf6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af71a5c4ab45f37de0240e19ad4e6b643"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mbed_tester.html#af71a5c4ab45f37de0240e19ad4e6b643">write</a> (uint32_t addr, const uint8_t *data, uint32_t size)</td></tr>
<tr class="memdesc:af71a5c4ab45f37de0240e19ad4e6b643"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write to tester memory.  <a href="class_mbed_tester.html#af71a5c4ab45f37de0240e19ad4e6b643">More...</a><br /></td></tr>
<tr class="separator:af71a5c4ab45f37de0240e19ad4e6b643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eb309078b13b7c5214b5759d25580dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mbed_tester.html#a8eb309078b13b7c5214b5759d25580dd">read</a> (uint32_t addr, uint8_t *data, uint32_t size)</td></tr>
<tr class="memdesc:a8eb309078b13b7c5214b5759d25580dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read from tester memory.  <a href="class_mbed_tester.html#a8eb309078b13b7c5214b5759d25580dd">More...</a><br /></td></tr>
<tr class="separator:a8eb309078b13b7c5214b5759d25580dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8445782a6b44c3c0a751ab7cb46c49ab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mbed_tester.html#a8445782a6b44c3c0a751ab7cb46c49ab">self_test_all</a> ()</td></tr>
<tr class="memdesc:a8445782a6b44c3c0a751ab7cb46c49ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run all self tests.  <a href="class_mbed_tester.html#a8445782a6b44c3c0a751ab7cb46c49ab">More...</a><br /></td></tr>
<tr class="separator:a8445782a6b44c3c0a751ab7cb46c49ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8646bfb76cc97709e0c5cf3dd5230e89"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mbed_tester.html#a8646bfb76cc97709e0c5cf3dd5230e89">self_test_control_channels</a> ()</td></tr>
<tr class="memdesc:a8646bfb76cc97709e0c5cf3dd5230e89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test that all allowed control channels can be used.  <a href="class_mbed_tester.html#a8646bfb76cc97709e0c5cf3dd5230e89">More...</a><br /></td></tr>
<tr class="separator:a8646bfb76cc97709e0c5cf3dd5230e89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a210fcd451374f7aa2ee27f3d936aae53"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mbed_tester.html#a210fcd451374f7aa2ee27f3d936aae53">self_test_control_miso</a> ()</td></tr>
<tr class="memdesc:a210fcd451374f7aa2ee27f3d936aae53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test that all allowed control miso lines can be used.  <a href="class_mbed_tester.html#a210fcd451374f7aa2ee27f3d936aae53">More...</a><br /></td></tr>
<tr class="separator:a210fcd451374f7aa2ee27f3d936aae53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93598fd663f554f0c314786e18bc0dd1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mbed_tester.html#a93598fd663f554f0c314786e18bc0dd1">self_test_control_current</a> ()</td></tr>
<tr class="memdesc:a93598fd663f554f0c314786e18bc0dd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test that the current control channel works.  <a href="class_mbed_tester.html#a93598fd663f554f0c314786e18bc0dd1">More...</a><br /></td></tr>
<tr class="separator:a93598fd663f554f0c314786e18bc0dd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock">
<p class="definition">Definition at line <a class="el" href="_s_p_i_master_tester_8h_source.html#l00023">23</a> of file <a class="el" href="_s_p_i_master_tester_8h_source.html">SPIMasterTester.h</a>.</p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="ad91c9bfd2d0e98dcb4be89caa6e86f52" name="ad91c9bfd2d0e98dcb4be89caa6e86f52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad91c9bfd2d0e98dcb4be89caa6e86f52">&#9670;&#160;</a></span>PullMode</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_mbed_tester.html#ad91c9bfd2d0e98dcb4be89caa6e86f52">PullMode</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>FPGA Pullup mode. </p>

<p class="definition">Definition at line <a class="el" href="_mbed_tester_8h_source.html#l00404">404</a> of file <a class="el" href="_mbed_tester_8h_source.html">MbedTester.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae728defed648d72e61e42de80f6f1bdd" name="ae728defed648d72e61e42de80f6f1bdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae728defed648d72e61e42de80f6f1bdd">&#9670;&#160;</a></span>firmware_dump()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool firmware_dump </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmbed_1_1_file_handle.html">mbed::FileHandle</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; void(uint8_t)&gt;&#160;</td>
          <td class="paramname"><em>progress</em> = <code><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt;&#160;void(uint8_t)&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read FPGA CI Test Shield firmware. </p>
<p >Read the firmware on the FPGA CI Test Shield. An optional progress callback can be supplied to display progress while the firmware is being read.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>File to write the firmware to. This file must have been opened as writeable </td></tr>
    <tr><td class="paramname">progress</td><td>Optional progress callback called when the percent complete changes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if firmware was successfully read, false otherwise </dd></dl>

</div>
</div>
<a id="aa1073a11b35157a6194311550d3fbe15" name="aa1073a11b35157a6194311550d3fbe15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1073a11b35157a6194311550d3fbe15">&#9670;&#160;</a></span>firmware_dump_all()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool firmware_dump_all </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmbed_1_1_file_handle.html">mbed::FileHandle</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; void(uint8_t)&gt;&#160;</td>
          <td class="paramname"><em>progress</em> = <code><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt;&#160;void(uint8_t)&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read FPGA CI Test Shield flash. </p>
<p >Read the entire flash contents of the FPGA CI Test Shield. An optional progress callback can be supplied to display progress while the firmware is being read.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>File to write the firmware to. This file must have been opened as writeable </td></tr>
    <tr><td class="paramname">progress</td><td>Optional progress callback called when the percent complete changes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if firmware was successfully read, false otherwise </dd></dl>

</div>
</div>
<a id="afa3dc94a89371462e855c8dfd85e8aec" name="afa3dc94a89371462e855c8dfd85e8aec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa3dc94a89371462e855c8dfd85e8aec">&#9670;&#160;</a></span>firmware_update()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool firmware_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmbed_1_1_file_handle.html">mbed::FileHandle</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; void(uint8_t)&gt;&#160;</td>
          <td class="paramname"><em>progress</em> = <code><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt;&#160;void(uint8_t)&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Program new FPGA CI Test Shield firmware. </p>
<p >Program firmware from the file given. The binary bitstream must be in the correct format and contain a correct CRC or the update will fail. To correctly format a bitstream binary the post_process_bitstream.py script in the fpga-ci-test-shield repository should be used.</p>
<p >Note - release binaries for the FPGA CI Test Shield have already been formatted and can be loaded directly with this function</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>File containing the new firmware to program </td></tr>
    <tr><td class="paramname">progress</td><td>Optional progress callback called when the percent complete changes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if firmware was successfully applied, false otherwise </dd></dl>

</div>
</div>
<a id="aaaf36b5543f96a717246a28152e035f2" name="aaaf36b5543f96a717246a28152e035f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaf36b5543f96a717246a28152e035f2">&#9670;&#160;</a></span>get_analog_in()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float get_analog_in </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the result of the analog to digital conversion computed on the FPGA in the form of a voltage reading. </p>
<p >The FPGA ADC operates on 0V-1V, which means this function will only ever return a float ranging from 0.0-1.0.</p>
<dl class="section return"><dt>Returns</dt><dd>The conversion result in the form of a voltage measurement for AnalogMuxIn, Eg. a return value of 0.7 means the ADC on the FPGA read 0.7 volts on its analog input </dd></dl>

</div>
</div>
<a id="a62d8618fe45a6c9ba4ce36ee47680338" name="a62d8618fe45a6c9ba4ce36ee47680338"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62d8618fe45a6c9ba4ce36ee47680338">&#9670;&#160;</a></span>get_analogmuxin_measurement()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t get_analogmuxin_measurement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the 12-bit analog to digital conversion result from the FPGA. </p>
<dl class="section return"><dt>Returns</dt><dd>12-bit FPGA ADC result for AnalogMuxIn </dd></dl>

</div>
</div>
<a id="aafbbbe691a8bee00c28953ba8ed11df1" name="aafbbbe691a8bee00c28953ba8ed11df1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafbbbe691a8bee00c28953ba8ed11df1">&#9670;&#160;</a></span>get_anin_measurement()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t get_anin_measurement </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Similar to 'get_analogmuxin_measurement' but returns the current XADC measurement for ANIN0-3. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>ANIN pin to read (0-3) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>12-bit FPGA ADC result for ANIN0-3 </dd></dl>

</div>
</div>
<a id="a7571005306ebc97908fa29a6bcf3b0ba" name="a7571005306ebc97908fa29a6bcf3b0ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7571005306ebc97908fa29a6bcf3b0ba">&#9670;&#160;</a></span>get_anin_sum_samples_cycles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void get_anin_sum_samples_cycles </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>sum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>cycles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets (by reference) the sum of all ANIN ADC results for any of the 4 ANIN pins specified by the index, number of ADC sample sequences that have completed since the XADC was turned on, and the number of FPGA clk cycles that have taken place since the ADC was turned on. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>ANIN pin of which to get sum of results (0-3) </td></tr>
    <tr><td class="paramname">sum</td><td>The sum of all specified ANIN pin's ADC results </td></tr>
    <tr><td class="paramname">samples</td><td>The number of ADC sample sequences that have completed since the XADC was turned on </td></tr>
    <tr><td class="paramname">cycles</td><td>The number of FPGA clk cycles that have taken place since the ADC was turned on </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa08bbf8a790e481242a75d2be0a967c0" name="aa08bbf8a790e481242a75d2be0a967c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa08bbf8a790e481242a75d2be0a967c0">&#9670;&#160;</a></span>get_anin_voltage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float get_anin_voltage </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Similar to 'get_analog_in' but returns a voltage reading from ANIN0-3. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>ANIN pin to read (0-3) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The conversion result in the form of a voltage measurement for ANIN0-3 </dd></dl>

</div>
</div>
<a id="a5adc6d8fc646ebf3aad5b21f5a4d6f94" name="a5adc6d8fc646ebf3aad5b21f5a4d6f94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5adc6d8fc646ebf3aad5b21f5a4d6f94">&#9670;&#160;</a></span>get_cs_to_first_clk_edge_ns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t get_cs_to_first_clk_edge_ns </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get nano seconds between chip select assertion and the first spi clock edge. </p>
<dl class="section return"><dt>Returns</dt><dd>nano seconds between chip select assertion and the first spi clock edge.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Number of nano seconds is calculated based of number of counted clk changes and clk frequency (100 MHz =&gt; 1 clk tick corresponds to 10 ns). Accuracy of the returned value is +/- 10 ns. </dd></dl>

</div>
</div>
<a id="a35235530410c978466bf4781e38686da" name="a35235530410c978466bf4781e38686da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35235530410c978466bf4781e38686da">&#9670;&#160;</a></span>get_last_clk_edge_to_cs_ns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t get_last_clk_edge_to_cs_ns </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get nano seconds between last spi clock edge and chip select de-assertion. </p>
<dl class="section return"><dt>Returns</dt><dd>nano seconds between last spi clock edge and chip select de-assertion.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Number of nano seconds is calculated based of number of counted clk changes and clk frequency (100 MHz =&gt; 1 clk tick corresponds to 10 ns). Accuracy of the returned value is +/- 10 ns. </dd></dl>

</div>
</div>
<a id="a19b675095afd0f1d3bd5cf1cd82e98ee" name="a19b675095afd0f1d3bd5cf1cd82e98ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19b675095afd0f1d3bd5cf1cd82e98ee">&#9670;&#160;</a></span>get_pwm_cycles_high()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t get_pwm_cycles_high </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of cycles that are high (duty cycle) from FPGA pwm. </p>
<dl class="section return"><dt>Returns</dt><dd>FPGA pwm output cycles high </dd></dl>

</div>
</div>
<a id="a5d5d641201e78923e17b383817e856f8" name="a5d5d641201e78923e17b383817e856f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d5d641201e78923e17b383817e856f8">&#9670;&#160;</a></span>get_pwm_enable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool get_pwm_enable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if FPGA pwm out is on or off. </p>
<dl class="section return"><dt>Returns</dt><dd>FPGA enable bit (false: off, true: on) </dd></dl>

</div>
</div>
<a id="a52b4408dde26134ce0582c1d74ad350c" name="a52b4408dde26134ce0582c1d74ad350c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52b4408dde26134ce0582c1d74ad350c">&#9670;&#160;</a></span>get_pwm_period()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t get_pwm_period </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the pwm output period of the FPGA. </p>
<dl class="section return"><dt>Returns</dt><dd>FPGA pwm output period in units of clk cycles </dd></dl>

</div>
</div>
<a id="a1d038185c09c969ab5a7879c00d95f9c" name="a1d038185c09c969ab5a7879c00d95f9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d038185c09c969ab5a7879c00d95f9c">&#9670;&#160;</a></span>get_receive_checksum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t get_receive_checksum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a checksum of data send to the tester. </p>
<dl class="section return"><dt>Returns</dt><dd>The sum of all bytes sent to the tester since reset. </dd></dl>

</div>
</div>
<a id="a626ba9c3ff3e539b7fb3213fef3551a3" name="a626ba9c3ff3e539b7fb3213fef3551a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a626ba9c3ff3e539b7fb3213fef3551a3">&#9670;&#160;</a></span>get_start_stop_stats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t get_start_stop_stats </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get SCLK and SIN states on transmission start and stop. </p>
<dl class="section return"><dt>Returns</dt><dd>latched SCLK and SIN states on transmission start and stop.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Stats are encoded as fallows (bit 0 - LSB):<ul>
<li>bit 0: start SCLK</li>
<li>bit 1: start SIN</li>
<li>bit 2: stop SCLK,</li>
<li>bit 3: stop SIN,</li>
<li>other: unused </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a1706ad3153de269c4be6898ab985168a" name="a1706ad3153de269c4be6898ab985168a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1706ad3153de269c4be6898ab985168a">&#9670;&#160;</a></span>get_transfer_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t get_transfer_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the number of transfers which have occurred. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of SPI transfers that have completed since spi was reset. </dd></dl>

</div>
</div>
<a id="a40b8e1ca49ead640a37e985f618e5e05" name="a40b8e1ca49ead640a37e985f618e5e05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40b8e1ca49ead640a37e985f618e5e05">&#9670;&#160;</a></span>gpio_read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int gpio_read </td>
          <td>(</td>
          <td class="paramtype">LogicalPin&#160;</td>
          <td class="paramname"><em>gpio</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a gpio pin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gpio</td><td>Logical pin to read from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the pin is high 0 if the pin is low </dd></dl>

</div>
</div>
<a id="ac295cbdf2256b829a8d0a91cddad16eb" name="ac295cbdf2256b829a8d0a91cddad16eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac295cbdf2256b829a8d0a91cddad16eb">&#9670;&#160;</a></span>gpio_write()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gpio_write </td>
          <td>(</td>
          <td class="paramtype">LogicalPin&#160;</td>
          <td class="paramname"><em>gpio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>drive</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set value and drive of a gpio pin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gpio</td><td>Logical pin to write to </td></tr>
    <tr><td class="paramname">value</td><td>0 to set the pin low or non-zero to set it high </td></tr>
    <tr><td class="paramname">driver</td><td>0 to set the pin to Hi-Z or non-zero to drive the pin </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1bb41a2bd89c8693a27b007af9f17636" name="a1bb41a2bd89c8693a27b007af9f17636"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bb41a2bd89c8693a27b007af9f17636">&#9670;&#160;</a></span>io_expander_i2c_read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int io_expander_i2c_read </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>i2c_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>start_reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>I2C read on I2C system channels 0, 1, or 2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c_index</td><td>The number corresponding to the system i2c bus being used (0, 1, or 2) </td></tr>
    <tr><td class="paramname">dev_addr</td><td>The I2C address of the device being read from </td></tr>
    <tr><td class="paramname">start_reg</td><td>The internal device address where the read will start </td></tr>
    <tr><td class="paramname">data</td><td>Data buffer for data to be read into </td></tr>
    <tr><td class="paramname">length</td><td>The number of bytes to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success (ACK), nonzero on failure (NACK) </dd></dl>

</div>
</div>
<a id="ac9b1f8d9e819a7ecd25d818e41ded815" name="ac9b1f8d9e819a7ecd25d818e41ded815"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9b1f8d9e819a7ecd25d818e41ded815">&#9670;&#160;</a></span>io_expander_i2c_read_bb()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int io_expander_i2c_read_bb </td>
          <td>(</td>
          <td class="paramtype">SystemPin&#160;</td>
          <td class="paramname"><em>sda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SystemPin&#160;</td>
          <td class="paramname"><em>scl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>start_reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>I2C read on I2C system channels 0, 1, or 2 (bit banged version of function, bit banged over control channel) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sda</td><td>System pin used for sda </td></tr>
    <tr><td class="paramname">scl</td><td>System pin used for scl </td></tr>
    <tr><td class="paramname">dev_addr</td><td>The I2C address of the device being read from </td></tr>
    <tr><td class="paramname">start_reg</td><td>The internal device address where the read will start </td></tr>
    <tr><td class="paramname">data</td><td>Data buffer for data to be read into </td></tr>
    <tr><td class="paramname">length</td><td>The number of bytes to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success (ACK), nonzero on failure (NACK) </dd></dl>

</div>
</div>
<a id="ad87a1861252adc575d7092c03756b81f" name="ad87a1861252adc575d7092c03756b81f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad87a1861252adc575d7092c03756b81f">&#9670;&#160;</a></span>io_expander_i2c_write()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int io_expander_i2c_write </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>i2c_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>I2C write on I2C system channels 0, 1, or 2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c_index</td><td>The number corresponding to the system i2c bus being used (0, 1, or 2) </td></tr>
    <tr><td class="paramname">dev_addr</td><td>The I2C address of the device being written to </td></tr>
    <tr><td class="paramname">data</td><td>The data to be written </td></tr>
    <tr><td class="paramname">length</td><td>The number of bytes to be written </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success (ACK), nonzero on failure (NACK) </dd></dl>

</div>
</div>
<a id="a2def5404d53f8eef23f5222bc98fcf48" name="a2def5404d53f8eef23f5222bc98fcf48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2def5404d53f8eef23f5222bc98fcf48">&#9670;&#160;</a></span>io_expander_i2c_write_bb()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int io_expander_i2c_write_bb </td>
          <td>(</td>
          <td class="paramtype">SystemPin&#160;</td>
          <td class="paramname"><em>sda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SystemPin&#160;</td>
          <td class="paramname"><em>scl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>I2C write on I2C system channels 0, 1, or 2 (bit banged version of function, bit banged over control channel) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sda</td><td>System pin used for sda </td></tr>
    <tr><td class="paramname">scl</td><td>System pin used for scl </td></tr>
    <tr><td class="paramname">dev_addr</td><td>The I2C address of the device being written to </td></tr>
    <tr><td class="paramname">data</td><td>The data to be written </td></tr>
    <tr><td class="paramname">length</td><td>The number of bytes to be written </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success (ACK), nonzero on failure (NACK) </dd></dl>

</div>
</div>
<a id="a20378153c45434854ef0da0eac81f818" name="a20378153c45434854ef0da0eac81f818"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20378153c45434854ef0da0eac81f818">&#9670;&#160;</a></span>io_expander_read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t io_expander_read </td>
          <td>(</td>
          <td class="paramtype">PinName&#160;</td>
          <td class="paramname"><em>pin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IOExpanderReg&#160;</td>
          <td class="paramname"><em>reg_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a bit for a specific Mbed pin that is set in the input, output, or configuration registers inside of the IO expander via PinName. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pin</td><td>Mbed pin whose register bit is being read </td></tr>
    <tr><td class="paramname">reg_type</td><td>Pin register to access, options are: MbedTester::RegInput, MbedTester::RegOutput, or MbedTester::RegConfig </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the bit read </dd></dl>

</div>
</div>
<a id="a1836957e22fa3cecbf0b7a2291690fcf" name="a1836957e22fa3cecbf0b7a2291690fcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1836957e22fa3cecbf0b7a2291690fcf">&#9670;&#160;</a></span>io_expander_read_bb()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t io_expander_read_bb </td>
          <td>(</td>
          <td class="paramtype">PinName&#160;</td>
          <td class="paramname"><em>pin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IOExpanderReg&#160;</td>
          <td class="paramname"><em>reg_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a bit for a specific Mbed pin that is set in the input, output, or configuration registers inside of the IO expander (this version of the function uses io_expander_i2c_read_bb) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pin</td><td>Mbed pin whose register bit is being read </td></tr>
    <tr><td class="paramname">reg_type</td><td>Pin register to access, options are: MbedTester::RegInput, MbedTester::RegOutput, or MbedTester::RegConfig </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the bit read </dd></dl>

</div>
</div>
<a id="a5c7caf14d4d019023a81868cedb14a82" name="a5c7caf14d4d019023a81868cedb14a82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c7caf14d4d019023a81868cedb14a82">&#9670;&#160;</a></span>io_expander_read_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t io_expander_read_index </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IOExpanderReg&#160;</td>
          <td class="paramname"><em>reg_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a bit for a specific Mbed pin that is set in the input, output, or configuration registers inside of the IO expander via pin index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Mbed pin index whose register bit is being read </td></tr>
    <tr><td class="paramname">reg_type</td><td>Pin register to access, options are: MbedTester::RegInput, MbedTester::RegOutput, or MbedTester::RegConfig </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the bit read </dd></dl>

</div>
</div>
<a id="a5943471dd9ca342c70cf5b5106e9b32f" name="a5943471dd9ca342c70cf5b5106e9b32f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5943471dd9ca342c70cf5b5106e9b32f">&#9670;&#160;</a></span>io_metrics_continue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void io_metrics_continue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Continue recording metrics on all logical pins. </p>
<p >Resume recording metrics. </p>

</div>
</div>
<a id="affee4e3c418ed89b3541b90ff1ac9224" name="affee4e3c418ed89b3541b90ff1ac9224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affee4e3c418ed89b3541b90ff1ac9224">&#9670;&#160;</a></span>io_metrics_falling_edges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t io_metrics_falling_edges </td>
          <td>(</td>
          <td class="paramtype">LogicalPin&#160;</td>
          <td class="paramname"><em>pin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of falling edges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pin</td><td>Pin to read the metrics for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of falling edges </dd></dl>

</div>
</div>
<a id="ac560ef4377d8f8d72d2cee07bf7c4582" name="ac560ef4377d8f8d72d2cee07bf7c4582"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac560ef4377d8f8d72d2cee07bf7c4582">&#9670;&#160;</a></span>io_metrics_max_pulse_high()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t io_metrics_max_pulse_high </td>
          <td>(</td>
          <td class="paramtype">LogicalPin&#160;</td>
          <td class="paramname"><em>pin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the longest high pulse recorded. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pin</td><td>Pin to read the metrics for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The longest number of 100MHz clock cycles the pin was high </dd></dl>

</div>
</div>
<a id="a99b0a6d20c97a2f16930506c18463169" name="a99b0a6d20c97a2f16930506c18463169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99b0a6d20c97a2f16930506c18463169">&#9670;&#160;</a></span>io_metrics_max_pulse_low()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t io_metrics_max_pulse_low </td>
          <td>(</td>
          <td class="paramtype">LogicalPin&#160;</td>
          <td class="paramname"><em>pin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the longest low pulse recorded. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pin</td><td>Pin to read the metrics for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The longest number of 100MHz clock cycles the pin was low </dd></dl>

</div>
</div>
<a id="a778de7d7f6b0c11d40026455431faf32" name="a778de7d7f6b0c11d40026455431faf32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a778de7d7f6b0c11d40026455431faf32">&#9670;&#160;</a></span>io_metrics_min_pulse_high()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t io_metrics_min_pulse_high </td>
          <td>(</td>
          <td class="paramtype">LogicalPin&#160;</td>
          <td class="paramname"><em>pin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the shortest high pulse recorded. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pin</td><td>Pin to read the metrics for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The shortest number of 100MHz clock cycles the pin was high </dd></dl>

</div>
</div>
<a id="a9e85b38f8a2ff60e932404a1aca12746" name="a9e85b38f8a2ff60e932404a1aca12746"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e85b38f8a2ff60e932404a1aca12746">&#9670;&#160;</a></span>io_metrics_min_pulse_low()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t io_metrics_min_pulse_low </td>
          <td>(</td>
          <td class="paramtype">LogicalPin&#160;</td>
          <td class="paramname"><em>pin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the shortest low pulse recorded. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pin</td><td>Pin to read the metrics for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The shortest number of 100MHz clock cycles the pin was low </dd></dl>

</div>
</div>
<a id="a754d9ecc38b6bfbc80f892dbc2429378" name="a754d9ecc38b6bfbc80f892dbc2429378"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a754d9ecc38b6bfbc80f892dbc2429378">&#9670;&#160;</a></span>io_metrics_rising_edges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t io_metrics_rising_edges </td>
          <td>(</td>
          <td class="paramtype">LogicalPin&#160;</td>
          <td class="paramname"><em>pin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of rising edges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pin</td><td>Pin to read the metrics for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of rising edges </dd></dl>

</div>
</div>
<a id="a46de87c0fd447ce48a9153e4a4c989f2" name="a46de87c0fd447ce48a9153e4a4c989f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46de87c0fd447ce48a9153e4a4c989f2">&#9670;&#160;</a></span>io_metrics_start()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void io_metrics_start </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start recording metrics on all logical pins. </p>
<p >This function resets all past metrics to 0. To preserve these call io_metrics_continue instead. </p>

</div>
</div>
<a id="a6471bb52f4d357cd39614d910433f9a9" name="a6471bb52f4d357cd39614d910433f9a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6471bb52f4d357cd39614d910433f9a9">&#9670;&#160;</a></span>io_metrics_stop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void io_metrics_stop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stop recording metrics on all logical pins. </p>
<p >This function should be called before any metrics are read to ensure the value does not change while they are being read. </p>

</div>
</div>
<a id="a64ef1c1f3b9f27219fb0cf041865f1e3" name="a64ef1c1f3b9f27219fb0cf041865f1e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64ef1c1f3b9f27219fb0cf041865f1e3">&#9670;&#160;</a></span>peripherals_reset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void peripherals_reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset all peripherals. </p>
<p >This does not reset the pin mappings </p>

</div>
</div>
<a id="a35479ffc930d5153242802491c3bdf6b" name="a35479ffc930d5153242802491c3bdf6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35479ffc930d5153242802491c3bdf6b">&#9670;&#160;</a></span>pin_map_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pin_map_index </td>
          <td>(</td>
          <td class="paramtype">PhysicalIndex&#160;</td>
          <td class="paramname"><em>physical_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LogicalPin&#160;</td>
          <td class="paramname"><em>logical</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Map a physical pin index to the given logical pin. </p>
<p >This function will automatically move the control channel pins to avoid interfering with the mapped pin. The physical pin index does not need to be part of the form factor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">physical_index</td><td>Index of the physical pin on the board </td></tr>
    <tr><td class="paramname">logical</td><td>Logical pin to map to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1c3097ebcd9371a45b18a3f8c1dabf85" name="a1c3097ebcd9371a45b18a3f8c1dabf85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c3097ebcd9371a45b18a3f8c1dabf85">&#9670;&#160;</a></span>pin_map_reset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pin_map_reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset all pin mappings. </p>
<p >After this call all pins will be unmapped </p>

</div>
</div>
<a id="a89a38f832cf0df5ac4281114ce47fed1" name="a89a38f832cf0df5ac4281114ce47fed1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89a38f832cf0df5ac4281114ce47fed1">&#9670;&#160;</a></span>pin_map_set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pin_map_set </td>
          <td>(</td>
          <td class="paramtype">PinName&#160;</td>
          <td class="paramname"><em>physical</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LogicalPin&#160;</td>
          <td class="paramname"><em>logical</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Map a physical pin to the given logical pin. </p>
<p >This function will automatically move the control channel pins to avoid interfering with the mapped pin.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">physical</td><td>Physical pin on the board </td></tr>
    <tr><td class="paramname">logical</td><td>Logical pin to map to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a899da77e493cc99e301faea15bfdb413" name="a899da77e493cc99e301faea15bfdb413"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a899da77e493cc99e301faea15bfdb413">&#9670;&#160;</a></span>pin_pull_reset_all()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pin_pull_reset_all </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset the IO expander modules. </p>

</div>
</div>
<a id="a21e16d04752892415a8279e099ea3333" name="a21e16d04752892415a8279e099ea3333"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21e16d04752892415a8279e099ea3333">&#9670;&#160;</a></span>pin_set_pull()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int pin_set_pull </td>
          <td>(</td>
          <td class="paramtype">PinName&#160;</td>
          <td class="paramname"><em>pin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mbed_tester.html#ad91c9bfd2d0e98dcb4be89caa6e86f52">PullMode</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Configure an Mbed pin for a pulldown resistor, pullup resistor, or tristate mode via PinName. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pin</td><td>Mbed pin whose mode is being set </td></tr>
    <tr><td class="paramname">mode</td><td>(MbedTester::PullUp, MbedTester::PullDown, or MbedTester::PullNone) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, nonzero on failure </dd></dl>

</div>
</div>
<a id="a32f15d00dd9df5abadd596c6585a7438" name="a32f15d00dd9df5abadd596c6585a7438"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32f15d00dd9df5abadd596c6585a7438">&#9670;&#160;</a></span>pin_set_pull_bb()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int pin_set_pull_bb </td>
          <td>(</td>
          <td class="paramtype">PinName&#160;</td>
          <td class="paramname"><em>pin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mbed_tester.html#ad91c9bfd2d0e98dcb4be89caa6e86f52">PullMode</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Configure an Mbed pin for a pulldown resistor, pullup resistor, or tristate mode (this version of the function uses io_expander_i2c_read_bb and io_expander_i2c_write_bb) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pin</td><td>Mbed pin whose mode is being set </td></tr>
    <tr><td class="paramname">mode</td><td>(MbedTester::PullUp, MbedTester::PullDown, or MbedTester::PullNone) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, nonzero on failure </dd></dl>

</div>
</div>
<a id="af559c95db92afa9f5fef01331f28e0d0" name="af559c95db92afa9f5fef01331f28e0d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af559c95db92afa9f5fef01331f28e0d0">&#9670;&#160;</a></span>pin_set_pull_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int pin_set_pull_index </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mbed_tester.html#ad91c9bfd2d0e98dcb4be89caa6e86f52">PullMode</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Configure an Mbed pin for a pulldown resistor, pullup resistor, or tristate mode via pin index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Mbed pin index whose mode is being set </td></tr>
    <tr><td class="paramname">mode</td><td>(MbedTester::PullUp, MbedTester::PullDown, or MbedTester::PullNone) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, nonzero on failure </dd></dl>

</div>
</div>
<a id="a8eb309078b13b7c5214b5759d25580dd" name="a8eb309078b13b7c5214b5759d25580dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8eb309078b13b7c5214b5759d25580dd">&#9670;&#160;</a></span>read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void read </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read from tester memory. </p>
<p >@addr addr Address to read from </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Buffer to fill with data </td></tr>
    <tr><td class="paramname">size</td><td>Number of bytes to read </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a14db2eb3ee7c5c811b4d982d79aec8e0" name="a14db2eb3ee7c5c811b4d982d79aec8e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14db2eb3ee7c5c811b4d982d79aec8e0">&#9670;&#160;</a></span>reprogram()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reprogram </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reprogram the FPGA. </p>
<p >This function causes the FPGA to reboot and reload RAM contents. This should be used after <a class="el" href="class_mbed_tester.html#afa3dc94a89371462e855c8dfd85e8aec" title="Program new FPGA CI Test Shield firmware.">MbedTester::firmware_update</a> to load the new image. </p>

</div>
</div>
<a id="ad20897c5c8bd47f5d4005989bead0e55" name="ad20897c5c8bd47f5d4005989bead0e55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad20897c5c8bd47f5d4005989bead0e55">&#9670;&#160;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset everything. </p>
<p >This function resets the state of both the FPGA CI Test Shield and the <a class="el" href="class_mbed_tester.html" title="The base class for controlling the FPGA CI Test Shield.">MbedTester</a> object itself.</p>
<p >Reset effects on the FPGA CI Test Shield include:</p><ul>
<li>All pins are tristated</li>
<li>All pin mappings are reset</li>
<li>All pullup/pulldown settings are reset</li>
<li>All peripherals are reset</li>
</ul>
<p >Reset effects on the <a class="el" href="class_mbed_tester.html" title="The base class for controlling the FPGA CI Test Shield.">MbedTester</a> object include</p><ul>
<li>Control channels tristated and freed</li>
<li>Control channel selection set to automatic</li>
<li>Most internal state reinitialized </li>
</ul>

</div>
</div>
<a id="aedf6f6c5852e8c5e4fd28da83834bc66" name="aedf6f6c5852e8c5e4fd28da83834bc66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedf6f6c5852e8c5e4fd28da83834bc66">&#9670;&#160;</a></span>select_peripheral()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void select_peripheral </td>
          <td>(</td>
          <td class="paramtype">Peripheral&#160;</td>
          <td class="paramname"><em>peripheral</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Select the currently active peripheral. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">peripheral</td><td>Active peripheral </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8445782a6b44c3c0a751ab7cb46c49ab" name="a8445782a6b44c3c0a751ab7cb46c49ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8445782a6b44c3c0a751ab7cb46c49ab">&#9670;&#160;</a></span>self_test_all()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool self_test_all </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Run all self tests. </p>
<dl class="section return"><dt>Returns</dt><dd>true if all self tests pass, false otherwise </dd></dl>

</div>
</div>
<a id="a8646bfb76cc97709e0c5cf3dd5230e89" name="a8646bfb76cc97709e0c5cf3dd5230e89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8646bfb76cc97709e0c5cf3dd5230e89">&#9670;&#160;</a></span>self_test_control_channels()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool self_test_control_channels </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test that all allowed control channels can be used. </p>
<p >Check that all pairs of clk and mosi which aren't in the restricted list can be used.</p>
<dl class="section note"><dt>Note</dt><dd>CLK and MOSI lines are paired, where CLK is always on an even index and MOSI is always on an oddd index: clk_index_N = N * 2 mosi_index_N = N * 2 + 1</dd>
<dd>
This functions sets the control pin management mode to automatic when it completes.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true if all control channel pairs (clk and mosi) of this configuration can be used, false otherwise </dd></dl>

</div>
</div>
<a id="a93598fd663f554f0c314786e18bc0dd1" name="a93598fd663f554f0c314786e18bc0dd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93598fd663f554f0c314786e18bc0dd1">&#9670;&#160;</a></span>self_test_control_current()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool self_test_control_current </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test that the current control channel works. </p>
<dl class="section return"><dt>Returns</dt><dd>true if communication is successful, false otherwise </dd></dl>

</div>
</div>
<a id="a210fcd451374f7aa2ee27f3d936aae53" name="a210fcd451374f7aa2ee27f3d936aae53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a210fcd451374f7aa2ee27f3d936aae53">&#9670;&#160;</a></span>self_test_control_miso()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool self_test_control_miso </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test that all allowed control miso lines can be used. </p>
<p >Check that every pin of this form factor aside from the pins in the restricted list can be used as miso.</p>
<dl class="section note"><dt>Note</dt><dd>This functions sets the control pin management mode to automatic when it completes.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true if all control channel miso lines of this configuration can be used, false otherwise </dd></dl>

</div>
</div>
<a id="a22a332ce0ca574f076bf174c5ae5cc18" name="a22a332ce0ca574f076bf174c5ae5cc18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22a332ce0ca574f076bf174c5ae5cc18">&#9670;&#160;</a></span>set_analog_out()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void set_analog_out </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>voltage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an analog voltage via the FPGA sys pwm in order to test Mbed AnalogIn. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>Enable the FPGA system PWM (false: of, true: on) </td></tr>
    <tr><td class="paramname">voltage</td><td>The analog voltage that will be created by the FPGA CI test shield (float: 0.0 to 1.0) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8e5d7cc92ec95ce1ec3d434b6b4303b7" name="a8e5d7cc92ec95ce1ec3d434b6b4303b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e5d7cc92ec95ce1ec3d434b6b4303b7">&#9670;&#160;</a></span>set_bit_order()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_bit_order </td>
          <td>(</td>
          <td class="paramtype">SpiBitOrder&#160;</td>
          <td class="paramname"><em>bit_order</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set bit order durring transmission of the spi_slave module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>Spi clock mode </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac70d0289063e596b4e8ec6b1990d8bc1" name="ac70d0289063e596b4e8ec6b1990d8bc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac70d0289063e596b4e8ec6b1990d8bc1">&#9670;&#160;</a></span>set_control_pins_auto()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void set_control_pins_auto </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable automatic selection and update of control pins. </p>
<p >Calling this function configures <a class="el" href="class_mbed_tester.html" title="The base class for controlling the FPGA CI Test Shield.">MbedTester</a> to automatically select and update the control pins. The control pins are moved if the function <a class="el" href="class_mbed_tester.html#a89a38f832cf0df5ac4281114ce47fed1" title="Map a physical pin to the given logical pin.">MbedTester::pin_map_set</a> is called and maps a pin that is being used for control.</p>
<dl class="section note"><dt>Note</dt><dd>Automatic selection and update of control pins is the default. Unless <a class="el" href="class_mbed_tester.html#abdb5133547384f59b7eba1043ecdcbec" title="Set the control pins to use for communication.">MbedTester::set_control_pins_manual</a> has been called to manually set the control pins this function has no effect. </dd></dl>

</div>
</div>
<a id="abdb5133547384f59b7eba1043ecdcbec" name="abdb5133547384f59b7eba1043ecdcbec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdb5133547384f59b7eba1043ecdcbec">&#9670;&#160;</a></span>set_control_pins_manual()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void set_control_pins_manual </td>
          <td>(</td>
          <td class="paramtype">PinName&#160;</td>
          <td class="paramname"><em>clk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PinName&#160;</td>
          <td class="paramname"><em>mosi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PinName&#160;</td>
          <td class="paramname"><em>miso</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PinName&#160;</td>
          <td class="paramname"><em>aux</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the control pins to use for communication. </p>
<p >Manually set the control pins. Calling this function disables automatic control pin selection and updates. The function <a class="el" href="class_mbed_tester.html#a89a38f832cf0df5ac4281114ce47fed1" title="Map a physical pin to the given logical pin.">MbedTester::pin_map_set</a> must not be used to map over control pins when in this mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clk</td><td>Clock pin to use as the control channel </td></tr>
    <tr><td class="paramname">mosi</td><td>Mosi pin to use as the control channel </td></tr>
    <tr><td class="paramname">miso</td><td>Miso pin to use as the control channel </td></tr>
    <tr><td class="paramname">aux</td><td>Auxillary pin to use as the control cannel </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae0ce7769e07314e4b86a13f5e383507b" name="ae0ce7769e07314e4b86a13f5e383507b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0ce7769e07314e4b86a13f5e383507b">&#9670;&#160;</a></span>set_duplex_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_duplex_mode </td>
          <td>(</td>
          <td class="paramtype">SpiDuplex&#160;</td>
          <td class="paramname"><em>duplex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set full-duplex/half-duplex transmission mode of the spi_slave module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">duplex</td><td>duplex mode used for the transmission </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae2fba9756e2235ecf1be34be2ed73a77" name="ae2fba9756e2235ecf1be34be2ed73a77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2fba9756e2235ecf1be34be2ed73a77">&#9670;&#160;</a></span>set_hd_tx_rx_cnt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_hd_tx_rx_cnt </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>tx_cnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>rx_cnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set tx/rx symbol count. </p>
<p >@tx_cnt TX symbol count @rx_cnt RX symbol count</p>
<dl class="section note"><dt>Note</dt><dd>Required only in Half-Duplex mode. </dd></dl>

</div>
</div>
<a id="ad7a48c0e0d5b1e2f60b7b197a5572099" name="ad7a48c0e0d5b1e2f60b7b197a5572099"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7a48c0e0d5b1e2f60b7b197a5572099">&#9670;&#160;</a></span>set_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_mode </td>
          <td>(</td>
          <td class="paramtype">SpiMode&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the clock mode of the spi_slave module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>Spi clock mode </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a81fecd8c9c1d3ba88632cb734da43c2b" name="a81fecd8c9c1d3ba88632cb734da43c2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81fecd8c9c1d3ba88632cb734da43c2b">&#9670;&#160;</a></span>set_mux_addr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int set_mux_addr </td>
          <td>(</td>
          <td class="paramtype">PinName&#160;</td>
          <td class="paramname"><em>pin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the AnalogMuxAddr pins on the FPGA via PinName. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pin</td><td>The Mbed pin that the analog signal will be routed to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, nonzero on failure </dd></dl>

</div>
</div>
<a id="ad41919ba357ad8fdc04642489593c436" name="ad41919ba357ad8fdc04642489593c436"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad41919ba357ad8fdc04642489593c436">&#9670;&#160;</a></span>set_mux_addr_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int set_mux_addr_index </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the AnalogMuxAddr pins on the FPGA via pin index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The Mbed pin index that the analog signal will be routed to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, nonzero on failure </dd></dl>

</div>
</div>
<a id="afee16bb712db65e27346730f8e6cd049" name="afee16bb712db65e27346730f8e6cd049"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afee16bb712db65e27346730f8e6cd049">&#9670;&#160;</a></span>set_mux_enable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void set_mux_enable </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Turn on/off the analog muxes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>false: off, true: on </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acefb87575238ed961edc561c5223c0ba" name="acefb87575238ed961edc561c5223c0ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acefb87575238ed961edc561c5223c0ba">&#9670;&#160;</a></span>set_pwm_enable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void set_pwm_enable </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Turn on/off pwm output on FPGA to test Mbed AnalogIn. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>false: off, true: on </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="addafc573e0c82dae996f0322e2595f40" name="addafc573e0c82dae996f0322e2595f40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addafc573e0c82dae996f0322e2595f40">&#9670;&#160;</a></span>set_pwm_period_and_cycles_high()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void set_pwm_period_and_cycles_high </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>period</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cycles_high</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the pwm output period and number of cycles high (duty cycle) on the FPGA. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">period</td><td>In units of clk cycles </td></tr>
    <tr><td class="paramname">cycles_high</td><td>In units of clk cycles </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3119ad21d71329daa79cc15108fc2a8b" name="a3119ad21d71329daa79cc15108fc2a8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3119ad21d71329daa79cc15108fc2a8b">&#9670;&#160;</a></span>set_sample_adc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void set_sample_adc </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Turn the FPGA ADC on and off (power management data will be collected while the ADC is on) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>FPGA ADC enable bit (false: off, true: on) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac2e458283e6ae7d99f8fb457ffadabf9" name="ac2e458283e6ae7d99f8fb457ffadabf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e458283e6ae7d99f8fb457ffadabf9">&#9670;&#160;</a></span>set_snapshot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void set_snapshot </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows safe reading of FPGA ADC related values while the FPGA ADC is on If snapshot is set then the ADC values will be safely latched in the FPGA and safe to read. </p>
<p >The RTL will set snapshot to 0 after 1 clk cycle. </p>

</div>
</div>
<a id="aae61d348f133e03c3a0330b8a79f5af2" name="aae61d348f133e03c3a0330b8a79f5af2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae61d348f133e03c3a0330b8a79f5af2">&#9670;&#160;</a></span>set_sym_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_sym_size </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>sym_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set symbol size used durring transmission of the spi_slave module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>Spi clock mode </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad1429793080888c9e682898796646dbd" name="ad1429793080888c9e682898796646dbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1429793080888c9e682898796646dbd">&#9670;&#160;</a></span>sys_pin_mode_disabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sys_pin_mode_disabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the current system pin mode to disabled. </p>
<p >This releases any pin mappings that were set by the previous pin mode. </p>

</div>
</div>
<a id="a20d0b2afb587422aadd59aa819398814" name="a20d0b2afb587422aadd59aa819398814"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20d0b2afb587422aadd59aa819398814">&#9670;&#160;</a></span>sys_pin_mode_i2c_io_expander()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sys_pin_mode_i2c_io_expander </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PhysicalIndex&#160;</td>
          <td class="paramname"><em>sda_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PhysicalIndex&#160;</td>
          <td class="paramname"><em>sda_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PhysicalIndex&#160;</td>
          <td class="paramname"><em>scl_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PhysicalIndex&#160;</td>
          <td class="paramname"><em>scl_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the current system pin mode to io expander I2C bus. </p>
<p >Remap physical pins to the io expander I2C bus. The IO expanders are used for setting pullups and pulldowns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the I2C bus to connect to </td></tr>
    <tr><td class="paramname">sda_in</td><td>Physical pin index for the FPGA to output the state of SDA on </td></tr>
    <tr><td class="paramname">sda_val</td><td>Physical pin index for the FPGA to read SDA from. When in this mode the Mbed board must always drive this pin. Driving a 0 causes the FPGA to pull the SDA on the I2C bus low. Setting a 1 causes the FPGA to let SDA on the I2C bus float (and get pulled to 1). </td></tr>
    <tr><td class="paramname">scl_in</td><td>Physical pin index for the FPGA to output the state of SCL on </td></tr>
    <tr><td class="paramname">scl_val</td><td>Physical pin index for the FPGA to read SCL from. When in this mode the Mbed board must always drive this pin. Driving a 0 causes the FPGA to pull the SCL on the I2C bus low. Setting a 1 causes the FPGA to let SDA on the SCL bus float (and get pulled to 1). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae8a72a1f632b1b053e3a4398688b6ad7" name="ae8a72a1f632b1b053e3a4398688b6ad7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8a72a1f632b1b053e3a4398688b6ad7">&#9670;&#160;</a></span>sys_pin_mode_spi_serial_flash()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sys_pin_mode_spi_serial_flash </td>
          <td>(</td>
          <td class="paramtype">PhysicalIndex&#160;</td>
          <td class="paramname"><em>mosi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PhysicalIndex&#160;</td>
          <td class="paramname"><em>miso</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PhysicalIndex&#160;</td>
          <td class="paramname"><em>clk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PhysicalIndex&#160;</td>
          <td class="paramname"><em>ssel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the current system pin mode to serial flash. </p>
<p >Remap physical pins to the serial flash the FPGA boots from. This is used for firmware updates.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mosi</td><td>The physical pin index to connect to serial flash mosi </td></tr>
    <tr><td class="paramname">miso</td><td>The physical pin index to connect to serial flash miso </td></tr>
    <tr><td class="paramname">clk</td><td>The physical pin index to connect to serial flash clk </td></tr>
    <tr><td class="paramname">ssel</td><td>The physical pin index to connect to serial flash cs </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a621924c294fd2aac4e6c5b3b72f1a708" name="a621924c294fd2aac4e6c5b3b72f1a708"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a621924c294fd2aac4e6c5b3b72f1a708">&#9670;&#160;</a></span>sys_pin_read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sys_pin_read </td>
          <td>(</td>
          <td class="paramtype">SystemPin&#160;</td>
          <td class="paramname"><em>pin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read from the given system pin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pin</td><td>The pin to read from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if 1 was read, false if 0 </dd></dl>

</div>
</div>
<a id="aa599490906aed03297ecf9c8b3ed0bdb" name="aa599490906aed03297ecf9c8b3ed0bdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa599490906aed03297ecf9c8b3ed0bdb">&#9670;&#160;</a></span>sys_pin_write()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sys_pin_write </td>
          <td>(</td>
          <td class="paramtype">SystemPin&#160;</td>
          <td class="paramname"><em>pin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>drive</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write to the given system pin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pin</td><td>The pin to write to </td></tr>
    <tr><td class="paramname">value</td><td>The value to output on the pin when driven </td></tr>
    <tr><td class="paramname">true</td><td>to drive the output, false to set the output high-z </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if 1 was read, false if 0 </dd></dl>

</div>
</div>
<a id="a1cc07efe3a621a94b28f1d9bf7bff3cd" name="a1cc07efe3a621a94b28f1d9bf7bff3cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cc07efe3a621a94b28f1d9bf7bff3cd">&#9670;&#160;</a></span>version()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t version </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the running FPGA firmware version. </p>
<dl class="section return"><dt>Returns</dt><dd>The version of firmware running on the FPGA. </dd></dl>

</div>
</div>
<a id="af71a5c4ab45f37de0240e19ad4e6b643" name="af71a5c4ab45f37de0240e19ad4e6b643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af71a5c4ab45f37de0240e19ad4e6b643">&#9670;&#160;</a></span>write()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void write </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write to tester memory. </p>
<p >@addr addr Address to write to </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Data to write </td></tr>
    <tr><td class="paramname">size</td><td>Number of bytes to write </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_s_p_i_master_tester.html">SPIMasterTester</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>

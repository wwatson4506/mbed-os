<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Mbed OS Reference: EventQueue Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="mbed-ce_55x55.png"/></td>
  <td id="projectalign">
   <div id="projectname">Mbed OS Reference
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classevents_1_1_event_queue.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle"><div class="title">EventQueue Class Reference<div class="ingroups"><a class="el" href="group__mbed-os-public.html">Public API</a> &raquo; <a class="el" href="group__events-public-api.html">Events</a> &raquo; <a class="el" href="group__events___event_queue.html">EventQueue class</a></div></div></div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classevents_1_1_event_queue.html" title="EventQueue.">EventQueue</a>.  
 <a href="classevents_1_1_event_queue.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_event_queue_8h_source.html">EventQueue.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for EventQueue:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classevents_1_1_event_queue.png" usemap="#EventQueue_map" alt=""/>
  <map id="EventQueue_map" name="EventQueue_map">
<area href="classmbed_1_1_non_copyable.html" alt="NonCopyable&lt; EventQueue &gt;" shape="rect" coords="0,0,183,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a510a5f111e4f8442eb8f717ea60ddb02"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevents_1_1_event_queue.html#a510a5f111e4f8442eb8f717ea60ddb02">EventQueue</a> (unsigned size=(32 *(EQUEUE_EVENT_SIZE - 2 *sizeof(void *)+sizeof(<a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; void()&gt;))), unsigned char *buffer=NULL)</td></tr>
<tr class="memdesc:a510a5f111e4f8442eb8f717ea60ddb02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="classevents_1_1_event_queue.html" title="EventQueue.">EventQueue</a>.  <a href="classevents_1_1_event_queue.html#a510a5f111e4f8442eb8f717ea60ddb02">More...</a><br /></td></tr>
<tr class="separator:a510a5f111e4f8442eb8f717ea60ddb02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c36db20a2779c5a46e872847892d51b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevents_1_1_event_queue.html#a4c36db20a2779c5a46e872847892d51b">~EventQueue</a> ()</td></tr>
<tr class="memdesc:a4c36db20a2779c5a46e872847892d51b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy an <a class="el" href="classevents_1_1_event_queue.html" title="EventQueue.">EventQueue</a>.  <a href="classevents_1_1_event_queue.html#a4c36db20a2779c5a46e872847892d51b">More...</a><br /></td></tr>
<tr class="separator:a4c36db20a2779c5a46e872847892d51b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35c398f754284f2d160de129f1630b95"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevents_1_1_event_queue.html#a35c398f754284f2d160de129f1630b95">dispatch_for</a> (duration ms)</td></tr>
<tr class="memdesc:a35c398f754284f2d160de129f1630b95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch events.  <a href="classevents_1_1_event_queue.html#a35c398f754284f2d160de129f1630b95">More...</a><br /></td></tr>
<tr class="separator:a35c398f754284f2d160de129f1630b95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a397fcb417425ebaa28c20b9e90ef3ed5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevents_1_1_event_queue.html#a397fcb417425ebaa28c20b9e90ef3ed5">dispatch</a> (int ms=-1)</td></tr>
<tr class="memdesc:a397fcb417425ebaa28c20b9e90ef3ed5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch events.  <a href="classevents_1_1_event_queue.html#a397fcb417425ebaa28c20b9e90ef3ed5">More...</a><br /></td></tr>
<tr class="separator:a397fcb417425ebaa28c20b9e90ef3ed5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20fa1ed24992eb10f4cf99989adeb1b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevents_1_1_event_queue.html#a20fa1ed24992eb10f4cf99989adeb1b2">dispatch_forever</a> ()</td></tr>
<tr class="memdesc:a20fa1ed24992eb10f4cf99989adeb1b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch events without a timeout.  <a href="classevents_1_1_event_queue.html#a20fa1ed24992eb10f4cf99989adeb1b2">More...</a><br /></td></tr>
<tr class="separator:a20fa1ed24992eb10f4cf99989adeb1b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b169117c200524ae974d5a0ff696a26"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevents_1_1_event_queue.html#a0b169117c200524ae974d5a0ff696a26">dispatch_once</a> ()</td></tr>
<tr class="memdesc:a0b169117c200524ae974d5a0ff696a26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch currently queued events only and then terminate.  <a href="classevents_1_1_event_queue.html#a0b169117c200524ae974d5a0ff696a26">More...</a><br /></td></tr>
<tr class="separator:a0b169117c200524ae974d5a0ff696a26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10c137935fc407c31efee923d2f128e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevents_1_1_event_queue.html#a10c137935fc407c31efee923d2f128e4">break_dispatch</a> ()</td></tr>
<tr class="memdesc:a10c137935fc407c31efee923d2f128e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Break out of a running event loop.  <a href="classevents_1_1_event_queue.html#a10c137935fc407c31efee923d2f128e4">More...</a><br /></td></tr>
<tr class="separator:a10c137935fc407c31efee923d2f128e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19703a034aad436b55e831929fcfaf4a"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevents_1_1_event_queue.html#a19703a034aad436b55e831929fcfaf4a">tick</a> ()</td></tr>
<tr class="memdesc:a19703a034aad436b55e831929fcfaf4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Millisecond counter.  <a href="classevents_1_1_event_queue.html#a19703a034aad436b55e831929fcfaf4a">More...</a><br /></td></tr>
<tr class="separator:a19703a034aad436b55e831929fcfaf4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ccb4f1222149f37161430fa2f1974e4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevents_1_1_event_queue.html#a9ccb4f1222149f37161430fa2f1974e4">cancel</a> (int id)</td></tr>
<tr class="memdesc:a9ccb4f1222149f37161430fa2f1974e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel an in-flight event.  <a href="classevents_1_1_event_queue.html#a9ccb4f1222149f37161430fa2f1974e4">More...</a><br /></td></tr>
<tr class="separator:a9ccb4f1222149f37161430fa2f1974e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0646b0dda4cd9ef0ad3fee8af155437d"><td class="memTemplParams" colspan="2">template&lt;typename F , typename A &gt; </td></tr>
<tr class="memitem:a0646b0dda4cd9ef0ad3fee8af155437d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classevents_1_1_event_queue.html#a0646b0dda4cd9ef0ad3fee8af155437d">cancel</a> (<a class="el" href="classevents_1_1_user_allocated_event.html">UserAllocatedEvent</a>&lt; F, A &gt; *<a class="el" href="classevents_1_1_event_queue.html#a5198d7f52a9a05f07871a126a037a092">event</a>)</td></tr>
<tr class="memdesc:a0646b0dda4cd9ef0ad3fee8af155437d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel an in-flight user allocated event.  <a href="classevents_1_1_event_queue.html#a0646b0dda4cd9ef0ad3fee8af155437d">More...</a><br /></td></tr>
<tr class="separator:a0646b0dda4cd9ef0ad3fee8af155437d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac68ca9d11bae073b9fbca4468e310626"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevents_1_1_event_queue.html#ac68ca9d11bae073b9fbca4468e310626">time_left</a> (int id)</td></tr>
<tr class="memdesc:ac68ca9d11bae073b9fbca4468e310626"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query how much time is left for delayed event.  <a href="classevents_1_1_event_queue.html#ac68ca9d11bae073b9fbca4468e310626">More...</a><br /></td></tr>
<tr class="separator:ac68ca9d11bae073b9fbca4468e310626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dcfb23e6d17faaa4f7579744bb7e8b5"><td class="memTemplParams" colspan="2">template&lt;typename F , typename A &gt; </td></tr>
<tr class="memitem:a4dcfb23e6d17faaa4f7579744bb7e8b5"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classevents_1_1_event_queue.html#a4dcfb23e6d17faaa4f7579744bb7e8b5">time_left</a> (<a class="el" href="classevents_1_1_user_allocated_event.html">UserAllocatedEvent</a>&lt; F, A &gt; *<a class="el" href="classevents_1_1_event_queue.html#a5198d7f52a9a05f07871a126a037a092">event</a>)</td></tr>
<tr class="memdesc:a4dcfb23e6d17faaa4f7579744bb7e8b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query how much time is left for delayed <a class="el" href="classevents_1_1_user_allocated_event.html">UserAllocatedEvent</a>.  <a href="classevents_1_1_event_queue.html#a4dcfb23e6d17faaa4f7579744bb7e8b5">More...</a><br /></td></tr>
<tr class="separator:a4dcfb23e6d17faaa4f7579744bb7e8b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc2f99a102e2ef44a83d037b3662c27c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevents_1_1_event_queue.html#abc2f99a102e2ef44a83d037b3662c27c">background</a> (<a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; void(int)&gt; update)</td></tr>
<tr class="memdesc:abc2f99a102e2ef44a83d037b3662c27c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Background an event queue onto a single-shot timer-interrupt.  <a href="classevents_1_1_event_queue.html#abc2f99a102e2ef44a83d037b3662c27c">More...</a><br /></td></tr>
<tr class="separator:abc2f99a102e2ef44a83d037b3662c27c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ee10b41d4798e303389d0c301b11f48"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevents_1_1_event_queue.html#a8ee10b41d4798e303389d0c301b11f48">chain</a> (<a class="el" href="classevents_1_1_event_queue.html">EventQueue</a> *target)</td></tr>
<tr class="memdesc:a8ee10b41d4798e303389d0c301b11f48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chain an event queue onto another event queue.  <a href="classevents_1_1_event_queue.html#a8ee10b41d4798e303389d0c301b11f48">More...</a><br /></td></tr>
<tr class="separator:a8ee10b41d4798e303389d0c301b11f48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ac68397043137fd5c8de45b778b6ab9"><td class="memTemplParams" colspan="2">template&lt;typename F , typename ... Args&gt; </td></tr>
<tr class="memitem:a5ac68397043137fd5c8de45b778b6ab9"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classevents_1_1_event_queue.html#a5ac68397043137fd5c8de45b778b6ab9">call</a> (F f, Args ...args)</td></tr>
<tr class="memdesc:a5ac68397043137fd5c8de45b778b6ab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls an event on the queue.  <a href="classevents_1_1_event_queue.html#a5ac68397043137fd5c8de45b778b6ab9">More...</a><br /></td></tr>
<tr class="separator:a5ac68397043137fd5c8de45b778b6ab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad345e3c8529a42b0fa2593eaa02f4f65"><td class="memTemplParams" colspan="2">template&lt;typename T , typename R , typename ... Args&gt; </td></tr>
<tr class="memitem:ad345e3c8529a42b0fa2593eaa02f4f65"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classevents_1_1_event_queue.html#ad345e3c8529a42b0fa2593eaa02f4f65">call</a> (T *obj, R(T::*method)(Args ...args), Args ...args)</td></tr>
<tr class="memdesc:ad345e3c8529a42b0fa2593eaa02f4f65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls an event on the queue.  <a href="classevents_1_1_event_queue.html#ad345e3c8529a42b0fa2593eaa02f4f65">More...</a><br /></td></tr>
<tr class="separator:ad345e3c8529a42b0fa2593eaa02f4f65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa79e7e9c08170c8473140079ad27b9d6"><td class="memTemplParams" colspan="2">template&lt;typename F , typename ... ArgTs&gt; </td></tr>
<tr class="memitem:aa79e7e9c08170c8473140079ad27b9d6"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classevents_1_1_event_queue.html#aa79e7e9c08170c8473140079ad27b9d6">call_in</a> (duration ms, F f, ArgTs ...args)</td></tr>
<tr class="memdesc:aa79e7e9c08170c8473140079ad27b9d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls an event on the queue after a specified delay.  <a href="classevents_1_1_event_queue.html#aa79e7e9c08170c8473140079ad27b9d6">More...</a><br /></td></tr>
<tr class="separator:aa79e7e9c08170c8473140079ad27b9d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0180bd73e84949b6fc1bc2ad4787f47f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename R , typename ... ArgTs&gt; </td></tr>
<tr class="memitem:a0180bd73e84949b6fc1bc2ad4787f47f"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classevents_1_1_event_queue.html#a0180bd73e84949b6fc1bc2ad4787f47f">call_in</a> (duration ms, T *obj, R(T::*method)(ArgTs ...args), ArgTs ...args)</td></tr>
<tr class="memdesc:a0180bd73e84949b6fc1bc2ad4787f47f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls an event on the queue after a specified delay.  <a href="classevents_1_1_event_queue.html#a0180bd73e84949b6fc1bc2ad4787f47f">More...</a><br /></td></tr>
<tr class="separator:a0180bd73e84949b6fc1bc2ad4787f47f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43fa65dd7bcdf10129f8e8bb19275baf"><td class="memTemplParams" colspan="2">template&lt;typename F , typename ... ArgTs&gt; </td></tr>
<tr class="memitem:a43fa65dd7bcdf10129f8e8bb19275baf"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classevents_1_1_event_queue.html#a43fa65dd7bcdf10129f8e8bb19275baf">call_every</a> (duration ms, F f, ArgTs ...args)</td></tr>
<tr class="memdesc:a43fa65dd7bcdf10129f8e8bb19275baf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls an event on the queue periodically.  <a href="classevents_1_1_event_queue.html#a43fa65dd7bcdf10129f8e8bb19275baf">More...</a><br /></td></tr>
<tr class="separator:a43fa65dd7bcdf10129f8e8bb19275baf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dbf4fd9261a6cbfd03afce1f5a914e0"><td class="memTemplParams" colspan="2">template&lt;typename T , typename R , typename ... ArgTs&gt; </td></tr>
<tr class="memitem:a9dbf4fd9261a6cbfd03afce1f5a914e0"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classevents_1_1_event_queue.html#a9dbf4fd9261a6cbfd03afce1f5a914e0">call_every</a> (duration ms, T *obj, R(T::*method)(ArgTs ...args), ArgTs ...args)</td></tr>
<tr class="memdesc:a9dbf4fd9261a6cbfd03afce1f5a914e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls an event on the queue periodically.  <a href="classevents_1_1_event_queue.html#a9dbf4fd9261a6cbfd03afce1f5a914e0">More...</a><br /></td></tr>
<tr class="separator:a9dbf4fd9261a6cbfd03afce1f5a914e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5198d7f52a9a05f07871a126a037a092"><td class="memTemplParams" colspan="2">template&lt;typename R , typename ... BoundArgTs, typename ... ContextArgTs, typename ... ArgTs&gt; </td></tr>
<tr class="memitem:a5198d7f52a9a05f07871a126a037a092"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classevents_1_1_event.html">Event</a>&lt; void(ArgTs...)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classevents_1_1_event_queue.html#a5198d7f52a9a05f07871a126a037a092">event</a> (R(*func)(BoundArgTs..., ArgTs...), ContextArgTs ...context_args)</td></tr>
<tr class="memdesc:a5198d7f52a9a05f07871a126a037a092"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an event bound to the event queue.  <a href="classevents_1_1_event_queue.html#a5198d7f52a9a05f07871a126a037a092">More...</a><br /></td></tr>
<tr class="separator:a5198d7f52a9a05f07871a126a037a092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb02a67fcb7a3b55fc6c3872586e5646"><td class="memTemplParams" colspan="2">template&lt;typename T , typename R , typename ... BoundArgTs, typename ... ContextArgTs, typename ... ArgTs&gt; </td></tr>
<tr class="memitem:abb02a67fcb7a3b55fc6c3872586e5646"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classevents_1_1_event.html">Event</a>&lt; void(ArgTs...)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classevents_1_1_event_queue.html#abb02a67fcb7a3b55fc6c3872586e5646">event</a> (T *obj, R(T::*method)(BoundArgTs..., ArgTs...), ContextArgTs ...context_args)</td></tr>
<tr class="memdesc:abb02a67fcb7a3b55fc6c3872586e5646"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an event bound to the event queue.  <a href="classevents_1_1_event_queue.html#abb02a67fcb7a3b55fc6c3872586e5646">More...</a><br /></td></tr>
<tr class="separator:abb02a67fcb7a3b55fc6c3872586e5646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac76b79f252c09f0173e14261c56f3645"><td class="memTemplParams" colspan="2">template&lt;typename R , typename ... BoundArgTs, typename ... ContextArgTs, typename ... ArgTs&gt; </td></tr>
<tr class="memitem:ac76b79f252c09f0173e14261c56f3645"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classevents_1_1_event.html">Event</a>&lt; void(ArgTs...)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classevents_1_1_event_queue.html#ac76b79f252c09f0173e14261c56f3645">event</a> (<a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(BoundArgTs..., ArgTs...)&gt; cb, ContextArgTs ...context_args)</td></tr>
<tr class="memdesc:ac76b79f252c09f0173e14261c56f3645"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an event bound to the event queue.  <a href="classevents_1_1_event_queue.html#ac76b79f252c09f0173e14261c56f3645">More...</a><br /></td></tr>
<tr class="separator:ac76b79f252c09f0173e14261c56f3645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ad053572ff326e226ecb948fcf116cf"><td class="memTemplParams" colspan="2">template&lt;typename F , typename... ArgTs&gt; </td></tr>
<tr class="memitem:ga1ad053572ff326e226ecb948fcf116cf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classevents_1_1_user_allocated_event.html">UserAllocatedEvent</a>&lt; F, void(ArgTs...)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__events___event.html#ga1ad053572ff326e226ecb948fcf116cf">make_user_allocated_event</a> (F f, ArgTs... args)</td></tr>
<tr class="memdesc:ga1ad053572ff326e226ecb948fcf116cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an user allocated event bound to the event queue.  <a href="group__events___event.html#ga1ad053572ff326e226ecb948fcf116cf">More...</a><br /></td></tr>
<tr class="separator:ga1ad053572ff326e226ecb948fcf116cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67dc3662dcd5164ef8711bb18990c589"><td class="memTemplParams" colspan="2">template&lt;typename T , typename R , typename... ArgTs&gt; </td></tr>
<tr class="memitem:ga67dc3662dcd5164ef8711bb18990c589"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classevents_1_1_user_allocated_event.html">UserAllocatedEvent</a>&lt; <a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; void(ArgTs...)&gt;, void(ArgTs...)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__events___event.html#ga67dc3662dcd5164ef8711bb18990c589">make_user_allocated_event</a> (T *obj, R(T::*method)(ArgTs... args), ArgTs... args)</td></tr>
<tr class="memdesc:ga67dc3662dcd5164ef8711bb18990c589"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an user allocated event bound to the event queue.  <a href="group__events___event.html#ga67dc3662dcd5164ef8711bb18990c589">More...</a><br /></td></tr>
<tr class="separator:ga67dc3662dcd5164ef8711bb18990c589"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p ><a class="el" href="classevents_1_1_event_queue.html" title="EventQueue.">EventQueue</a>. </p>
<p >Flexible event queue for dispatching events </p>

<p class="definition">Definition at line <a class="el" href="_event_queue_8h_source.html#l00062">62</a> of file <a class="el" href="_event_queue_8h_source.html">EventQueue.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a510a5f111e4f8442eb8f717ea60ddb02" name="a510a5f111e4f8442eb8f717ea60ddb02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a510a5f111e4f8442eb8f717ea60ddb02">&#9670;&#160;</a></span>EventQueue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classevents_1_1_event_queue.html">EventQueue</a> </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>size</em> = <code>(32&#160;*(EQUEUE_EVENT_SIZE&#160;-&#160;2&#160;*sizeof(void&#160;*)+sizeof(<a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt;&#160;void()&gt;)))</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an <a class="el" href="classevents_1_1_event_queue.html" title="EventQueue.">EventQueue</a>. </p>
<p >Create an event queue. The event queue either allocates a buffer of the specified size with malloc or uses the user provided buffer or uses 1B dummy buffer if 0 size passed.</p>
<p >0 size queue is a special purpose queue to dispatch static events only (see <a class="el" href="classevents_1_1_user_allocated_event.html">UserAllocatedEvent</a>). Such a queue gives the guarantee that no dynamic memory allocation will take place while queue creation and events posting &amp; dispatching.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Size of buffer to use for events in bytes (default to EVENTS_QUEUE_SIZE) If 0 provided then 1B dummy buffer is used </td></tr>
    <tr><td class="paramname">buffer</td><td>Pointer to buffer to use for events (default to NULL) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4c36db20a2779c5a46e872847892d51b" name="a4c36db20a2779c5a46e872847892d51b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c36db20a2779c5a46e872847892d51b">&#9670;&#160;</a></span>~EventQueue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="classevents_1_1_event_queue.html">EventQueue</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy an <a class="el" href="classevents_1_1_event_queue.html" title="EventQueue.">EventQueue</a>. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a35c398f754284f2d160de129f1630b95" name="a35c398f754284f2d160de129f1630b95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35c398f754284f2d160de129f1630b95">&#9670;&#160;</a></span>dispatch_for()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dispatch_for </td>
          <td>(</td>
          <td class="paramtype">duration&#160;</td>
          <td class="paramname"><em>ms</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dispatch events. </p>
<p >Executes events for the specified number of milliseconds.</p>
<p >The <a class="el" href="classevents_1_1_event_queue.html#a35c398f754284f2d160de129f1630b95" title="Dispatch events.">dispatch_for()</a> function is guaranteed to terminate after the elapsed wait.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ms</td><td>Time to wait for events in milliseconds, expressed as a Chrono duration. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a397fcb417425ebaa28c20b9e90ef3ed5" name="a397fcb417425ebaa28c20b9e90ef3ed5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a397fcb417425ebaa28c20b9e90ef3ed5">&#9670;&#160;</a></span>dispatch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dispatch </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ms</em> = <code>-1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dispatch events. </p>
<p >Executes events until the specified milliseconds have passed. If ms is negative, the dispatch function will dispatch events indefinitely or until break_dispatch is called on this queue.</p>
<p >When called with a finite timeout, the dispatch function is guaranteed to terminate. When called with a timeout of 0, the dispatch function does not wait and is IRQ safe.</p>
<p >NOTE: Since the majority of the event library was updated to use Chrono types (as part of the Mbed 6 release), this function will not function as expected. Please update to use the new dispatch functions to ensure correct functionality.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ms</td><td>Time to wait for events in milliseconds, a negative value will dispatch events indefinitely (default to -1) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a20fa1ed24992eb10f4cf99989adeb1b2" name="a20fa1ed24992eb10f4cf99989adeb1b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20fa1ed24992eb10f4cf99989adeb1b2">&#9670;&#160;</a></span>dispatch_forever()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dispatch_forever </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dispatch events without a timeout. </p>
<p >Executes events indefinitely unless the dispatch loop is forcibly broken. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classevents_1_1_event_queue.html#a10c137935fc407c31efee923d2f128e4" title="Break out of a running event loop.">break_dispatch()</a> </dd></dl>

</div>
</div>
<a id="a0b169117c200524ae974d5a0ff696a26" name="a0b169117c200524ae974d5a0ff696a26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b169117c200524ae974d5a0ff696a26">&#9670;&#160;</a></span>dispatch_once()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dispatch_once </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dispatch currently queued events only and then terminate. </p>
<p >In this case the dispatch function does not wait. </p>

</div>
</div>
<a id="a10c137935fc407c31efee923d2f128e4" name="a10c137935fc407c31efee923d2f128e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10c137935fc407c31efee923d2f128e4">&#9670;&#160;</a></span>break_dispatch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void break_dispatch </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Break out of a running event loop. </p>
<p >Forces the specified event queue's dispatch loop to terminate. Pending events may finish executing, but no new events will be executed. </p>

</div>
</div>
<a id="a19703a034aad436b55e831929fcfaf4a" name="a19703a034aad436b55e831929fcfaf4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19703a034aad436b55e831929fcfaf4a">&#9670;&#160;</a></span>tick()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned tick </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Millisecond counter. </p>
<p >Returns the underlying tick of the event queue represented as the number of milliseconds that have passed since an arbitrary point in time. Intentionally overflows to 0 after 2^32-1.</p>
<dl class="section return"><dt>Returns</dt><dd>The underlying tick of the event queue in milliseconds </dd></dl>

</div>
</div>
<a id="a9ccb4f1222149f37161430fa2f1974e4" name="a9ccb4f1222149f37161430fa2f1974e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ccb4f1222149f37161430fa2f1974e4">&#9670;&#160;</a></span>cancel() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cancel </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cancel an in-flight event. </p>
<p >Attempts to cancel an event referenced by the unique id returned from one of the call functions. It is not safe to call cancel after an event has already been dispatched.</p>
<p >id must be valid i.e. event must have not finished executing.</p>
<p >The cancel function is IRQ safe.</p>
<p >If called while the event queue's dispatch loop is active in another thread, the cancel function does not guarantee that the event will not execute after it returns, as the event may have already begun executing. A call made from the same thread as the dispatch loop will always succeed with a valid id.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Unique id of the event </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if event was successfully cancelled false if event was not cancelled (invalid id or executing already begun) </dd></dl>

</div>
</div>
<a id="a0646b0dda4cd9ef0ad3fee8af155437d" name="a0646b0dda4cd9ef0ad3fee8af155437d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0646b0dda4cd9ef0ad3fee8af155437d">&#9670;&#160;</a></span>cancel() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cancel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classevents_1_1_user_allocated_event.html">UserAllocatedEvent</a>&lt; F, A &gt; *&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cancel an in-flight user allocated event. </p>
<p >Attempts to cancel an <a class="el" href="classevents_1_1_user_allocated_event.html">UserAllocatedEvent</a> referenced by its address It is not safe to call cancel after an event has already been dispatched.</p>
<p ><a class="el" href="classevents_1_1_event.html" title="Event.">Event</a> must be valid i.e. event must have not finished executing and must have been bound to this queue.</p>
<p >The cancel function is IRQ safe.</p>
<p >If called while the event queue's dispatch loop is active in another thread, the cancel function does not guarantee that the event will not execute after it returns, as the event may have already begun executing. A call made from the same thread as the dispatch loop will always succeed with a valid id.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>Address of the event </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if event was successfully cancelled false if event was not cancelled (invalid queue or executing already begun) </dd></dl>

<p class="definition">Definition at line <a class="el" href="_event_queue_8h_source.html#l00195">195</a> of file <a class="el" href="_event_queue_8h_source.html">EventQueue.h</a>.</p>

</div>
</div>
<a id="ac68ca9d11bae073b9fbca4468e310626" name="ac68ca9d11bae073b9fbca4468e310626"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac68ca9d11bae073b9fbca4468e310626">&#9670;&#160;</a></span>time_left() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int time_left </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query how much time is left for delayed event. </p>
<p >If the event is delayed, this function can be used to query how much time is left until the event is due to be dispatched.</p>
<p >id must be valid i.e. event must have not finished executing.</p>
<p >This function is IRQ safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Unique id of the event</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Remaining time in milliseconds or 0 if event is already due to be dispatched or is currently executing. Undefined if id is invalid. </dd></dl>

</div>
</div>
<a id="a4dcfb23e6d17faaa4f7579744bb7e8b5" name="a4dcfb23e6d17faaa4f7579744bb7e8b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dcfb23e6d17faaa4f7579744bb7e8b5">&#9670;&#160;</a></span>time_left() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int time_left </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classevents_1_1_user_allocated_event.html">UserAllocatedEvent</a>&lt; F, A &gt; *&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query how much time is left for delayed <a class="el" href="classevents_1_1_user_allocated_event.html">UserAllocatedEvent</a>. </p>
<p >If the event is delayed, this function can be used to query how much time is left until the event is due to be dispatched.</p>
<p ><a class="el" href="classevents_1_1_event.html" title="Event.">Event</a> must be valid i.e. event must have not finished executing and must have been bound to this queue.</p>
<p >This function is IRQ safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>Address of the event</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Remaining time in milliseconds or 0 if event is already due to be dispatched or is currently executing. Undefined if id is invalid. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_event_queue_8h_source.html#l00241">241</a> of file <a class="el" href="_event_queue_8h_source.html">EventQueue.h</a>.</p>

</div>
</div>
<a id="abc2f99a102e2ef44a83d037b3662c27c" name="abc2f99a102e2ef44a83d037b3662c27c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc2f99a102e2ef44a83d037b3662c27c">&#9670;&#160;</a></span>background()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void background </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; void(int)&gt;&#160;</td>
          <td class="paramname"><em>update</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Background an event queue onto a single-shot timer-interrupt. </p>
<p >When updated, the event queue will call the provided update function with a timeout indicating when the queue should be dispatched. A negative timeout will be passed to the update function when the timer-interrupt is no longer needed.</p>
<p >Passing a null function disables the existing update function.</p>
<p >The background function allows an event queue to take advantage of hardware timers or other event loops, allowing an event queue to be ran in the background without consuming the foreground thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">update</td><td>Function called to indicate when the queue should be dispatched </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8ee10b41d4798e303389d0c301b11f48" name="a8ee10b41d4798e303389d0c301b11f48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ee10b41d4798e303389d0c301b11f48">&#9670;&#160;</a></span>chain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int chain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classevents_1_1_event_queue.html">EventQueue</a> *&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Chain an event queue onto another event queue. </p>
<p >After chaining a queue to a target, calling dispatch on the target queue will also dispatch events from this queue. The queues use their own buffers and events must be handled independently.</p>
<p >A null queue as the target will unchain the existing queue.</p>
<p >The chain function allows multiple event queues to be composed, sharing the context of a dispatch loop while still being managed independently</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>Queue that will dispatch this queue's events as a part of its dispatch loop</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero on success and negative error code value if chaining fails </dd></dl>

</div>
</div>
<a id="a5ac68397043137fd5c8de45b778b6ab9" name="a5ac68397043137fd5c8de45b778b6ab9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ac68397043137fd5c8de45b778b6ab9">&#9670;&#160;</a></span>call() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int call </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args ...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls an event on the queue. </p>
<p >The specified callback will be executed in the context of the event queue's dispatch loop.</p>
<p >The call function is IRQ safe and can act as a mechanism for moving events out of IRQ contexts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Function to execute in the context of the dispatch loop </td></tr>
    <tr><td class="paramname">args</td><td>Arguments to pass to the callback </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A unique id that represents the posted event and can be passed to cancel, or an id of 0 if there is not enough memory to allocate the event. Returned id will remain valid until event has finished executing.</dd></dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;mbed.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="comment">// creates a queue with the default size</span></div>
<div class="line">    <a class="code hl_class" href="classevents_1_1_event_queue.html">EventQueue</a> queue;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// events are simple callbacks</span></div>
<div class="line">    queue.<a class="code hl_function" href="classevents_1_1_event_queue.html#a5ac68397043137fd5c8de45b778b6ab9">call</a>(printf, <span class="stringliteral">&quot;called immediately\n&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// the dispatch method executes events</span></div>
<div class="line">    queue.<a class="code hl_function" href="classevents_1_1_event_queue.html#a397fcb417425ebaa28c20b9e90ef3ed5">dispatch</a>();</div>
<div class="line">}</div>
<div class="ttc" id="aclassevents_1_1_event_queue_html"><div class="ttname"><a href="classevents_1_1_event_queue.html">events::EventQueue</a></div><div class="ttdoc">EventQueue.</div><div class="ttdef"><b>Definition:</b> <a href="_event_queue_8h_source.html#l00062">EventQueue.h:62</a></div></div>
<div class="ttc" id="aclassevents_1_1_event_queue_html_a397fcb417425ebaa28c20b9e90ef3ed5"><div class="ttname"><a href="classevents_1_1_event_queue.html#a397fcb417425ebaa28c20b9e90ef3ed5">events::EventQueue::dispatch</a></div><div class="ttdeci">void dispatch(int ms=-1)</div><div class="ttdoc">Dispatch events.</div></div>
<div class="ttc" id="aclassevents_1_1_event_queue_html_a5ac68397043137fd5c8de45b778b6ab9"><div class="ttname"><a href="classevents_1_1_event_queue.html#a5ac68397043137fd5c8de45b778b6ab9">events::EventQueue::call</a></div><div class="ttdeci">int call(F f, Args ...args)</div><div class="ttdoc">Calls an event on the queue.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ad345e3c8529a42b0fa2593eaa02f4f65" name="ad345e3c8529a42b0fa2593eaa02f4f65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad345e3c8529a42b0fa2593eaa02f4f65">&#9670;&#160;</a></span>call() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int call </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(Args ...args)&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args ...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls an event on the queue. </p>
<p >The specified callback is executed in the context of the event queue's dispatch loop.</p>
<p >The call function is IRQ safe and can act as a mechanism for moving events out of IRQ contexts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Object to call with the member function </td></tr>
    <tr><td class="paramname">method</td><td>Member function to execute in the context of the dispatch loop </td></tr>
    <tr><td class="paramname">args</td><td>Arguments to pass to the callback </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A unique ID that represents the posted event and can be passed to cancel, or an ID of 0 if there is not enough memory to allocate the event. Returned ID remains valid until event has finished executing.</dd></dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;mbed.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>EventHandler {</div>
<div class="line">    <span class="keywordtype">int</span> _id;</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    EventHandler(<span class="keywordtype">int</span> <span class="keywordtype">id</span>) : _id(id) { }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> handler(<span class="keywordtype">int</span> c) {</div>
<div class="line">        printf(<span class="stringliteral">&quot;ID: %d Param: %d\r\n&quot;</span>, _id, c);</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="comment">// creates a queue with the default size</span></div>
<div class="line">    <a class="code hl_function" href="classevents_1_1_event_queue.html#a510a5f111e4f8442eb8f717ea60ddb02">EventQueue</a> queue;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Create EventHandler object with state</span></div>
<div class="line">    EventHandler handler_cb(1);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// events are simple callbacks, call object method</span></div>
<div class="line">    <span class="comment">// with provided parameter</span></div>
<div class="line">    queue.call(&amp;handler_cb, &amp;EventHandler::handler, 2);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// the dispath method executes events</span></div>
<div class="line">    queue.dispatch();</div>
<div class="line">}</div>
<div class="ttc" id="aclassevents_1_1_event_queue_html_a510a5f111e4f8442eb8f717ea60ddb02"><div class="ttname"><a href="classevents_1_1_event_queue.html#a510a5f111e4f8442eb8f717ea60ddb02">events::EventQueue::EventQueue</a></div><div class="ttdeci">EventQueue(unsigned size=(32 *(EQUEUE_EVENT_SIZE - 2 *sizeof(void *)+sizeof(mbed::Callback&lt; void()&gt;))), unsigned char *buffer=NULL)</div><div class="ttdoc">Create an EventQueue.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="aa79e7e9c08170c8473140079ad27b9d6" name="aa79e7e9c08170c8473140079ad27b9d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa79e7e9c08170c8473140079ad27b9d6">&#9670;&#160;</a></span>call_in() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int call_in </td>
          <td>(</td>
          <td class="paramtype">duration&#160;</td>
          <td class="paramname"><em>ms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgTs ...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls an event on the queue after a specified delay. </p>
<p >The specified callback is executed in the context of the event queue's dispatch loop.</p>
<p >The call_in function is IRQ safe and can act as a mechanism for moving events out of IRQ contexts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ms</td><td>Time to delay in milliseconds </td></tr>
    <tr><td class="paramname">f</td><td>Function to execute in the context of the dispatch loop </td></tr>
    <tr><td class="paramname">args</td><td>Arguments to pass to the callback </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A unique ID that represents the posted event and can be passed to cancel, or an ID of 0 if there is not enough memory to allocate the event.</dd></dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;mbed.h&quot;</span></div>
<div class="line"><span class="keyword">using namespace </span>std::chrono_literals;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="comment">// creates a queue with the default size</span></div>
<div class="line">    <a class="code hl_class" href="classevents_1_1_event_queue.html">EventQueue</a> queue;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// events are simple callbacks</span></div>
<div class="line">    queue.<a class="code hl_function" href="classevents_1_1_event_queue.html#aa79e7e9c08170c8473140079ad27b9d6">call_in</a>(2s, printf, <span class="stringliteral">&quot;called in 2 seconds\n&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// the dispatch methods executes events</span></div>
<div class="line">    queue.<a class="code hl_function" href="classevents_1_1_event_queue.html#a397fcb417425ebaa28c20b9e90ef3ed5">dispatch</a>();</div>
<div class="line">}</div>
<div class="ttc" id="aclassevents_1_1_event_queue_html_aa79e7e9c08170c8473140079ad27b9d6"><div class="ttname"><a href="classevents_1_1_event_queue.html#aa79e7e9c08170c8473140079ad27b9d6">events::EventQueue::call_in</a></div><div class="ttdeci">int call_in(duration ms, F f, ArgTs ...args)</div><div class="ttdoc">Calls an event on the queue after a specified delay.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a0180bd73e84949b6fc1bc2ad4787f47f" name="a0180bd73e84949b6fc1bc2ad4787f47f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0180bd73e84949b6fc1bc2ad4787f47f">&#9670;&#160;</a></span>call_in() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int call_in </td>
          <td>(</td>
          <td class="paramtype">duration&#160;</td>
          <td class="paramname"><em>ms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(ArgTs ...args)&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgTs ...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls an event on the queue after a specified delay. </p>
<p >The specified callback is executed in the context of the event queue's dispatch loop.</p>
<p >The call_in function is IRQ safe and can act as a mechanism for moving events out of IRQ contexts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ms</td><td>Time to delay in milliseconds </td></tr>
    <tr><td class="paramname">obj</td><td>Object to call with the member function </td></tr>
    <tr><td class="paramname">method</td><td>Member function to execute in the context of the dispatch loop </td></tr>
    <tr><td class="paramname">args</td><td>Arguments to pass to the callback </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A unique ID that represents the posted event and can be passed to cancel, or an ID of 0 if there is not enough memory to allocate the event.</dd></dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;mbed.h&quot;</span></div>
<div class="line"><span class="keyword">using namespace </span>std::chrono_literals;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>EventHandler {</div>
<div class="line">    <span class="keywordtype">int</span> _id;</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    EventHandler(<span class="keywordtype">int</span> <span class="keywordtype">id</span>) : _id(id) { }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> handler(<span class="keywordtype">int</span> c) {</div>
<div class="line">        printf(<span class="stringliteral">&quot;ID: %d Param: %d\r\n&quot;</span>, _id, c);</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="comment">// creates a queue with the default size</span></div>
<div class="line">    <a class="code hl_function" href="classevents_1_1_event_queue.html#a510a5f111e4f8442eb8f717ea60ddb02">EventQueue</a> queue;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Create EventHandler object with state</span></div>
<div class="line">    EventHandler handler_cb(3);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// events are simple callbacks, call object method in 2 seconds</span></div>
<div class="line">    <span class="comment">// with provided parameter</span></div>
<div class="line">    queue.call_in(2s, &amp;handler_cb, &amp;EventHandler::handler, 4);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// the dispatch method executes events</span></div>
<div class="line">    queue.dispatch();</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a43fa65dd7bcdf10129f8e8bb19275baf" name="a43fa65dd7bcdf10129f8e8bb19275baf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43fa65dd7bcdf10129f8e8bb19275baf">&#9670;&#160;</a></span>call_every() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int call_every </td>
          <td>(</td>
          <td class="paramtype">duration&#160;</td>
          <td class="paramname"><em>ms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgTs ...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls an event on the queue periodically. </p>
<dl class="section note"><dt>Note</dt><dd>The first call_every event occurs after the specified delay. To create a periodic event that fires immediately, </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classevents_1_1_event.html" title="Event.">Event</a>.</dd></dl>
<p>The specified callback is executed in the context of the event queue's dispatch loop.</p>
<p >The call_every function is IRQ safe and can act as a mechanism for moving events out of IRQ contexts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ms</td><td>Period of the event in milliseconds </td></tr>
    <tr><td class="paramname">f</td><td>Function to execute in the context of the dispatch loop </td></tr>
    <tr><td class="paramname">args</td><td>Arguments to pass to the callback </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A unique ID that represents the posted event and can be passed to cancel, or an ID of 0 if there is not enough memory to allocate the event.</dd></dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;mbed.h&quot;</span></div>
<div class="line"><span class="keyword">using namespace </span>std::chrono_literals;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>EventHandler {</div>
<div class="line">    <span class="keywordtype">int</span> _id;</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    EventHandler(<span class="keywordtype">int</span> <span class="keywordtype">id</span>) : _id(id) { }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> handler(<span class="keywordtype">int</span> c) {</div>
<div class="line">        printf(<span class="stringliteral">&quot;ID: %d Param: %d\r\n&quot;</span>, _id, c);</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="comment">// creates a queue with the default size</span></div>
<div class="line">    <a class="code hl_function" href="classevents_1_1_event_queue.html#a510a5f111e4f8442eb8f717ea60ddb02">EventQueue</a> queue;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// events are simple callbacks, call every 2 seconds</span></div>
<div class="line">    queue.call_every(2s, printf, <span class="stringliteral">&quot;Calling every 2 seconds\n&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// the dispatch method executes events</span></div>
<div class="line">    queue.dispatch();</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a9dbf4fd9261a6cbfd03afce1f5a914e0" name="a9dbf4fd9261a6cbfd03afce1f5a914e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dbf4fd9261a6cbfd03afce1f5a914e0">&#9670;&#160;</a></span>call_every() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int call_every </td>
          <td>(</td>
          <td class="paramtype">duration&#160;</td>
          <td class="paramname"><em>ms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(ArgTs ...args)&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgTs ...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls an event on the queue periodically. </p>
<dl class="section note"><dt>Note</dt><dd>The first call_every event occurs after the specified delay. To create a periodic event that fires immediately, </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classevents_1_1_event.html" title="Event.">Event</a>.</dd></dl>
<p>The specified callback is executed in the context of the event queue's dispatch loop.</p>
<p >The call_every function is IRQ safe and can act as a mechanism for moving events out of IRQ contexts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ms</td><td>Period of the event in milliseconds </td></tr>
    <tr><td class="paramname">obj</td><td>Object to call with the member function </td></tr>
    <tr><td class="paramname">method</td><td>Member function to execute in the context of the dispatch loop </td></tr>
    <tr><td class="paramname">args</td><td>Arguments to pass to the callback</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;mbed.h&quot;</span></div>
<div class="line"><span class="keyword">using namespace </span>std::chrono_literals;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>EventHandler {</div>
<div class="line">    <span class="keywordtype">int</span> _id;</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    EventHandler(<span class="keywordtype">int</span> <span class="keywordtype">id</span>) : _id(id) { }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> handler(<span class="keywordtype">int</span> c) {</div>
<div class="line">        printf(<span class="stringliteral">&quot;ID: %d Param: %d\r\n&quot;</span>, _id, c);</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="comment">// creates a queue with the default size</span></div>
<div class="line">    <a class="code hl_function" href="classevents_1_1_event_queue.html#a510a5f111e4f8442eb8f717ea60ddb02">EventQueue</a> queue;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Create EventHandler object with state</span></div>
<div class="line">    EventHandler handler_cb(5);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// events are simple callbacks, call object method every 2 seconds</span></div>
<div class="line">    <span class="comment">// with provided parameter</span></div>
<div class="line">    queue.call_every(2s, &amp;handler_cb, &amp;EventHandler::handler, 6);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// the dispatch method executes events</span></div>
<div class="line">    queue.dispatch();</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a5198d7f52a9a05f07871a126a037a092" name="a5198d7f52a9a05f07871a126a037a092"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5198d7f52a9a05f07871a126a037a092">&#9670;&#160;</a></span>event() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classevents_1_1_event.html">Event</a>&lt; void(ArgTs...)&gt; event </td>
          <td>(</td>
          <td class="paramtype">R(*)(BoundArgTs..., ArgTs...)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContextArgTs ...&#160;</td>
          <td class="paramname"><em>context_args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an event bound to the event queue. </p>
<p >Constructs an event bound to the specified event queue. The specified callback acts as the target for the event and is executed in the context of the event queue's dispatch loop once posted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Function to execute when the event is dispatched </td></tr>
    <tr><td class="paramname">context_args</td><td>Arguments to pass to the callback </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classevents_1_1_event.html" title="Event.">Event</a> that dispatches on the specific queue</dd></dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;mbed.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> handler(<span class="keywordtype">int</span> c) {</div>
<div class="line">    printf(<span class="stringliteral">&quot;Param: %d\r\n&quot;</span>, c);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_class" href="classevents_1_1_event_queue.html">EventQueue</a> queue;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Create event with parameter</span></div>
<div class="line">    <a class="code hl_class" href="classevents_1_1_event.html">Event</a>&lt;void()&gt;    e  = queue.<a class="code hl_function" href="classevents_1_1_event_queue.html#a5198d7f52a9a05f07871a126a037a092">event</a>(handler, 1);</div>
<div class="line">    e();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Create event and post parameter later</span></div>
<div class="line">    <a class="code hl_class" href="classevents_1_1_event.html">Event</a>&lt;void(<span class="keywordtype">int</span>)&gt; e2 = queue.<a class="code hl_function" href="classevents_1_1_event_queue.html#a5198d7f52a9a05f07871a126a037a092">event</a>(handler);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Post the event with paramter 8</span></div>
<div class="line">    e.post(8);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// The dispatch method executes events</span></div>
<div class="line">    queue.<a class="code hl_function" href="classevents_1_1_event_queue.html#a397fcb417425ebaa28c20b9e90ef3ed5">dispatch</a>();</div>
<div class="line"> </div>
<div class="line">    e2.post(2);</div>
<div class="line"> </div>
<div class="line">    queue.<a class="code hl_function" href="classevents_1_1_event_queue.html#a397fcb417425ebaa28c20b9e90ef3ed5">dispatch</a>();</div>
<div class="line">}</div>
<div class="ttc" id="aclassevents_1_1_event_html"><div class="ttname"><a href="classevents_1_1_event.html">events::Event</a></div><div class="ttdoc">Event.</div><div class="ttdef"><b>Definition:</b> <a href="_event_8h_source.html#l00038">Event.h:38</a></div></div>
<div class="ttc" id="aclassevents_1_1_event_queue_html_a5198d7f52a9a05f07871a126a037a092"><div class="ttname"><a href="classevents_1_1_event_queue.html#a5198d7f52a9a05f07871a126a037a092">events::EventQueue::event</a></div><div class="ttdeci">Event&lt; void(ArgTs...)&gt; event(R(*func)(BoundArgTs..., ArgTs...), ContextArgTs ...context_args)</div><div class="ttdoc">Creates an event bound to the event queue.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="abb02a67fcb7a3b55fc6c3872586e5646" name="abb02a67fcb7a3b55fc6c3872586e5646"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb02a67fcb7a3b55fc6c3872586e5646">&#9670;&#160;</a></span>event() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classevents_1_1_event.html">Event</a>&lt; void(ArgTs...)&gt; event </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(BoundArgTs..., ArgTs...)&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContextArgTs ...&#160;</td>
          <td class="paramname"><em>context_args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an event bound to the event queue. </p>
<p >Constructs an event bound to the specified event queue. The specified callback acts as the target for the event and is executed in the context of the event queue's dispatch loop once posted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Object to call with the member function </td></tr>
    <tr><td class="paramname">method</td><td>Member function to execute in the context of the dispatch loop </td></tr>
    <tr><td class="paramname">context_args</td><td>Arguments to pass to the callback </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classevents_1_1_event.html" title="Event.">Event</a> that dispatches on the specific queue</dd></dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;mbed.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>EventHandler {</div>
<div class="line">    <span class="keywordtype">int</span> _id;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    EventHandler(<span class="keywordtype">int</span> <span class="keywordtype">id</span>) : _id(id) { }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> handler(<span class="keywordtype">int</span> c) {</div>
<div class="line">        printf(<span class="stringliteral">&quot;ID: %d Param: %d\r\n&quot;</span>, _id, c);</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_function" href="classevents_1_1_event_queue.html#a510a5f111e4f8442eb8f717ea60ddb02">EventQueue</a> queue;</div>
<div class="line"> </div>
<div class="line">    EventHandler handler_cb(10);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Create event on the eventqueue with a method callback</span></div>
<div class="line">    Event&lt;void(<span class="keywordtype">int</span>)&gt; e = queue.event(&amp;handler_cb, &amp;EventHandler::handler);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Post the event with paramter 8</span></div>
<div class="line">    e.post(11);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// The dispatch method executes events</span></div>
<div class="line">    queue.dispatch();</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ac76b79f252c09f0173e14261c56f3645" name="ac76b79f252c09f0173e14261c56f3645"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac76b79f252c09f0173e14261c56f3645">&#9670;&#160;</a></span>event() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classevents_1_1_event.html">Event</a>&lt; void(ArgTs...)&gt; event </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback</a>&lt; R(BoundArgTs..., ArgTs...)&gt;&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContextArgTs ...&#160;</td>
          <td class="paramname"><em>context_args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an event bound to the event queue. </p>
<p >Constructs an event bound to the specified event queue. The specified callback acts as the target for the event and is executed in the context of the event queue's dispatch loop once posted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb</td><td>Callback object </td></tr>
    <tr><td class="paramname">context_args</td><td>Arguments to pass to the callback </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classevents_1_1_event.html" title="Event.">Event</a> that dispatches on the specific queue</dd></dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;mbed.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> handler(<span class="keywordtype">int</span> c) {</div>
<div class="line">    printf(<span class="stringliteral">&quot;Param: %d\r\n&quot;</span>, c);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_class" href="classevents_1_1_event_queue.html">EventQueue</a> queue;</div>
<div class="line">    <span class="comment">// Create callback object acting as a function</span></div>
<div class="line">    <span class="comment">// pointer to handler</span></div>
<div class="line">    Callback&lt;void(<span class="keywordtype">int</span>)&gt; cb(handler);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Pass the callback object to the eventqueue</span></div>
<div class="line">    <a class="code hl_class" href="classevents_1_1_event.html">Event</a>&lt;void(<span class="keywordtype">int</span>)&gt; e = queue.<a class="code hl_function" href="classevents_1_1_event_queue.html#a5198d7f52a9a05f07871a126a037a092">event</a>(cb);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Post the event with parameter 8</span></div>
<div class="line">    e.post(9);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// The dispatch method executes events</span></div>
<div class="line">    q.dispatch();</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>events</b></li><li class="navelem"><a class="el" href="classevents_1_1_event_queue.html">EventQueue</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>
